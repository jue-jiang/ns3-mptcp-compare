diff --git a/examples/tcp/mptcp.cc b/examples/tcp/mptcp.cc
deleted file mode 100644
index e5b2f84..0000000
--- a/examples/tcp/mptcp.cc
+++ /dev/null
@@ -1,703 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- *
- */
-
-#include "ns3/test.h"
-#include "ns3/socket-factory.h"
-#include "ns3/tcp-socket-factory.h"
-#include "ns3/simulator.h"
-#include "ns3/simple-channel.h"
-#include "ns3/simple-net-device.h"
-#include "ns3/drop-tail-queue.h"
-#include "ns3/config.h"
-#include "ns3/ipv4-static-routing.h"
-#include "ns3/ipv4-list-routing.h"
-#include "ns3/ipv6-static-routing.h"
-#include "ns3/ipv6-list-routing.h"
-#include "ns3/node.h"
-#include "ns3/inet-socket-address.h"
-#include "ns3/inet6-socket-address.h"
-#include "ns3/uinteger.h"
-#include "ns3/log.h"
-#include "ns3/string.h"
-#include "ns3/tcp-socket-base.h"
-#include "ns3/mptcp-socket-base.h"
-#include "ns3/mptcp-subflow.h"
-
-// Test to get netanim working
-#include "ns3/netanim-module.h"
-#include "ns3/constant-position-mobility-model.h"
-
-#include "ns3/ipv4-end-point.h"
-#include "ns3/arp-l3-protocol.h"
-#include "ns3/ipv4-l3-protocol.h"
-#include "ns3/ipv6-l3-protocol.h"
-#include "ns3/icmpv4-l4-protocol.h"
-#include "ns3/icmpv6-l4-protocol.h"
-#include "ns3/udp-l4-protocol.h"
-#include "ns3/tcp-l4-protocol.h"
-#include "ns3/trace-helper.h"
-#include "ns3/point-to-point-helper.h"
-#include "ns3/ipv4-address-helper.h"
-#include "ns3/sequence-number.h"
-#include "ns3/trace-helper.h"
-#include "ns3/global-route-manager.h"
-#include "ns3/abort.h"
-#include "ns3/tcp-trace-helper.h"
-// Copy
-#include <string>
-#include <fstream>
-#include "ns3/core-module.h"
-#include "ns3/point-to-point-module.h"
-#include "ns3/internet-module.h"
-#include "ns3/applications-module.h"
-#include "ns3/network-module.h"
-#include "ns3/packet-sink.h"
-
-#include <string>
-#include <fstream>
-
-NS_LOG_COMPONENT_DEFINE ("MpTcpExample");
-
-using namespace ns3;
-
-//std::ofstream source_f;
-//std::ofstream server_f;
-
-// rename to serverPort
-const uint16_t serverPort = 50000;
-
-
-// Check dce-iperf-mptcp
-void setPos (Ptr<Node> n, int x, int y, int z)
-{
-  Ptr<ConstantPositionMobilityModel> loc = CreateObject<ConstantPositionMobilityModel> ();
-  n->AggregateObject (loc);
-  Vector locVec2 (x, y, z);
-  loc->SetPosition (locVec2);
-}
-
-
-/**
-TODO name generation could be moved to tcp-trace-helper ?!
-TODO prefixer avec nom de la meta etc...
-**/
-void
-OnNewSocket (Ptr<TcpSocket> socket)
-{
-  NS_LOG_DEBUG ("New socket incoming");
-  
-  TcpTraceHelper tcpHelper;
-  std::stringstream os;
-  //! we start at 1 because it's nicer
-  // m_tracePrefix << 
-  static int subflowCounter = 0;
-  static int metaCounter = 0;
-
-//      std::string filename;
-//      if (explicitFilename)
-//        {
-//          filename = prefix;
-//        }
-//      else
-//        {
-//          filename = asciiTraceHelper.GetFilenameFromInterfacePair (prefix, ipv4, interface);
-//        }
-
-  // No reason to fail
-  Ptr<TcpSocketBase> sock = DynamicCast<TcpSocketBase>(socket);
-
-  //! choose a prefix depending on if it's subflow or meta
-  // TODO improve the doc to mark that isChildOf is strict
-  if(sock->GetInstanceTypeId().IsChildOf( MpTcpSubflow::GetTypeId()) 
-    || sock->GetInstanceTypeId() == MpTcpSubflow::GetTypeId())
-  {
-    //! TODO prefixer avec le nom de la meta 
-    os << Simulator::GetContext() << "-subflow" <<  subflowCounter++;
-    tcpHelper.SetupSocketTracing (sock, os.str());
-  }
-  else if(sock->GetInstanceTypeId().IsChildOf( MpTcpSocketBase::GetTypeId())
-      || sock->GetInstanceTypeId() == MpTcpSocketBase::GetTypeId()
-      )
-  {
-    os << Simulator::GetContext() << "-meta" <<  metaCounter++;
-    tcpHelper.SetupSocketTracing (sock, os.str());
-  }
-  else 
-  {
-    NS_LOG_INFO ("Not mptcp, do nothing: typeid=" << sock->GetInstanceTypeId().GetName ());
-  }
-}
-
-static const Ipv4Mask g_netmask = Ipv4Mask(0xffffff00);
-
-/**
- *
- */
- #if 0
-class MpTcpMultihomedTestCase : public TestCase
-{
-public:
-  MpTcpMultihomedTestCase (uint32_t totalStreamSize,
-               uint32_t sourceWriteSize,
-               uint32_t sourceReadSize,
-               uint32_t serverWriteSize,
-               uint32_t serverReadSize,
-               uint8_t nb_of_devices,
-               uint8_t nb_of_subflows_per_device,
-               bool useIpv6);
-
-  void HandleSubflowConnected (Ptr<MpTcpSubflow> subflow);
-  void HandleSubflowCreated (Ptr<MpTcpSubflow> subflow);
-
-private:
-  virtual void DoSetup (void);
-  virtual void DoRun (void);
-  virtual void DoTeardown (void);
-  void SetupDefaultSim (void);
-  void SetupDefaultSim6 (void);
-
-  Ptr<Node> CreateInternetNode (void);
-  Ptr<Node> CreateInternetNode6 (void);
-  Ptr<SimpleNetDevice> AddSimpleNetDevice (Ptr<Node> node, const char* ipaddr, const char* netmask);
-  Ptr<SimpleNetDevice> AddSimpleNetDevice6 (Ptr<Node> node, Ipv6Address ipaddr, Ipv6Prefix prefix);
-  void ServerHandleConnectionCreated (Ptr<Socket> s, const Address & addr);
-  void ServerHandleRecv (Ptr<Socket> sock);
-  void ServerHandleSend (Ptr<Socket> sock, uint32_t available);
-  void SourceHandleSend (Ptr<Socket> sock, uint32_t available);
-  void SourceHandleRecv (Ptr<Socket> sock);
-  void SourceConnectionSuccessful (Ptr<Socket> sock);
-  void SourceConnectionFailed (Ptr<Socket> sock);
-
-
-
-
-
-  uint32_t m_totalBytes;
-  uint32_t m_sourceWriteSize;
-  uint32_t m_sourceReadSize;
-  uint32_t m_serverWriteSize;
-  uint32_t m_serverReadSize;
-  uint32_t m_currentSourceTxBytes;
-  uint32_t m_currentSourceRxBytes;
-  uint32_t m_currentServerRxBytes;
-  uint32_t m_currentServerTxBytes;
-  uint8_t *m_sourceTxPayload;
-  uint8_t *m_sourceRxPayload;
-  uint8_t* m_serverRxPayload;
-
-  int m_nb_of_successful_connections;
-  int m_nb_of_successful_creations;
-//  int m_nb_of_subflow_connections;
-
-  bool m_connect_cb_called;
-  bool m_useIpv6;
-
-  uint8_t m_number_of_devices;
-  uint8_t m_number_of_subflow_per_device;
-
-  Ptr<Node> m_serverNode;
-  Ptr<Node> m_sourceNode;
-};
-#endif
-
-
-
-/**
-Normally this should be called twice, first when server replied with MPTCP option,
-2nd when DataAck was received, i.e., FullyEstablished
-**/
-void
-MpTcpMultihomedTestCase::SourceConnectionSuccessful (Ptr<Socket> sock)
-{
-
-  Ptr<MpTcpSocketBase> meta =  DynamicCast<MpTcpSocketBase>(sock);
-  NS_ASSERT_MSG(meta, "WTF ?!!");
-
-  NS_LOG_LOGIC("connection successful. Meta state=" << TcpSocket::TcpStateName[meta->GetState() ]
-//              << " received a DSS: " << meta->m_receivedDSS
-              );
-
-
-  if (!meta->FullyEstablished ())
-  {
-    //!
-    NS_LOG_INFO ("No DSS received yet => Not fully established. Can't create any subflow");
-    return;
-  }
-
-  m_nb_of_successful_connections++;
-  NS_LOG_INFO("At least one DSS received => fully established. Asking for a new subflow");
-
-//  NS_LOG_WARN("TODO check this is called after the receival of 1st DSS !!!");
-  m_connect_cb_called = true;
-
-//   NS_LOG_DEBUG("meta in state " << meta->m_state);
-
-//#if 0
-  /*
-  first address on 2nd interface
-  TODO this should depend on the number of interfaces
-  */
-  
-//    static const int MaxNbOfDevices = 3;
-//    static const int SubflowPerDevice = 1;
-//  TODO loop over devices
-    // GetNDevice
-//     GetDevice
-  Ptr<Ipv4> ipv4Local = m_sourceNode->GetObject<Ipv4> ();
-  NS_ABORT_MSG_UNLESS (ipv4Local, "GetObject for <Ipv4> interface failed");
-
-//      bool isForwarding = false;
-      for (uint32_t j = 0; j < ipv4Local->GetNInterfaces (); ++j )
-        {
-          if (
-//          ipv4Local->GetNetDevice (j) == ndLocal && 
-          ipv4Local->IsUp (j) &&
-              ipv4Local->IsForwarding (j)   // to remove localhost
-              ) 
-            {
-//              isForwarding = true;
-              // TODO call to CreateNewSubflow
-              int nb_of_subflows_to_create = m_number_of_subflow_per_device;
-              // If it's the same interface as master subflow, then remove one
-              if (ipv4Local->GetInterfaceForPrefix( "192.168.0.0", g_netmask))
-              {
-                nb_of_subflows_to_create--;
-              }
-              
-              // create subflows for this device
-              for (int i = 0; i < nb_of_subflows_to_create; ++i)
-              {
-                // Create new subflow
-                Ipv4Address serverAddr = m_serverNode->GetObject<Ipv4>()->GetAddress(2,0).GetLocal();
-                Ipv4Address sourceAddr = m_sourceNode->GetObject<Ipv4>()->GetAddress(2,0).GetLocal();
-
-                //! TODO, we should be able to not specify a port but it seems buggy so for now, let's set a port
-                InetSocketAddress local(sourceAddr, 4420);
-                InetSocketAddress remote(serverAddr, serverPort);
-
-                meta->ConnectNewSubflow (local, remote);
-              }
-            }
-        }
-        
-    #if 0
-    uint32_t numDevices = node->GetNDevices ();
-    ->
-    for (int nb_of_devices = 1; nb_of_devices < MaxNbOfDevices; ++nb_of_devices) {
-
-        // TODO account for master subflow
-        for (int subflow_per_device = 1; subflow_per_device < SubflowPerDevice; ++subflow_per_device) {
-
-        }
-    }
-    // GetAddress (interface, index ) index = 0 as each device has only one IP.
-    Ipv4Address serverAddr = m_serverNode->GetObject<Ipv4>()->GetAddress(2,0).GetLocal();
-    Ipv4Address sourceAddr = m_sourceNode->GetObject<Ipv4>()->GetAddress(2,0).GetLocal();
-
-    //! TODO, we should be able to not specify a port but it seems buggy so for now, let's set a port
-    InetSocketAddress local(sourceAddr, 4420);
-    InetSocketAddress remote(serverAddr, serverPort);
-
-    meta->ConnectNewSubflow (local, remote);
-    #endif
-
-//#endif
-
-}
-
-
-
-void
-MpTcpMultihomedTestCase::SourceConnectionFailed(Ptr<Socket> sock)
-{
-
-  NS_FATAL_ERROR("Connect failed");
-}
-
-void
-MpTcpMultihomedTestCase::ServerHandleConnectionCreated (Ptr<Socket> s, const Address & addr)
-{
-  NS_LOG_DEBUG("ServerHandleConnectionCreated");
-  s->SetRecvCallback (MakeCallback (&MpTcpMultihomedTestCase::ServerHandleRecv, this));
-  s->SetSendCallback (MakeCallback (&MpTcpMultihomedTestCase::ServerHandleSend, this));
-
-  // TODO setup tracing there !
-
-  Ptr<MpTcpSocketBase> server_meta = DynamicCast<MpTcpSocketBase>(s);
-  NS_ASSERT_MSG (server_meta, "Was expecting a meta socket !");
-  m_nb_of_successful_creations++;
-//  server_meta->SetupMetaTracing("server");
-}
-
-#if 0
-void
-MpTcpMultihomedTestCase::ServerHandleRecv (Ptr<Socket> sock)
-{
-  NS_LOG_DEBUG("ServerHandleRecv, Rx available [" << sock->GetRxAvailable () << "]");
-  while (sock->GetRxAvailable () > 0)
-    {
-
-      uint32_t toRead = std::min (m_serverReadSize, sock->GetRxAvailable ());
-      NS_LOG_DEBUG("Rx Available [" << toRead );
-      Ptr<Packet> p = sock->Recv (toRead, 0);
-      if (p == 0 && sock->GetErrno () != Socket::ERROR_NOTERROR)
-        {
-          NS_FATAL_ERROR ("Server could not read stream at byte " << m_currentServerRxBytes);
-        }
-      NS_TEST_EXPECT_MSG_EQ ((m_currentServerRxBytes + p->GetSize () <= m_totalBytes), true,
-                             "Server received too many bytes");
-      NS_LOG_DEBUG ("Server recv data=\"" << GetString (p) << "\"");
-      p->CopyData (&m_serverRxPayload[m_currentServerRxBytes], p->GetSize ());
-      m_currentServerRxBytes += p->GetSize ();
-      ServerHandleSend (sock, sock->GetTxAvailable ());
-    }
-}
-
-void
-MpTcpMultihomedTestCase::ServerHandleSend (Ptr<Socket> sock, uint32_t available)
-{
-  NS_LOG_DEBUG("ServerHandleSend: TxAvailable=" << available
-        << " m_currentServerTxBytes=" << m_currentServerTxBytes
-        << " m_currentServerRxBytes=" << m_currentServerRxBytes
-
-        );
-
-  // en fait la seconde condition est zarb : kesako ?
-  while (sock->GetTxAvailable () > 0 && m_currentServerTxBytes < m_currentServerRxBytes)
-    {
-      uint32_t left = m_currentServerRxBytes - m_currentServerTxBytes;
-      uint32_t toSend = std::min (left, sock->GetTxAvailable ());
-      NS_LOG_DEBUG ("toSend=min(nbBytesLeft=" << left << ",m_serverWriteSize=" << m_serverWriteSize << ")");
-      toSend = std::min (toSend, m_serverWriteSize);
-      Ptr<Packet> p = Create<Packet> (&m_serverRxPayload[m_currentServerTxBytes], toSend);
-      NS_LOG_DEBUG ("Server send data=\"" << GetString (p) << "\"");
-      int sent = sock->Send (p);
-      NS_TEST_EXPECT_MSG_EQ ((sent != -1), true, "Server error during send ?");
-      m_currentServerTxBytes += sent;
-    }
-  if (m_currentServerTxBytes == m_totalBytes)
-    {
-      NS_LOG_DEBUG ("Server received all the data. Closing socket.");
-      sock->Close ();
-    }
-}
-
-void
-MpTcpMultihomedTestCase::SourceHandleSend (Ptr<Socket> sock, uint32_t available)
-{
-  NS_LOG_DEBUG("SourceHandleSend with available = " << available
-                  << " m_currentSourceTxBytes=" << m_currentSourceTxBytes
-                  << " m_totalBytes=" << m_totalBytes
-                  );
-  while (sock->GetTxAvailable () > 0 && m_currentSourceTxBytes < m_totalBytes)
-    {
-      uint32_t left = m_totalBytes - m_currentSourceTxBytes;
-      uint32_t toSend = std::min (left, sock->GetTxAvailable ());
-      toSend = std::min (toSend, m_sourceWriteSize);
-      NS_LOG_DEBUG ("toSend=min(nbBytesLeft=" << left << ",sourceWriteSize=" << m_sourceWriteSize << ")");
-      Ptr<Packet> p = Create<Packet> (&m_sourceTxPayload[m_currentSourceTxBytes], toSend);
-      NS_LOG_DEBUG ("Source send data=\"" << GetString (p) << "\"");
-      int sent = sock->Send (p);
-      NS_TEST_EXPECT_MSG_EQ ((sent != -1), true, "Error during send ?");
-      m_currentSourceTxBytes += sent;
-    }
-}
-
-void
-MpTcpMultihomedTestCase::SourceHandleRecv (Ptr<Socket> sock)
-{
-  NS_LOG_DEBUG("SourceHandleRecv : m_currentSourceRxBytes=" << m_currentSourceRxBytes);
-  while (sock->GetRxAvailable () > 0 && m_currentSourceRxBytes < m_totalBytes)
-    {
-      uint32_t toRead = std::min (m_sourceReadSize, sock->GetRxAvailable ());
-      Ptr<Packet> p = sock->Recv (toRead, 0);
-      if (p == 0 && sock->GetErrno () != Socket::ERROR_NOTERROR)
-        {
-          NS_FATAL_ERROR ("Source could not read stream at byte " << m_currentSourceRxBytes);
-        }
-      NS_TEST_EXPECT_MSG_EQ ((m_currentSourceRxBytes + p->GetSize () <= m_totalBytes), true,
-                             "Source received too many bytes");
-
-      p->CopyData (&m_sourceRxPayload[m_currentSourceRxBytes], p->GetSize ());
-      m_currentSourceRxBytes += p->GetSize ();
-
-      NS_LOG_DEBUG ("Source recv data=\"" << GetString (p) << "\". m_currentSourceRxBytes=" << m_currentSourceRxBytes);
-    }
-  if (m_currentSourceRxBytes == m_totalBytes)
-    {
-      NS_LOG_DEBUG ("Client received all the data. Closing socket.");
-      sock->Close ();
-    }
-}
-#endif
-
-
-//Callback<bool, const Address &> m_joinRequest
-//Callback<void, Ptr<MpTcpSubflow> > m_joinConnectionSucceeded;
-
-
-/** Here subflow should already have a correct id */
-void
-MpTcpMultihomedTestCase::HandleSubflowCreated (Ptr<MpTcpSubflow> subflow)
-{
-  NS_LOG_LOGIC("Created new subflow [" << subflow << "]. Is master: " << subflow->IsMaster());
-
-  static int nb_of_successful_creations = 0;
-  if(subflow->IsMaster())
-  {
-    NS_LOG_LOGIC("successful establishement of first subflow " << subflow);
-  }
-  else
-  {
-    //! ce n'est pas le master donc forcement il s'agit d'un join
-    NS_LOG_LOGIC ("successful JOIN of subflow " << subflow );
-  }
-
-  NS_LOG_LOGIC ( "Subflow id=" << (int)subflow->GetLocalId() );
-  NS_LOG_LOGIC ( "Subflow =" << subflow );
-
-  // TODO check it's not called several times for the same sf ?
-  nb_of_successful_creations++;
-}
-
-
-/** Here subflow should already have a correct id */
-void
-MpTcpMultihomedTestCase::HandleSubflowConnected (Ptr<MpTcpSubflow> subflow)
-{
-  NS_LOG_LOGIC ("successful connection of a subflow");
-
-  static nb_of_successful_connections = 0;
-  if (subflow->IsMaster ())
-  {
-    NS_LOG_LOGIC ("successful establishement of first subflow " << subflow);
-  }
-  else
-  {
-    //! ce n'est pas le master donc forcement il s'agit d'un join
-    NS_LOG_LOGIC ("successful JOIN of subflow " << subflow );
-  }
-
-  nb_of_successful_connections++;
-  // TODO check it's not called several times for the same sf ?
-  
-}
-
-
-
-
-
-using namespace ns3;
-
-NS_LOG_COMPONENT_DEFINE ("TcpBulkSendExample");
-
-int
-main (int argc, char *argv[])
-{
-
-  bool tracing = false;
-  uint32_t maxBytes = 0;
-  int nbOfDevices = 1;
-
-//
-// Allow the user to override any of the defaults at
-// run-time, via command-line arguments
-//
-  CommandLine cmd;
-  cmd.AddValue ("tracing", "Flag to enable/disable tracing", tracing);
-  cmd.AddValue ("sfPerDevices",
-                "Total number of devices", nbOfDevices);
-
-  cmd.AddValue ("nbOfDevices",
-                "Total number of devices", nbOfDevices);
-  cmd.AddValue ("maxBytes",
-                "Total number of bytes for application to send", maxBytes);
-  cmd.Parse (argc, argv);
-
-//
-// Explicitly create the nodes required by the topology (shown above).
-//
-  NS_LOG_INFO ("Create nodes.");
-  NodeContainer nodes;
-  nodes.Create (2);
-
-  NS_LOG_INFO ("Create channels.");
-
-//
-// Explicitly create the point-to-point link required by the topology (shown above).
-//
-  PointToPointHelper pointToPoint;
-  pointToPoint.SetDeviceAttribute ("DataRate", StringValue ("500Kbps"));
-  pointToPoint.SetChannelAttribute ("Delay", StringValue ("5ms"));
-
-  NetDeviceContainer devices;
-  devices = pointToPoint.Install (nodes);
-
-//
-// Install the internet stack on the nodes
-//
-  InternetStackHelper internet;
-  internet.Install (nodes);
-
-//
-// We've got the "hardware" in place.  Now we need to add IP addresses.
-//
-  NS_LOG_INFO ("Assign IP Addresses.");
-  Ipv4AddressHelper ipv4;
-  ipv4.SetBase ("10.1.1.0", "255.255.255.0");
-  Ipv4InterfaceContainer i = ipv4.Assign (devices);
-
-  
-  
-  m_serverNode = CreateInternetNode ();
-  m_sourceNode = CreateInternetNode ();
-
-  // For netanim
-  setPos (m_serverNode, 0,0,0);
-  setPos (m_sourceNode, 100,0,0);
-
-  int nbOfDevices = m_number_of_devices;
-
-// TODO ptet essayer avec AddSimpleNetDevice
-  for(int i = 0; i < nbOfDevices; ++i)
-  {
-    // Use 10.0. instead !
-    // TODO use SimpleNetDevice instead if you want to upstream !
-    std::stringstream netAddr;
-    netAddr << "192.168." << i << ".0";
-
-    PointToPointHelper p2p;
-    p2p.SetDeviceAttribute ("DataRate", StringValue ("100Mbps"));
-    p2p.SetChannelAttribute ("Delay", StringValue ("10ms"));
-    p2p.SetChannelAttribute ("AlternateDelay", StringValue ("10ms"));
-    NetDeviceContainer cont = p2p.Install(m_serverNode,m_sourceNode);
-    p2p.EnablePcapAll("mptcp-multi", true);
-
-    Ipv4AddressHelper ipv4;
-    NS_LOG_DEBUG ("setting ipv4 base " << netAddr.str());
-    ipv4.SetBase ( netAddr.str().c_str(), g_netmask);
-    ipv4.Assign(cont);
-    /// Added by matt for debugging purposes
-
-    //PointToPointHelper helper;
-    //helper.EnablePcapAll("test",true);
-    //helper.EnablePcapAll("testmptcp",false);
-
-  }
-  //pcap.EnablePcapInternal("mptcp",dev,true,true);
-
-  // TODO addition
-  GlobalRouteManager::BuildGlobalRoutingDatabase ();
-  GlobalRouteManager::InitializeRoutes ();
-
-  Ptr<SocketFactory> sockFactory0 = m_serverNode->GetObject<TcpSocketFactory> ();
-  Ptr<SocketFactory> sockFactory1 = m_sourceNode->GetObject<TcpSocketFactory> ();
-
-  // a wrapper that calls m_tcp->CreateSocket ();
-  Ptr<Socket> server = sockFactory0->CreateSocket ();
-  Ptr<Socket> source = sockFactory1->CreateSocket ();
-
-  // TODO this should fail :/
-//  Ptr<MpTcpSocketBase> server_meta = DynamicCast<MpTcpSocketBase>(server);
-//  Ptr<MpTcpSocketBase> source_meta = DynamicCast<MpTcpSocketBase>(source);
-
-
-
-
-  /* We want to control over which socket the meta binds first
-   GetAddress(interface, noIp);
-   sachant que l'interface 0 est le loopback en fait
-  */
-  Ipv4Address serverMainAddr = m_serverNode->GetObject<Ipv4>()->GetAddress(1,0).GetLocal();
-  InetSocketAddress serverlocaladdr (serverMainAddr, serverPort);
-  InetSocketAddress serverremoteaddr (serverMainAddr, serverPort);
-  NS_LOG_DEBUG("serverMainAddr=" << serverlocaladdr);
-  server->Bind (serverlocaladdr);
-  server->Listen ();
-  server->SetAcceptCallback (MakeNullCallback<bool, Ptr< Socket >, const Address &> (),
-                             MakeCallback (&MpTcpMultihomedTestCase::ServerHandleConnectionCreated,this));
-
-//  NS_LOG_UNCOND("Server Meta:" << server_meta << " NodeId:" << server_meta->GetNode()->GetId());
-//  NS_LOG_UNCOND("Client Meta:" << source_meta << " NodeId:" << source_meta->GetNode()->GetId());
-//  NS_LOG_INFO( "test" << server);
-  source->SetRecvCallback (MakeCallback (&MpTcpMultihomedTestCase::SourceHandleRecv, this));
-  source->SetSendCallback (MakeCallback (&MpTcpMultihomedTestCase::SourceHandleSend, this));
-
-  // SetConnectCallback
-  source->SetConnectCallback (
-//    Callback< void, Ptr< Socket > > connectionSucceeded, Callback< void, Ptr< Socket > > connectionFailed
-    MakeCallback (&MpTcpMultihomedTestCase::SourceConnectionSuccessful, this),
-    MakeCallback (&MpTcpMultihomedTestCase::SourceConnectionFailed, this)
-
-    );
-  source->Connect (serverremoteaddr);
-
-
-  NS_LOG_INFO ("Create Applications.");
-
-//
-// Create a BulkSendApplication and install it on node 0
-//
-  uint16_t port = 9;  // well-known echo port number
-
-
-  BulkSendHelper source ("ns3::TcpSocketFactory",
-                         InetSocketAddress (i.GetAddress (1), port));
-  // Set the amount of data to send in bytes.  Zero is unlimited.
-  source.SetAttribute ("MaxBytes", UintegerValue (maxBytes));
-  ApplicationContainer sourceApps = source.Install (nodes.Get (0));
-  sourceApps.Start (Seconds (0.0));
-  sourceApps.Stop (Seconds (10.0));
-
-//
-// Create a PacketSinkApplication and install it on node 1
-//
-  PacketSinkHelper sink ("ns3::TcpSocketFactory",
-                         InetSocketAddress (Ipv4Address::GetAny (), port));
-  ApplicationContainer sinkApps = sink.Install (nodes.Get (1));
-  sinkApps.Start (Seconds (0.0));
-  sinkApps.Stop (Seconds (10.0));
-
-//
-// Set up tracing if enabled
-//
-  if (tracing)
-    {
-      AsciiTraceHelper ascii;
-      pointToPoint.EnableAsciiAll (ascii.CreateFileStream ("tcp-bulk-send.tr"));
-      pointToPoint.EnablePcapAll ("tcp-bulk-send", false);
-    }
-
-//
-// Now, do the actual simulation.
-//
-  NS_LOG_INFO ("Run Simulation.");
-
-  AnimationInterface anim ("animation.xml");
-  Simulator::Stop (Seconds (10.0));
-  Simulator::Run ();
-  Simulator::Destroy ();
-  NS_LOG_INFO ("Done.");
-
-  Ptr<PacketSink> sink1 = DynamicCast<PacketSink> (sinkApps.Get (0));
-  std::cout << "Total Bytes Received: " << sink1->GetTotalRx () << std::endl;
-}
diff --git a/examples/tcp/wscript b/examples/tcp/wscript
index 728be04..f535d8c 100644
--- a/examples/tcp/wscript
+++ b/examples/tcp/wscript
@@ -4,9 +4,6 @@ def build(bld):
     obj = bld.create_ns3_program('tcp-large-transfer',
                                  ['point-to-point', 'applications', 'internet'])
     obj.source = 'tcp-large-transfer.cc'
-    obj = bld.create_ns3_program('tcp-mptcp',
-                                 ['point-to-point', 'applications', 'internet'])
-    obj.source = 'mptcp.cc'
 
     obj = bld.create_ns3_program('tcp-nsc-lfn',
                                  ['point-to-point', 'applications', 'internet'])
diff --git a/src/core/model/build-profile.h b/src/core/model/build-profile.h
deleted file mode 100644
index 8874fb2..0000000
--- a/src/core/model/build-profile.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 LLNL
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Peter D. Barnes, Jr. <pdbarnes@llnl.gov>
- */
-
-#ifndef NS3_BUILD_PROFILE_H
-#define NS3_BUILD_PROFILE_H
-
-/**
- * \file
- * \ingroup debugging
- * Definition of build profile macros NS_BUILD_DEBUG, NS_BUILD_RELEASE,
- * and NS_BUILD_OPTIMIZED.
- */
-
-/**
- * \ingroup debugging
- * Build profile no-op macro.
- * \param [in] code The code to skip.
- */
-#define NS_BUILD_PROFILE_NOOP(code)             \
-  do                                            \
-      if (false)                                \
-        {                                       \
-          code ;                                \
-        }                                       \
-  while (false)
-
-/**
- * \ingroup debugging
- * Build profile macro to execute a code snippet.
- * \param [in] code The code to execute.
- */
-#define NS_BUILD_PROFILE_OP(code) \
-  do                                            \
-    {                                           \
-      code ;                                    \
-    }                                           \
-  while (false)
-
-
-#ifdef NS3_BUILD_PROFILE_DEBUG
-/**
- * \ingroup debugging
- * Execute a code snippet in debug builds.
- * \param [in] code The code to execute.
- */
-#define NS_BUILD_DEBUG(code)     NS_BUILD_PROFILE_OP (code)
-#else
-#define NS_BUILD_DEBUG(code)     NS_BUILD_PROFILE_NOOP (code)
-#endif
-
-#ifdef NS3_BUILD_PROFILE_RELEASE
-/**
- * \ingroup debugging
- * Execute a code snippet in release builds.
- * \param [in] code The code to execute.
- */
-#define NS_BUILD_RELEASE(code)   NS_BUILD_PROFILE_OP (code)
-#else
-#define NS_BUILD_RELEASE(code)   NS_BUILD_PROFILE_NOOP (code)
-#endif
-
-#ifdef NS3_BUILD_PROFILE_OPTIMIZED
-/**
- * \ingroup debugging
- * Execute a code snippet in optimized builds.
- * \param [in] code The code to execute.
- */
-#define NS_BUILD_OPTIMIZED(code) NS_BUILD_PROFILE_OP (code)
-#else
-#define NS_BUILD_OPTIMIZED(code) NS_BUILD_PROFILE_NOOP (code)
-#endif
-
-
-
-
-#endif /* NS3_BUILD_PROFILE_H */
diff --git a/src/core/model/callback.h b/src/core/model/callback.h
index 49fad69..041acd1 100644
--- a/src/core/model/callback.h
+++ b/src/core/model/callback.h
@@ -102,7 +102,7 @@ namespace ns3 {
  * or not we really want to use it.
  */
 
-
+  
 /**
  * \ingroup makecallbackmemptr
  *
@@ -156,7 +156,7 @@ public:
  */
 template <typename R, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename T8, typename T9>
 class CallbackImpl;
-
+  
 /**
  * \ingroup callbackimpl
  * CallbackImpl classes with varying numbers of argument types
@@ -246,7 +246,7 @@ public:
   /**
    * Construct from a functor
    *
-   * \param functor the functor
+   * \param functor the functor 
    */
   FunctorCallbackImpl (T const &functor)
     : m_functor (functor) {}
@@ -366,7 +366,7 @@ public:
    * \return true if this and other have the same functor
    */
   virtual bool IsEqual (Ptr<const CallbackImplBase> other) const {
-    FunctorCallbackImpl<T,R,T1,T2,T3,T4,T5,T6,T7,T8,T9> const *otherDerived =
+    FunctorCallbackImpl<T,R,T1,T2,T3,T4,T5,T6,T7,T8,T9> const *otherDerived = 
       dynamic_cast<FunctorCallbackImpl<T,R,T1,T2,T3,T4,T5,T6,T7,T8,T9> const *> (PeekPointer (other));
     if (otherDerived == 0)
       {
@@ -513,7 +513,7 @@ public:
    * \return true if we have the same object and member function
    */
   virtual bool IsEqual (Ptr<const CallbackImplBase> other) const {
-    MemPtrCallbackImpl<OBJ_PTR,MEM_PTR,R,T1,T2,T3,T4,T5,T6,T7,T8,T9> const *otherDerived =
+    MemPtrCallbackImpl<OBJ_PTR,MEM_PTR,R,T1,T2,T3,T4,T5,T6,T7,T8,T9> const *otherDerived = 
       dynamic_cast<MemPtrCallbackImpl<OBJ_PTR,MEM_PTR,R,T1,T2,T3,T4,T5,T6,T7,T8,T9> const *> (PeekPointer (other));
     if (otherDerived == 0)
       {
@@ -540,7 +540,7 @@ class BoundFunctorCallbackImpl : public CallbackImpl<R,T1,T2,T3,T4,T5,T6,T7,T8,e
 public:
   /**
    * Construct from functor and a bound argument
-   * \param functor the functor
+   * \param functor the functor 
    * \param a the argument to bind
    */
   template <typename FUNCTOR, typename ARG>
@@ -647,7 +647,7 @@ public:
    * \return true if we have the same functor and bound arguments
    */
   virtual bool IsEqual (Ptr<const CallbackImplBase> other) const {
-    BoundFunctorCallbackImpl<T,R,TX,T1,T2,T3,T4,T5,T6,T7,T8> const *otherDerived =
+    BoundFunctorCallbackImpl<T,R,TX,T1,T2,T3,T4,T5,T6,T7,T8> const *otherDerived = 
       dynamic_cast<BoundFunctorCallbackImpl<T,R,TX,T1,T2,T3,T4,T5,T6,T7,T8> const *> (PeekPointer (other));
     if (otherDerived == 0)
       {
@@ -768,7 +768,7 @@ public:
    * \return true if we have the same functor and bound arguments
    */
   virtual bool IsEqual (Ptr<const CallbackImplBase> other) const {
-    TwoBoundFunctorCallbackImpl<T,R,TX1,TX2,T1,T2,T3,T4,T5,T6,T7> const *otherDerived =
+    TwoBoundFunctorCallbackImpl<T,R,TX1,TX2,T1,T2,T3,T4,T5,T6,T7> const *otherDerived = 
       dynamic_cast<TwoBoundFunctorCallbackImpl<T,R,TX1,TX2,T1,T2,T3,T4,T5,T6,T7> const *> (PeekPointer (other));
     if (otherDerived == 0)
       {
@@ -878,7 +878,7 @@ public:
    * \return true if we have the same functor and bound arguments
    */
   virtual bool IsEqual (Ptr<const CallbackImplBase> other) const {
-    ThreeBoundFunctorCallbackImpl<T,R,TX1,TX2,TX3,T1,T2,T3,T4,T5,T6> const *otherDerived =
+    ThreeBoundFunctorCallbackImpl<T,R,TX1,TX2,TX3,T1,T2,T3,T4,T5,T6> const *otherDerived = 
       dynamic_cast<ThreeBoundFunctorCallbackImpl<T,R,TX1,TX2,TX3,T1,T2,T3,T4,T5,T6> const *> (PeekPointer (other));
     if (otherDerived == 0)
       {
@@ -892,8 +892,8 @@ public:
     return true;
   }
 private:
-  T m_functor;                                    //!< The functor
-  typename TypeTraits<TX1>::ReferencedType m_a1;  //!< first bound argument
+  T m_functor;                                    //!< The functor      
+  typename TypeTraits<TX1>::ReferencedType m_a1;  //!< first bound argument 
   typename TypeTraits<TX2>::ReferencedType m_a2;  //!< second bound argument
   typename TypeTraits<TX3>::ReferencedType m_a3;  //!< third bound argument
 };
@@ -941,22 +941,22 @@ protected:
  * user intervention which allows you to pass around Callback
  * instances by value.
  *
- * Sample code which shows how to use this class template
+ * Sample code which shows how to use this class template 
  * as well as the function templates \ref MakeCallback :
  * \include src/core/examples/main-callback.cc
  *
  * \internal
- * This code was originally written based on the techniques
+ * This code was originally written based on the techniques 
  * described in http://www.codeproject.com/cpp/TTLFunction.asp
  * It was subsequently rewritten to follow the architecture
- * outlined in "Modern C++ Design" by Andrei Alexandrescu in
+ * outlined in "Modern C++ Design" by Andrei Alexandrescu in 
  * chapter 5, "Generalized Functors".
  *
  * This code uses:
  *   - default template parameters to saves users from having to
  *     specify empty parameters when the number of parameters
  *     is smaller than the maximum supported number
- *   - the pimpl idiom: the Callback class is passed around by
+ *   - the pimpl idiom: the Callback class is passed around by 
  *     value and delegates the crux of the work to its pimpl
  *     pointer.
  *   - two pimpl implementations which derive from CallbackImpl
@@ -966,7 +966,7 @@ protected:
  *   - a reference list implementation to implement the Callback's
  *     value semantics.
  *
- * This code most notably departs from the alexandrescu
+ * This code most notably departs from the alexandrescu 
  * implementation in that it does not use type lists to specify
  * and pass around the types of the callback arguments.
  * Of course, it also does not use copy-destruction semantics
@@ -975,8 +975,8 @@ protected:
  *
  * \see attribute_Callback
  */
-template<typename R,
-         typename T1 = empty, typename T2 = empty,
+template<typename R, 
+         typename T1 = empty, typename T2 = empty, 
          typename T3 = empty, typename T4 = empty,
          typename T5 = empty, typename T6 = empty,
          typename T7 = empty, typename T8 = empty,
@@ -995,7 +995,7 @@ public:
    * always properly disambiguated by the c++ compiler.
    */
   template <typename FUNCTOR>
-  Callback (FUNCTOR const &functor, bool, bool)
+  Callback (FUNCTOR const &functor, bool, bool) 
     : CallbackBase (Create<FunctorCallbackImpl<FUNCTOR,R,T1,T2,T3,T4,T5,T6,T7,T8,T9> > (functor))
   {}
 
@@ -1252,12 +1252,10 @@ private:
   void DoAssign (Ptr<const CallbackImplBase> other) {
     if (!DoCheckType (other))
       {
-        const CallbackImplBase * otherRaw = PeekPointer (other);
         Ptr<CallbackImpl<R,T1,T2,T3,T4,T5,T6,T7,T8,T9> > expected;
-        CallbackImpl<R,T1,T2,T3,T4,T5,T6,T7,T8,T9> * expectedRaw = PeekPointer (expected);
         NS_FATAL_ERROR ("Incompatible types. (feed to \"c++filt -t\" if needed)" << std::endl <<
-                        "got=" << Demangle ( typeid (*otherRaw).name () ) << std::endl <<
-                        "expected=" << Demangle ( typeid (*expectedRaw).name () ));
+                        "got=" << Demangle ( typeid (*other).name () ) << std::endl <<
+                        "expected=" << Demangle ( typeid (*expected).name () ));
       }
     m_impl = const_cast<CallbackImplBase *> (PeekPointer (other));
   }
@@ -1290,10 +1288,10 @@ bool operator != (Callback<R,T1,T2,T3,T4,T5,T6,T7,T8,T9> a, Callback<R,T1,T2,T3,
  * \param memPtr class method member pointer
  * \param objPtr class instance
  * \return a wrapper Callback
- *
+ * 
  * Build Callbacks for class method members which take varying numbers of arguments
  * and potentially returning a value.
- */
+ */     
 template <typename T, typename OBJ, typename R>
 Callback<R> MakeCallback (R (T::*memPtr)(void), OBJ objPtr) {
   return Callback<R> (objPtr, memPtr);
@@ -1383,7 +1381,7 @@ Callback<R,T1,T2,T3,T4,T5,T6,T7,T8,T9> MakeCallback (R (T::*memPtr)(T1,T2,T3,T4,
 /**
  * \param fnPtr function pointer
  * \return a wrapper Callback
- *
+ * 
  * Build Callbacks for functions which take varying numbers of arguments
  * and potentially returning a value.
  */
@@ -1439,7 +1437,7 @@ Callback<R,T1,T2,T3,T4,T5,T6,T7,T8,T9> MakeCallback (R (*fnPtr)(T1,T2,T3,T4,T5,T
  * Build null Callbacks which take no arguments,
  * for varying number of template arguments,
  * and potentially returning a value.
- */
+ */     
 template <typename R>
 Callback<R> MakeNullCallback (void) {
   return Callback<R> ();
@@ -1490,21 +1488,21 @@ Callback<R,T1,T2,T3,T4,T5,T6,T7,T8,T9> MakeNullCallback (void) {
  * \param fnPtr function pointer
  * \param a1 first bound argument
  * \return a bound Callback
- */
+ */   
 template <typename R, typename TX, typename ARG>
 Callback<R> MakeBoundCallback (R (*fnPtr)(TX), ARG a1) {
   Ptr<CallbackImpl<R,empty,empty,empty,empty,empty,empty,empty,empty,empty> > impl =
     Create<BoundFunctorCallbackImpl<R (*)(TX),R,TX,empty,empty,empty,empty,empty,empty,empty,empty> >(fnPtr, a1);
   return Callback<R> (impl);
 }
-template <typename R, typename TX, typename ARG,
+template <typename R, typename TX, typename ARG, 
           typename T1>
 Callback<R,T1> MakeBoundCallback (R (*fnPtr)(TX,T1), ARG a1) {
   Ptr<CallbackImpl<R,T1,empty,empty,empty,empty,empty,empty,empty,empty> > impl =
     Create<BoundFunctorCallbackImpl<R (*)(TX,T1),R,TX,T1,empty,empty,empty,empty,empty,empty,empty> > (fnPtr, a1);
   return Callback<R,T1> (impl);
 }
-template <typename R, typename TX, typename ARG,
+template <typename R, typename TX, typename ARG, 
           typename T1, typename T2>
 Callback<R,T1,T2> MakeBoundCallback (R (*fnPtr)(TX,T1,T2), ARG a1) {
   Ptr<CallbackImpl<R,T1,T2,empty,empty,empty,empty,empty,empty,empty> > impl =
@@ -1561,7 +1559,7 @@ Callback<R,T1,T2,T3,T4,T5,T6,T7,T8> MakeBoundCallback (R (*fnPtr)(TX,T1,T2,T3,T4
  * Make Callbacks with two bound arguments.
  * \param fnPtr function pointer
  * \param a1 first bound argument
- * \param a2 second bound argument
+ * \param a2 second bound argument 
  * \return a bound Callback
  */
 template <typename R, typename TX1, typename TX2, typename ARG1, typename ARG2>
@@ -1626,8 +1624,8 @@ Callback<R,T1,T2,T3,T4,T5,T6,T7> MakeBoundCallback (R (*fnPtr)(TX1,TX2,T1,T2,T3,
  * @{
  * Make Callbacks with three bound arguments.
  * \param a1 first bound argument
- * \param a2 second bound argument
- * \param a3 third bound argument
+ * \param a2 second bound argument 
+ * \param a3 third bound argument 
  * \param fnPtr function pointer
  * \return a bound Callback
  */
diff --git a/src/core/model/config.cc b/src/core/model/config.cc
index 7e16beb..b521a7d 100644
--- a/src/core/model/config.cc
+++ b/src/core/model/config.cc
@@ -100,7 +100,7 @@ MatchContainer::Set (std::string name, const AttributeValue &value)
       object->SetAttribute (name, value);
     }
 }
-void
+void 
 MatchContainer::Connect (std::string name, const CallbackBase &cb)
 {
   NS_LOG_FUNCTION (this << name << &cb);
@@ -112,7 +112,7 @@ MatchContainer::Connect (std::string name, const CallbackBase &cb)
       object->TraceConnect (name, ctx, cb);
     }
 }
-void
+void 
 MatchContainer::ConnectWithoutContext (std::string name, const CallbackBase &cb)
 {
   NS_LOG_FUNCTION (this << name << &cb);
@@ -123,7 +123,7 @@ MatchContainer::ConnectWithoutContext (std::string name, const CallbackBase &cb)
       object->TraceConnectWithoutContext (name, cb);
     }
 }
-void
+void 
 MatchContainer::Disconnect (std::string name, const CallbackBase &cb)
 {
   NS_LOG_FUNCTION (this << name << &cb);
@@ -135,7 +135,7 @@ MatchContainer::Disconnect (std::string name, const CallbackBase &cb)
       object->TraceDisconnect (name, ctx, cb);
     }
 }
-void
+void 
 MatchContainer::DisconnectWithoutContext (std::string name, const CallbackBase &cb)
 {
   NS_LOG_FUNCTION (this << name << &cb);
@@ -204,7 +204,7 @@ ArrayMatcher::Matches (uint32_t i) const
       std::string upperBound = m_element.substr (dash + 1, rightBracket - (dash + 1));
       uint32_t min;
       uint32_t max;
-      if (StringToUint32 (lowerBound, &min) &&
+      if (StringToUint32 (lowerBound, &min) && 
           StringToUint32 (upperBound, &max) &&
           i >= min && i <= max)
         {
@@ -287,7 +287,7 @@ Resolver::Canonicalize (void)
     }
 }
 
-void
+void 
 Resolver::Resolve (Ptr<Object> root)
 {
   NS_LOG_FUNCTION (this << root);
@@ -308,7 +308,7 @@ Resolver::GetResolvedPath (void) const
   return fullPath;
 }
 
-void
+void 
 Resolver::DoResolveOne (Ptr<Object> object)
 {
   NS_LOG_FUNCTION (this << object);
@@ -327,13 +327,13 @@ Resolver::DoResolve (std::string path, Ptr<Object> root)
   if (next == std::string::npos)
     {
       //
-      // If root is zero, we're beginning to see if we can use the object name
-      // service to resolve this path.  It is impossible to have a object name
+      // If root is zero, we're beginning to see if we can use the object name 
+      // service to resolve this path.  It is impossible to have a object name 
       // associated with the root of the object name service since that root
       // is not an object.  This path must be referring to something in another
       // namespace and it will have been found already since the name service
       // is always consulted last.
-      //
+      // 
       if (root)
         {
           DoResolveOne (root);
@@ -344,10 +344,10 @@ Resolver::DoResolve (std::string path, Ptr<Object> root)
   std::string pathLeft = path.substr (next, path.size ()-next);
 
   //
-  // If root is zero, we're beginning to see if we can use the object name
-  // service to resolve this path.  In this case, we must see the name space
-  // "/Names" on the front of this path.  There is no object associated with
-  // the root of the "/Names" namespace, so we just ignore it and move on to
+  // If root is zero, we're beginning to see if we can use the object name 
+  // service to resolve this path.  In this case, we must see the name space 
+  // "/Names" on the front of this path.  There is no object associated with 
+  // the root of the "/Names" namespace, so we just ignore it and move on to 
   // the next segment.
   //
   if (root == 0)
@@ -406,17 +406,17 @@ Resolver::DoResolve (std::string path, Ptr<Object> root)
       DoResolve (pathLeft, object);
       m_workStack.pop_back ();
     }
-  else
+  else 
     {
       // this is a normal attribute.
       TypeId tid;
       TypeId nextTid = root->GetInstanceTypeId ();
       bool foundMatch = false;
-
+      
       do
         {
           tid = nextTid;
-
+          
           for (uint32_t i = 0; i < tid.GetAttributeN(); i++)
             {
               struct TypeId::AttributeInformation info;
@@ -446,7 +446,7 @@ Resolver::DoResolve (std::string path, Ptr<Object> root)
                   m_workStack.pop_back ();
                 }
               // attempt to cast to an object vector.
-              const ObjectPtrContainerChecker *vectorChecker =
+              const ObjectPtrContainerChecker *vectorChecker = 
                 dynamic_cast<const ObjectPtrContainerChecker *> (PeekPointer (info.checker));
               if (vectorChecker != 0)
                 {
@@ -464,7 +464,7 @@ Resolver::DoResolve (std::string path, Ptr<Object> root)
 
           nextTid = tid.GetParent ();
         } while (nextTid != tid);
-
+      
       if (!foundMatch)
         {
           NS_LOG_DEBUG ("Requested item="<<item<<" does not exist on path="<<GetResolvedPath ());
@@ -473,7 +473,7 @@ Resolver::DoResolve (std::string path, Ptr<Object> root)
     }
 }
 
-void
+void 
 Resolver::DoArrayResolve (std::string path, const ObjectPtrContainerValue &container)
 {
   NS_LOG_FUNCTION(this << path << &container);
@@ -503,7 +503,7 @@ Resolver::DoArrayResolve (std::string path, const ObjectPtrContainerValue &conta
 }
 
 
-class ConfigImpl
+class ConfigImpl 
 {
 public:
   void Set (std::string path, const AttributeValue &value);
@@ -525,7 +525,7 @@ private:
   Roots m_roots;
 };
 
-void
+void 
 ConfigImpl::ParsePath (std::string path, std::string *root, std::string *leaf) const
 {
   NS_LOG_FUNCTION (this << path << root << leaf);
@@ -537,7 +537,7 @@ ConfigImpl::ParsePath (std::string path, std::string *root, std::string *leaf) c
   NS_LOG_FUNCTION (path << *root << *leaf);
 }
 
-void
+void 
 ConfigImpl::Set (std::string path, const AttributeValue &value)
 {
   NS_LOG_FUNCTION (this << path << &value);
@@ -547,7 +547,7 @@ ConfigImpl::Set (std::string path, const AttributeValue &value)
   Config::MatchContainer container = LookupMatches (root);
   container.Set (leaf, value);
 }
-void
+void 
 ConfigImpl::ConnectWithoutContext (std::string path, const CallbackBase &cb)
 {
   NS_LOG_FUNCTION (this << path << &cb);
@@ -556,7 +556,7 @@ ConfigImpl::ConnectWithoutContext (std::string path, const CallbackBase &cb)
   Config::MatchContainer container = LookupMatches (root);
   container.ConnectWithoutContext (leaf, cb);
 }
-void
+void 
 ConfigImpl::DisconnectWithoutContext (std::string path, const CallbackBase &cb)
 {
   NS_LOG_FUNCTION (this << path << &cb);
@@ -565,7 +565,7 @@ ConfigImpl::DisconnectWithoutContext (std::string path, const CallbackBase &cb)
   Config::MatchContainer container = LookupMatches (root);
   container.DisconnectWithoutContext (leaf, cb);
 }
-void
+void 
 ConfigImpl::Connect (std::string path, const CallbackBase &cb)
 {
   NS_LOG_FUNCTION (this << path << &cb);
@@ -575,7 +575,7 @@ ConfigImpl::Connect (std::string path, const CallbackBase &cb)
   Config::MatchContainer container = LookupMatches (root);
   container.Connect (leaf, cb);
 }
-void
+void 
 ConfigImpl::Disconnect (std::string path, const CallbackBase &cb)
 {
   NS_LOG_FUNCTION (this << path << &cb);
@@ -586,11 +586,11 @@ ConfigImpl::Disconnect (std::string path, const CallbackBase &cb)
   container.Disconnect (leaf, cb);
 }
 
-Config::MatchContainer
+Config::MatchContainer 
 ConfigImpl::LookupMatches (std::string path)
 {
   NS_LOG_FUNCTION (this << path);
-  class LookupMatchesResolver : public Resolver
+  class LookupMatchesResolver : public Resolver 
   {
   public:
     LookupMatchesResolver (std::string path)
@@ -618,14 +618,14 @@ ConfigImpl::LookupMatches (std::string path)
   return Config::MatchContainer (resolver.m_objects, resolver.m_contexts, path);
 }
 
-void
+void 
 ConfigImpl::RegisterRootNamespaceObject (Ptr<Object> obj)
 {
   NS_LOG_FUNCTION (this << obj);
   m_roots.push_back (obj);
 }
 
-void
+void 
 ConfigImpl::UnregisterRootNamespaceObject (Ptr<Object> obj)
 {
   NS_LOG_FUNCTION (this << obj);
@@ -640,13 +640,13 @@ ConfigImpl::UnregisterRootNamespaceObject (Ptr<Object> obj)
     }
 }
 
-uint32_t
+uint32_t 
 ConfigImpl::GetRootNamespaceObjectN (void) const
 {
   NS_LOG_FUNCTION (this);
   return m_roots.size ();
 }
-Ptr<Object>
+Ptr<Object> 
 ConfigImpl::GetRootNamespaceObject (uint32_t i) const
 {
   NS_LOG_FUNCTION (this << i);
@@ -702,7 +702,6 @@ bool SetDefaultFailSafe (std::string fullName, const AttributeValue &value)
   bool ok = TypeId::LookupByNameFailSafe (tidName, &tid);
   if (!ok)
     {
-      NS_LOG_WARN("Could not find typeid");
       return false;
     }
   for (uint32_t j = 0; j < tid.GetAttributeN (); j++)
@@ -713,7 +712,6 @@ bool SetDefaultFailSafe (std::string fullName, const AttributeValue &value)
           Ptr<AttributeValue> v = tmp.checker->CreateValidValue (value);
           if (v == 0)
             {
-              NS_LOG_WARN("Value null");
               return false;
             }
           tid.SetAttributeInitialValue (j, v);
@@ -742,13 +740,13 @@ void DisconnectWithoutContext (std::string path, const CallbackBase &cb)
   NS_LOG_FUNCTION (path << &cb);
   Singleton<ConfigImpl>::Get ()->DisconnectWithoutContext (path, cb);
 }
-void
+void 
 Connect (std::string path, const CallbackBase &cb)
 {
   NS_LOG_FUNCTION (path << &cb);
   Singleton<ConfigImpl>::Get ()->Connect (path, cb);
 }
-void
+void 
 Disconnect (std::string path, const CallbackBase &cb)
 {
   NS_LOG_FUNCTION (path << &cb);
diff --git a/src/core/model/nstime.h b/src/core/model/nstime.h
index 5ea7577..9c85d18 100644
--- a/src/core/model/nstime.h
+++ b/src/core/model/nstime.h
@@ -41,7 +41,7 @@
 namespace ns3 {
 
 class TimeWithUnit;
-
+  
 /**
  * \ingroup core
  * \defgroup time Virtual Time
@@ -124,7 +124,7 @@ public:
    *  Assignment operator
    * \param [in] o Time to assign.
    * \return the Time.
-   */
+   */      
   inline Time & operator = (const Time & o)
   {
     m_data = o.m_data;
@@ -143,7 +143,7 @@ public:
    *  Copy constructor
    *
    * \param [in] o Time to copy
-   */
+   */      
   inline Time(const Time & o)
     : m_data (o.m_data)
   {
@@ -229,7 +229,7 @@ public:
   }
   /**@}*/
   /**@}*/
-
+  
   /**
    * \brief Construct Time object from common time expressions like "1ms"
    *
@@ -389,7 +389,7 @@ public:
    */
   static enum Unit GetResolution (void);
 
-
+  
   /**
    *  Create a Time in the current unit.
    *
@@ -443,7 +443,7 @@ public:
   }
   /**@}*/
 
-
+  
   /**
    *  Get the Time value expressed in a particular unit.
    *
@@ -485,14 +485,14 @@ public:
   }
   /**@}*/
 
-
+  
   /** Cast to int64x64_t */
   inline operator int64x64_t () const
   {
     return int64x64_t (m_data);
   }
 
-
+  
   /**
    * Attach a unit to a Time, to facilitate output in a specific unit.
    *
@@ -516,7 +516,7 @@ public:
    */
   typedef void (* TracedValueCallback)(const Time oldValue,
                                        const Time newValue);
-
+  
 private:
   /** How to convert between other units and the current unit. */
   struct Information
@@ -663,10 +663,8 @@ private:
   friend Time operator / (const Time & lhs, const int64_t & rhs);
   friend Time & operator += (Time & lhs, const Time & rhs);
   friend Time & operator -= (Time & lhs, const Time & rhs);
-
-  friend Time operator - (const Time & lhs);
   /**@}*/
-
+  
   /**
    *  Absolute value function for Time
    *  \param time the input value
@@ -730,10 +728,6 @@ inline Time operator + (const Time & lhs, const Time & rhs)
 {
   return Time (lhs.m_data + rhs.m_data);
 }
-inline Time operator - (const Time & lhs)
-{
-  return Time (-lhs.m_data);
-}
 inline Time operator - (const Time & lhs, const Time & rhs)
 {
   return Time (lhs.m_data - rhs.m_data);
@@ -776,7 +770,7 @@ inline Time & operator -= (Time & lhs, const Time & rhs)
   return lhs;
 }
 
-
+  
 inline Time Abs (const Time & time)
 {
   return Time ((time.m_data < 0) ? -time.m_data : time.m_data);
@@ -793,7 +787,7 @@ inline Time Min (const Time & ta, const Time & tb)
 /**
  * \ingroup time
  * \brief Time output streamer.
- *
+ * 
  * Generates output such as "3.96ns".  Times are printed with the
  * following format flags (independent of the stream flags):
  *   - `showpos`
@@ -918,7 +912,7 @@ inline Time FemtoSeconds (int64x64_t value)
   return Time::From (value, Time::FS);
 }
 /**@}*/
-
+  
 
 /**
  *  \ingroup time
diff --git a/src/core/model/object.h b/src/core/model/object.h
index 5914151..15f1cf3 100644
--- a/src/core/model/object.h
+++ b/src/core/model/object.h
@@ -49,7 +49,7 @@ class TraceSourceAccessor;
  * \defgroup object Object
  * \brief Base classes which provide memory management and object aggregation.
  */
-
+  
 /**
  * \ingroup object
  * \ingroup ptr
@@ -97,7 +97,7 @@ public:
    * \brief Iterate over the Objects aggregated to an ns3::Object.
    *
    * This iterator does not allow you to iterate over the parent
-   * Object used to call Object::GetAggregateIterator.
+   * Object used to call Object::GetAggregateIterator. 
    *
    * \note This is a java-style iterator.
    */
@@ -156,7 +156,7 @@ private:
   inline Ptr<T> GetObject (void) const;
   /**
    * Get a pointer to the requested aggregated Object.
-   *
+   * 
    * \param tid The TypeId of the requested Object.
    * \returns A pointer to the requested Object, or zero
    *          if it could not be found.
@@ -167,7 +167,7 @@ private:
    * Dispose of this Object.
    *
    * Run the DoDispose() methods of this Object and all the
-   * Objects aggregated to it.
+   * Objects aggregated to it.  
    * After calling this method, this Object is expected to be
    * totally unusable except for the Ref() and Unref() methods.
    *
@@ -185,7 +185,7 @@ private:
    *
    * This method aggregates the two Objects together: after this
    * method returns, it becomes possible to call GetObject()
-   * on one to get the other, and vice-versa.
+   * on one to get the other, and vice-versa. 
    *
    * This method calls the virtual method NotifyNewAggregates() to
    * notify all aggregated Objects that they have been aggregated
@@ -249,7 +249,7 @@ protected:
   /**
    * Destructor implementation.
    *
-   * This method is called by Dispose() or by the Object's
+   * This method is called by Dispose() or by the Object's 
    * destructor, whichever comes first.
    *
    * Subclasses are expected to implement their real destruction
@@ -283,7 +283,7 @@ protected:
    * valid state.
    */
   Object (const Object &o);
-
+  
 private:
 
   /**
@@ -301,7 +301,7 @@ private:
   template <typename T>
   friend Ptr<T> CopyObject (Ptr<const T> object);
   /**@}*/
-
+  
   /**
    * Set the TypeId and construct all Attributes of an Object.
    *
@@ -319,7 +319,7 @@ private:
   /**
    * The list of Objects aggregated to this one.
    *
-   * This data structure uses a classic C-style trick to
+   * This data structure uses a classic C-style trick to 
    * hold an array of variable size without performing
    * two memory allocations: the declaration of the structure
    * declares a one-element array but when we allocate
@@ -362,7 +362,7 @@ private:
   bool CheckLoose (void) const;
   /**
    * Set the TypeId of this Object.
-
+   
    * \param tid The TypeId value to set.
    *
    * Invoked from ns3::CreateObject only.
@@ -392,7 +392,7 @@ private:
   /**
    * Attempt to delete this Object.
    *
-   * This method iterates over all aggregated Objects to check if they all
+   * This method iterates over all aggregated Objects to check if they all 
    * have a zero refcount. If yes, the Object and all
    * its aggregates are deleted. If not, nothing is done.
    */
@@ -415,7 +415,7 @@ private:
   /**
    * A pointer to an array of 'aggregates'.
    *
-   * A pointer to each Object aggregated to this Object is stored in this
+   * A pointer to each Object aggregated to this Object is stored in this 
    * array.  The array is shared by all aggregated Objects
    * so the size of the array is indirectly a reference count.
    */
@@ -444,14 +444,14 @@ namespace ns3 {
  *   The Object implementation which depends on templates
  *************************************************************************/
 
-void
+void 
 ObjectDeleter::Delete (Object *object)
 {
   object->DoDelete ();
 }
 
 template <typename T>
-Ptr<T>
+Ptr<T> 
 Object::GetObject () const
 {
   // This is an optimization: if the cast works (which is likely),
@@ -471,7 +471,7 @@ Object::GetObject () const
 }
 
 template <typename T>
-Ptr<T>
+Ptr<T> 
 Object::GetObject (TypeId tid) const
 {
   Ptr<Object> found = DoGetObject (tid);
@@ -510,9 +510,7 @@ Ptr<T> CompleteConstruct (T *object)
   return Ptr<T> (object, false);
 }
 
-
-
-/**
+/** 
  * \ingroup object
  * @{
  */
diff --git a/src/core/model/ptr.h b/src/core/model/ptr.h
index c147739..00de5f6 100644
--- a/src/core/model/ptr.h
+++ b/src/core/model/ptr.h
@@ -70,7 +70,7 @@ namespace ns3 {
  * \tparam T The underlying type.
  */
 template <typename T>
-class Ptr
+class Ptr 
 {
 private:
 
@@ -83,10 +83,10 @@ private:
     /** Disable delete (by virtue that this is unimplemented). */
     void operator delete (void *);
   };
-
+  
   /** Interoperate with const instances. */
   friend class Ptr<const T>;
-
+  
   /**
    * Get a permanent pointer to the underlying object.
    *
@@ -112,11 +112,9 @@ private:
   template <typename U>
   friend U *PeekPointer (const Ptr<U> &p);
 
-// Make this public to test MPTCP
-public:
   /** Mark this as a a reference by incrementing the reference count. */
   inline void Acquire (void) const;
-
+  
 public:
   /** Create an empty smart pointer */
   Ptr ();
@@ -153,7 +151,7 @@ public:
    * \param [in] o The Ptr to copy.
    */
   template <typename U>
-  Ptr (Ptr<U> const &o);
+  Ptr (Ptr<U> const &o); 
   /** Destructor. */
   ~Ptr ();
   /**
@@ -437,7 +435,7 @@ bool operator > (const Ptr<T> &lhs, const Ptr<T> &rhs);
 template <typename T>
 bool operator >= (const Ptr<T> &lhs, const Ptr<T> &rhs);
 /** @} */
-
+  
 /**
  * Return a copy of \c p with its stored pointer const casted from
  * \c T2 to \c T1.
@@ -450,7 +448,7 @@ bool operator >= (const Ptr<T> &lhs, const Ptr<T> &rhs);
 template <typename T1, typename T2>
 Ptr<T1> const_pointer_cast (Ptr<T2> const&p);
 
-// Duplicate of struct CallbackTraits<T> as defined in callback.h
+// Duplicate of struct CallbackTraits<T> as defined in callback.h  
 template <typename T>
 struct CallbackTraits;
 
@@ -581,42 +579,42 @@ std::ostream &operator << (std::ostream &os, const Ptr<T> &p)
 }
 
 template <typename T1, typename T2>
-bool
+bool 
 operator == (Ptr<T1> const &lhs, T2 const *rhs)
 {
   return PeekPointer (lhs) == rhs;
 }
 
 template <typename T1, typename T2>
-bool
+bool 
 operator == (T1 const *lhs, Ptr<T2> &rhs)
 {
   return lhs == PeekPointer (rhs);
 }
 
 template <typename T1, typename T2>
-bool
+bool 
 operator != (Ptr<T1> const &lhs, T2 const *rhs)
 {
   return PeekPointer (lhs) != rhs;
 }
 
 template <typename T1, typename T2>
-bool
+bool 
 operator != (T1 const *lhs, Ptr<T2> &rhs)
 {
   return lhs != PeekPointer (rhs);
 }
 
 template <typename T1, typename T2>
-bool
+bool 
 operator == (Ptr<T1> const &lhs, Ptr<T2> const &rhs)
 {
   return PeekPointer (lhs) == PeekPointer (rhs);
 }
 
 template <typename T1, typename T2>
-bool
+bool 
 operator != (Ptr<T1> const &lhs, Ptr<T2> const &rhs)
 {
   return PeekPointer (lhs) != PeekPointer (rhs);
@@ -704,7 +702,7 @@ Ptr<T> Copy (Ptr<const T> object)
  ***************************************************/
 
 template <typename T>
-void
+void 
 Ptr<T>::Acquire (void) const
 {
   if (m_ptr != 0)
@@ -737,7 +735,7 @@ Ptr<T>::Ptr (T *ptr, bool ref)
 }
 
 template <typename T>
-Ptr<T>::Ptr (Ptr const&o)
+Ptr<T>::Ptr (Ptr const&o) 
   : m_ptr (PeekPointer (o))
 {
   Acquire ();
@@ -751,9 +749,9 @@ Ptr<T>::Ptr (Ptr<U> const &o)
 }
 
 template <typename T>
-Ptr<T>::~Ptr ()
+Ptr<T>::~Ptr () 
 {
-  if (m_ptr != 0)
+  if (m_ptr != 0) 
     {
       m_ptr->Unref ();
     }
@@ -761,13 +759,13 @@ Ptr<T>::~Ptr ()
 
 template <typename T>
 Ptr<T> &
-Ptr<T>::operator = (Ptr const& o)
+Ptr<T>::operator = (Ptr const& o) 
 {
   if (&o == this)
     {
       return *this;
     }
-  if (m_ptr != 0)
+  if (m_ptr != 0) 
     {
       m_ptr->Unref ();
     }
@@ -778,7 +776,7 @@ Ptr<T>::operator = (Ptr const& o)
 
 template <typename T>
 T *
-Ptr<T>::operator -> ()
+Ptr<T>::operator -> () 
 {
   return m_ptr;
 }
@@ -805,8 +803,8 @@ Ptr<T>::operator * ()
 }
 
 template <typename T>
-bool
-Ptr<T>::operator! ()
+bool 
+Ptr<T>::operator! () 
 {
   return m_ptr == 0;
 }
@@ -814,7 +812,7 @@ Ptr<T>::operator! ()
 template <typename T>
 Ptr<T>::operator Tester * () const
 {
-  if (m_ptr == 0)
+  if (m_ptr == 0) 
     {
       return 0;
     }
diff --git a/src/core/model/type-id.cc b/src/core/model/type-id.cc
index 8c10fac..25a277e 100644
--- a/src/core/model/type-id.cc
+++ b/src/core/model/type-id.cc
@@ -762,7 +762,7 @@ TypeId::HasParent (void) const
   return parent != m_tid;
 }
 bool 
-TypeId::IsChildOf (TypeId other, bool strict) const
+TypeId::IsChildOf (TypeId other) const
 {
   NS_LOG_FUNCTION (this << other);
   TypeId tmp = *this;
@@ -770,11 +770,7 @@ TypeId::IsChildOf (TypeId other, bool strict) const
     {
       tmp = tmp.GetParent ();
     }
-  bool res = tmp == other;
-  if (strict) {
-    res &= *this != other;
-  }
-  return res;
+  return tmp == other && *this != other;
 }
 std::string 
 TypeId::GetGroupName (void) const
diff --git a/src/core/model/type-id.h b/src/core/model/type-id.h
index 0f6272d..7f8d2a4 100644
--- a/src/core/model/type-id.h
+++ b/src/core/model/type-id.h
@@ -169,7 +169,7 @@ public:
    * except that you do not need object instances: you can do the check
    * with TypeId instances instead.
    */
-  bool IsChildOf (TypeId other, bool strict = true) const;
+  bool IsChildOf (TypeId other) const;
 
   /**
    * \returns the name of the group associated to this TypeId.
diff --git a/src/core/wscript b/src/core/wscript
index 43ad444..87b9169 100644
--- a/src/core/wscript
+++ b/src/core/wscript
@@ -222,7 +222,6 @@ def build(bld):
         'model/event-impl.h',
         'model/simulator.h',
         'model/simulator-impl.h',
-        'model/build-profile.h',
         'model/default-simulator-impl.h',
         'model/scheduler.h',
         'model/list-scheduler.h',
diff --git a/src/internet/helper/tcp-trace-helper.cc b/src/internet/helper/tcp-trace-helper.cc
deleted file mode 100644
index 487f9bf..0000000
--- a/src/internet/helper/tcp-trace-helper.cc
+++ /dev/null
@@ -1,270 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2010 University of Washington
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-
-#include <stdint.h>
-#include <string>
-#include <fstream>
-
-#include "ns3/abort.h"
-#include "ns3/assert.h"
-#include "ns3/log.h"
-#include "ns3/ptr.h"
-#include "ns3/node.h"
-#include "ns3/names.h"
-#include "ns3/net-device.h"
-#include "ns3/pcap-file-wrapper.h"
-#include "ns3/sequence-number.h"
-#include "ns3/tcp-socket-base.h"
-#include "ns3/mptcp-socket-base.h"
-#include "ns3/mptcp-subflow.h"
-//#include "ns3/mptcp-subflow.h"
-
-#include "tcp-trace-helper.h"
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE ("TcpTraceHelper");
-
-
-void
-dumpStr (Ptr<OutputStreamWrapper> stream, int pos, std::string item)
-{
-  NS_LOG_DEBUG ("Recording item " 
-  << item << " at time=" 
-  << (Simulator::Now())
-  );
-  
-  *stream->GetStream() << Simulator::Now() << ",";
-  
-  for (int i = 1;i < pos; ++i){
-    *stream->GetStream() << ",";
-  }
-  
-  *stream->GetStream() << item;
-
-  for (int i = pos + 1;i < 10; ++i){
-    *stream->GetStream() << ",";
-  }
-  
-  *stream->GetStream()  << std::endl;
-}
-
-void
-dumpSequence32(Ptr<OutputStreamWrapper> stream, int pos, std::string context, SequenceNumber32 oldSeq, SequenceNumber32 newSeq)
-{
-  //<< context <<
-//  if (context == "NextTxSequence")
-  std::ostringstream os;
-  os << newSeq;
-  dumpStr ( stream, pos, os.str());
-//  *stream->GetStream() << Simulator::Now()
-//                       << "," << oldSeq
-//                       << "," << newSeq
-//                       << std::endl;
-}
-
-
-void
-dumpUint32(Ptr<OutputStreamWrapper> stream, int pos, std::string context, uint32_t oldVal, uint32_t newVal) {
-
-//  NS_LOG_UNCOND("Context " << context << "oldVal=" << oldVal << "newVal=" << newVal);
-
-//  *stream->GetStream() << Simulator::Now()
-//                       << "," << oldVal
-//                       << "," << newVal
-//                       << std::endl;
-  std::ostringstream os;
-  os << newVal;
-  dumpStr ( stream, pos, os.str());
-}
-
-
-void
-dumpTcpState(Ptr<OutputStreamWrapper> stream, int pos, std::string context, TcpSocket::TcpStates_t oldVal, TcpSocket::TcpStates_t newVal) {
-  // TODO rely
-//  *stream->GetStream() << Simulator::Now()
-//                      << "," << TcpSocket::TcpStateName[oldVal]
-//                      << "," << TcpSocket::TcpStateName[newVal]
-//                      << std::endl;
-//  std::ostringstream os;
-//  os << newSeq;
-  dumpStr ( stream, pos, TcpSocket::TcpStateName[newVal]);
-}
-
-
-void
-TcpTraceHelper::OnNewSocket (Ptr<TcpSocket> socket)
-{
-  NS_LOG_DEBUG ("New socket incoming");
-  
-  TcpTraceHelper tcpHelper;
-  std::stringstream os;
-  //! we start at 1 because it's nicer
-  // m_tracePrefix << 
-  static int subflowCounter = 0;
-  static int metaCounter = 0;
-
-//      std::string filename;
-//      if (explicitFilename)
-//        {
-//          filename = prefix;
-//        }
-//      else
-//        {
-//          filename = asciiTraceHelper.GetFilenameFromInterfacePair (prefix, ipv4, interface);
-//        }
-
-  // No reason to fail
-  Ptr<TcpSocketBase> sock = DynamicCast<TcpSocketBase>(socket);
-
-  //! choose a prefix depending on if it's subflow or meta
-  // TODO improve the doc to mark that isChildOf ( ,false) is strict
-  if(sock->GetInstanceTypeId().IsChildOf( MpTcpSubflow::GetTypeId()) 
-    || sock->GetInstanceTypeId() == MpTcpSubflow::GetTypeId())
-  {
-    //! TODO prefixer avec le nom de la meta et utiliser le subflow addrId
-    os << Simulator::GetContext() << "-subflow" <<  subflowCounter++;
-    tcpHelper.SetupSocketTracing (sock, os.str());
-  }
-  else if(sock->GetInstanceTypeId().IsChildOf( MpTcpSocketBase::GetTypeId())
-      || sock->GetInstanceTypeId() == MpTcpSocketBase::GetTypeId()
-      )
-  {
-    os << Simulator::GetContext() << "-meta" <<  metaCounter++;
-    tcpHelper.SetupSocketTracing (sock, os.str());
-  }
-  else 
-  {
-    
-    NS_LOG_INFO ("Not mptcp, do nothing: typeid=" << sock->GetInstanceTypeId().GetName ());
-  }
-}
-
-/**
-TODO move that elsewhere, and plot the first line to get the initial value else it makes
-for bad plots.
-**/
-void
-TcpTraceHelper::SetupSocketTracing (Ptr<TcpSocketBase> sock, const std::string prefix)
-{
-  NS_LOG_INFO("sock " << sock << " and prefix [" << prefix << "]");
-  std::ios::openmode mode = std::ofstream::out | std::ofstream::trunc;
-
-
-  
-  // Or everything could be just written in the same file (uses fewer file descriptors)
-  AsciiTraceHelper asciiTraceHelper;
-  Ptr<OutputStreamWrapper> fd = asciiTraceHelper.CreateFileStream (prefix+ "_data.csv", mode);
-
-  Time now = Simulator::Now();
-  
-  
-  /* TODO use GetInitialCwnd, GetValue  etc...
-   Here we disabled some entries else the initial value wrongly set or just normal 
-   messed up the graph scale
-  */
-  *fd->GetStream() 
-    << "Time,txNext,highestSeq,unackSeq,rxNext,rxAvailable,rxTotal,cwnd,rWnd,ssThresh,state" << std::endl
-    << now << "," << sock->m_nextTxSequence
-          << "," << sock->m_highTxMark 
-          << "," << sock->FirstUnackedSeq() 
-          << "," 
-          /// << sock->m_rxBuffer->NextRxSequence()
-          << "," << sock->GetRxAvailable ()
-          << "," 
-        //      <<  sock->GetRcvBufSize()
-          << "," << sock->GetInitialCwnd ()
-          // TODO may crash for subflow as meta is not set yet for subflow
-          << "," 
-//          << sock->Window()
-          << "," << sock->GetInitialSSThresh()
-          << "," << TcpSocket::TcpStateName[sock->GetState()]
-          << std::endl
-   ;
-
-//  *streamTxHighest->GetStream() << "Time,oldHighestSequence,newHighestSequence" << std::endl
-//                              << now << ",0," << sock->m_highTxMark << std::endl
-//                                ;
-  // In fact it might be acked but as it neds to be moved on a per-mapping basis
-  //
-//  *streamTxUnack->GetStream() << "Time,oldUnackSequence,newUnackSequence" << std::endl
-//                                  << now << ",0," << sock->FirstUnackedSeq() << std::endl
-//                                  ;
-//  *streamRxNext->GetStream() << "Time,oldRxNext,newRxNext" << std::endl
-//                             << now << ",0," << sock->m_rxBuffer->NextRxSequence() << std::endl
-//                             ;
-//  *streamRxAvailable->GetStream() << "Time,oldRxAvailable,newRxAvailable" << std::endl
-//                                  << now << ",," << sock->GetRxAvailable () << std::endl
-//                                  ;
-//  *streamRxTotal->GetStream() << "Time,oldRxTotal,newRxTotal" << std::endl
-//                                  << now << ",," << sock->GetRcvBufSize() << std::endl
-//                                  ;
-  // TODO
-//  *streamCwnd->GetStream() << "Time,oldCwnd,newCwnd" << std::endl
-//                          << now << ",0," << sock->GetInitialCwnd() << std::endl;
-//  *streamRwnd->GetStream() << "Time,oldRwnd,newRwnd" << std::endl
-//                           << now << ",0," << sock->Window() << std::endl
-//                           ;
-
-  // We don't plot it, just looking at it so we don't care of the initial state
-//  *streamStates->GetStream() << "Time,oldState,newState" << std::endl
-//                           << now << ",," << TcpSocket::TcpStateName[sock->GetState()] << std::endl
-//            ;
-
-//  NS_ASSERT(f.is_open());
-  // TODO je devrais etre capable de voir les CongestionWindow + tailles de buffer/ Out of order
-//  CongestionWindow
-//  Ptr<MpTcpSocketBase> sock(this);
-//  NS_ASSERT(sock->TraceConnect ("RcvBufSize", "RcvBufSize", MakeBoundCallback(&dumpSequence32, streamTxNext)));
-//  NS_ASSERT(sock->TraceConnect ("SndBufSize", "SndBufSize", MakeBoundCallback(&dumpSequence32, streamTxNext)));
-
-  // TODO pass on the index (10 elements indexed from 0)
-  bool res = sock->TraceConnect ("NextTxSequence", "NextTxSequence", MakeBoundCallback(&dumpSequence32, fd, 1));
-  NS_ASSERT (res);
-  
-  res = sock->TraceConnect ("HighestSequence", "HighestSequence", MakeBoundCallback(&dumpSequence32, fd, 2));
-  NS_ASSERT(res);
-
-  res &= sock->TraceConnect ("UnackSequence", "UnackSequence", MakeBoundCallback(&dumpSequence32, fd,3));
-  // TODO bug here
-  res &= sock->m_rxBuffer->TraceConnect ("NextRxSequence", "NextRxSequence", MakeBoundCallback(&dumpSequence32, fd,4) );
-
-  res &= sock->m_rxBuffer->TraceConnect ("RxAvailable", "RxAvailable", MakeBoundCallback(&dumpUint32, fd, 5) );
-  res &= sock->m_rxBuffer->TraceConnect ("RxTotal", "RxTotal", MakeBoundCallback(&dumpUint32, fd, 6) );
-  
-  res &= sock->TraceConnect ("CongestionWindow", "CongestionWindow", MakeBoundCallback(&dumpUint32, fd,7));
-  res &= sock->TraceConnect ("RWND", "Remote WND", MakeBoundCallback(&dumpUint32, fd, 8));
-
-  // TODO show SlowStart Threshold
-  res &= sock->TraceConnect ("SlowStartThreshold", "SlowStartThreshold", MakeBoundCallback(&dumpUint32, fd, 9));
-  res &= sock->TraceConnect ("State", "State", MakeBoundCallback(&dumpTcpState, fd, 10) );
-  NS_ASSERT(res);
-//  Ptr<MpTcpSocketBase> sock2 = DynamicCast<MpTcpSocketBase>(sock);
-//  Ptr<TcpTxBuffer> txBuffer( &sock->m_txBuffer);
-  
-  
-  // HighestRxAck is not in sync with RxBuffer nextRxSequence, hence useless + it is not used in MPTCP stacks
-//  NS_ASSERT(sock->TraceConnect ("HighestRxAck", "HighestRxAck", MakeBoundCallback(&dumpSequence32, streamRxNext) ));
-//  HighestRxSequence
-}
-
-
-
-
-} // namespace ns3
-
diff --git a/src/internet/helper/tcp-trace-helper.h b/src/internet/helper/tcp-trace-helper.h
deleted file mode 100644
index acc526e..0000000
--- a/src/internet/helper/tcp-trace-helper.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-
-#ifndef TCP_TRACE_HELPER_H
-#define TCP_TRACE_HELPER_H
-
-#include "ns3/assert.h"
-//#include "ns3/ipv4-interface-container.h"
-//#include "ns3/ipv6-interface-container.h"
-//#include "ns3/ipv4.h"
-//#include "ns3/ipv6.h"
-#include "ns3/trace-helper.h"
-#include "ns3/ptr.h"
-
-namespace ns3 {
-
-class TcpSocketBase;
-class TcpSocket;
-
-// TODO look in TCP example for similar code
-// TODO move those to a TCP helper
-//void
-//SetupSocketTracing(Ptr<TcpSocketBase> sock, const std::string prefix);
-//
-//void
-//dumpSequence32(Ptr<OutputStreamWrapper> stream, std::string context, SequenceNumber32 oldSeq, SequenceNumber32 newSeq);
-//
-//void
-//dumpUint32(Ptr<OutputStreamWrapper> stream, std::string context, uint32_t oldVal, uint32_t newVal);
-//
-//void
-//dumpTcpState(Ptr<OutputStreamWrapper> stream, std::string context, TcpStates_t oldVal, TcpStates_t newVal);
-
-
-/**
- * @brief Base class providing common user-level pcap operations for helpers
- * representing IPv4 protocols .
- */
-class TcpTraceHelper
-{
-public:
-  /**
-   * @brief Construct a PcapHelperForIpv4.
-   */
-  TcpTraceHelper () {}
-
-  /**
-   * @brief Destroy a PcapHelperForIpv4.
-   */
-  virtual ~TcpTraceHelper () {}
-
-  /**
-   * For MPTCP tracing
-   */
-  static void OnNewSocket (Ptr<TcpSocket> socket);
-  /**
-   * prefix should be autogenerated
-   */
-  static void SetupSocketTracing (Ptr<TcpSocketBase> sock
-    , const std::string prefix
-    );
-};
-
-
-
-} // namespace ns3
-
-#endif /* INTERNET_TRACE_HELPER_H */
diff --git a/src/internet/model/global-route-manager-impl.cc b/src/internet/model/global-route-manager-impl.cc
index 4f79d5c..e9a44b7 100644
--- a/src/internet/model/global-route-manager-impl.cc
+++ b/src/internet/model/global-route-manager-impl.cc
@@ -1,8 +1,8 @@
 /* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
 /*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
+ * Copyright 2007 University of Washington
+ * Copyright (C) 1999, 2000 Kunihiro Ishiguro, Toshiaki Takada
+ * 
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation;
@@ -16,9 +16,12 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
+ * Authors:  Tom Henderson (tomhend@u.washington.edu)
+ * 
+ * Kunihiro Ishigura, Toshiaki Takada (GNU Zebra) are attributed authors
+ * of the quagga 0.99.7/src/ospfd/ospf_spf.c code which was ported here
  */
+
 #include <utility>
 #include <vector>
 #include <queue>
@@ -48,14 +51,14 @@ NS_LOG_COMPONENT_DEFINE ("GlobalRouteManagerImpl");
  * \param exit the exit node
  * \returns the reference to the output stream
  */
-std::ostream&
+std::ostream& 
 operator<< (std::ostream& os, const SPFVertex::NodeExit_t& exit)
 {
   os << "(" << exit.first << " ," << exit.second << ")";
   return os;
 }
 
-std::ostream&
+std::ostream& 
 operator<< (std::ostream& os, const SPFVertex::ListOfSPFVertex_t& vs)
 {
   typedef SPFVertex::ListOfSPFVertex_t::const_iterator CIter_t;
@@ -63,12 +66,12 @@ operator<< (std::ostream& os, const SPFVertex::ListOfSPFVertex_t& vs)
   for (CIter_t iter = vs.begin (); iter != vs.end ();)
     {
       os << (*iter)->m_vertexId;
-      if (++iter != vs.end ())
+      if (++iter != vs.end ()) 
         {
           os << ", ";
         }
-      else
-        {
+      else 
+        { 
           break;
         }
     }
@@ -82,11 +85,11 @@ operator<< (std::ostream& os, const SPFVertex::ListOfSPFVertex_t& vs)
 //
 // ---------------------------------------------------------------------------
 
-SPFVertex::SPFVertex () :
-  m_vertexType (VertexUnknown),
-  m_vertexId ("255.255.255.255"),
+SPFVertex::SPFVertex () : 
+  m_vertexType (VertexUnknown), 
+  m_vertexId ("255.255.255.255"), 
   m_lsa (0),
-  m_distanceFromRoot (SPF_INFINITY),
+  m_distanceFromRoot (SPF_INFINITY), 
   m_rootOif (SPF_INFINITY),
   m_nextHop ("0.0.0.0"),
   m_parents (),
@@ -96,10 +99,10 @@ SPFVertex::SPFVertex () :
   NS_LOG_FUNCTION (this);
 }
 
-SPFVertex::SPFVertex (GlobalRoutingLSA* lsa) :
+SPFVertex::SPFVertex (GlobalRoutingLSA* lsa) : 
   m_vertexId (lsa->GetLinkStateId ()),
   m_lsa (lsa),
-  m_distanceFromRoot (SPF_INFINITY),
+  m_distanceFromRoot (SPF_INFINITY), 
   m_rootOif (SPF_INFINITY),
   m_nextHop ("0.0.0.0"),
   m_parents (),
@@ -108,13 +111,13 @@ SPFVertex::SPFVertex (GlobalRoutingLSA* lsa) :
 {
   NS_LOG_FUNCTION (this << lsa);
 
-  if (lsa->GetLSType () == GlobalRoutingLSA::RouterLSA)
+  if (lsa->GetLSType () == GlobalRoutingLSA::RouterLSA) 
     {
       NS_LOG_LOGIC ("Setting m_vertexType to VertexRouter");
       m_vertexType = SPFVertex::VertexRouter;
     }
-  else if (lsa->GetLSType () == GlobalRoutingLSA::NetworkLSA)
-    {
+  else if (lsa->GetLSType () == GlobalRoutingLSA::NetworkLSA) 
+    { 
       NS_LOG_LOGIC ("Setting m_vertexType to VertexNetwork");
       m_vertexType = SPFVertex::VertexNetwork;
     }
@@ -129,7 +132,7 @@ SPFVertex::~SPFVertex ()
 
   // find this node from all its parents and remove the entry of this node
   // from all its parents
-  for (ListOfSPFVertex_t::iterator piter = m_parents.begin ();
+  for (ListOfSPFVertex_t::iterator piter = m_parents.begin (); 
        piter != m_parents.end ();
        piter++)
     {
@@ -148,7 +151,7 @@ SPFVertex::~SPFVertex ()
   // delete children
   while (m_children.size () > 0)
     {
-      // pop out children one by one. Some children may disapper
+      // pop out children one by one. Some children may disapper 
       // when deleting some other children in the list. As a result,
       // it is necessary to use pop to walk through all children, instead
       // of using iterator.
@@ -249,21 +252,21 @@ SPFVertex::GetParent (uint32_t i) const
       return 0;
     }
   ListOfSPFVertex_t::const_iterator iter = m_parents.begin ();
-  while (i-- > 0)
+  while (i-- > 0) 
     {
       iter++;
     }
   return *iter;
 }
 
-void
+void 
 SPFVertex::MergeParent (const SPFVertex* v)
 {
   NS_LOG_FUNCTION (this << v);
 
   NS_LOG_LOGIC ("Before merge, list of parents = " << m_parents);
   // combine the two lists first, and then remove any duplicated after
-  m_parents.insert (m_parents.end (),
+  m_parents.insert (m_parents.end (), 
                     v->m_parents.begin (), v->m_parents.end ());
   // remove duplication
   m_parents.sort ();
@@ -271,7 +274,7 @@ SPFVertex::MergeParent (const SPFVertex* v)
   NS_LOG_LOGIC ("After merge, list of parents = " << m_parents);
 }
 
-void
+void 
 SPFVertex::SetRootExitDirection (Ipv4Address nextHop, int32_t id)
 {
   NS_LOG_FUNCTION (this << nextHop << id);
@@ -285,7 +288,7 @@ SPFVertex::SetRootExitDirection (Ipv4Address nextHop, int32_t id)
   m_rootOif = id;
 }
 
-void
+void 
 SPFVertex::SetRootExitDirection (SPFVertex::NodeExit_t exit)
 {
   NS_LOG_FUNCTION (this << exit);
@@ -305,7 +308,7 @@ SPFVertex::GetRootExitDirection (uint32_t i) const
   return *iter;
 }
 
-SPFVertex::NodeExit_t
+SPFVertex::NodeExit_t 
 SPFVertex::GetRootExitDirection () const
 {
   NS_LOG_FUNCTION (this);
@@ -314,7 +317,7 @@ SPFVertex::GetRootExitDirection () const
   return GetRootExitDirection (0);
 }
 
-void
+void 
 SPFVertex::MergeRootExitDirections (const SPFVertex* vertex)
 {
   NS_LOG_FUNCTION (this << vertex);
@@ -323,13 +326,13 @@ SPFVertex::MergeRootExitDirections (const SPFVertex* vertex)
   //
   // Append the external list into 'this' and remove duplication afterward
   const ListOfNodeExit_t& extList = vertex->m_ecmpRootExits;
-  m_ecmpRootExits.insert (m_ecmpRootExits.end (),
+  m_ecmpRootExits.insert (m_ecmpRootExits.end (), 
                           extList.begin (), extList.end ());
   m_ecmpRootExits.sort ();
   m_ecmpRootExits.unique ();
 }
 
-void
+void 
 SPFVertex::InheritAllRootExitDirections (const SPFVertex* vertex)
 {
   NS_LOG_FUNCTION (this << vertex);
@@ -341,18 +344,18 @@ SPFVertex::InheritAllRootExitDirections (const SPFVertex* vertex)
       NS_LOG_WARN ("x root exit directions in this vertex are going to be discarded");
     }
   m_ecmpRootExits.clear ();
-  m_ecmpRootExits.insert (m_ecmpRootExits.end (),
+  m_ecmpRootExits.insert (m_ecmpRootExits.end (), 
                           vertex->m_ecmpRootExits.begin (), vertex->m_ecmpRootExits.end ());
 }
 
-uint32_t
+uint32_t 
 SPFVertex::GetNRootExitDirections () const
 {
   NS_LOG_FUNCTION (this);
   return m_ecmpRootExits.size ();
 }
 
-uint32_t
+uint32_t 
 SPFVertex::GetNChildren (void) const
 {
   NS_LOG_FUNCTION (this);
@@ -386,14 +389,14 @@ SPFVertex::AddChild (SPFVertex* child)
   return m_children.size ();
 }
 
-void
+void 
 SPFVertex::SetVertexProcessed (bool value)
 {
   NS_LOG_FUNCTION (this << value);
   m_vertexProcessed = value;
 }
 
-bool
+bool 
 SPFVertex::IsVertexProcessed (void) const
 {
   NS_LOG_FUNCTION (this);
@@ -461,10 +464,10 @@ void
 GlobalRouteManagerLSDB::Insert (Ipv4Address addr, GlobalRoutingLSA* lsa)
 {
   NS_LOG_FUNCTION (this << addr << lsa);
-  if (lsa->GetLSType () == GlobalRoutingLSA::ASExternalLSAs)
+  if (lsa->GetLSType () == GlobalRoutingLSA::ASExternalLSAs) 
     {
       m_extdatabase.push_back (lsa);
-    }
+    } 
   else
     {
       m_database.insert (LSDBPair_t (addr, lsa));
@@ -534,7 +537,7 @@ GlobalRouteManagerLSDB::GetLSAByLinkData (Ipv4Address addr) const
 //
 // ---------------------------------------------------------------------------
 
-GlobalRouteManagerImpl::GlobalRouteManagerImpl ()
+GlobalRouteManagerImpl::GlobalRouteManagerImpl () 
   :
     m_spfroot (0)
 {
@@ -603,11 +606,11 @@ GlobalRouteManagerImpl::DeleteGlobalRoutes ()
 // These routers will export a number of Link State Advertisements (LSAs)
 // that describe the links and networks that are "adjacent" (i.e., that are
 // on the other side of a point-to-point link).  We take these LSAs and put
-// add them to the Link State DataBase (LSDB) from which the routes will
+// add them to the Link State DataBase (LSDB) from which the routes will 
 // ultimately be computed.
 //
 void
-GlobalRouteManagerImpl::BuildGlobalRoutingDatabase ()
+GlobalRouteManagerImpl::BuildGlobalRoutingDatabase () 
 {
   NS_LOG_FUNCTION (this);
 //
@@ -631,8 +634,8 @@ GlobalRouteManagerImpl::BuildGlobalRoutingDatabase ()
 // You must call DiscoverLSAs () before trying to use any routing info or to
 // update LSAs.  DiscoverLSAs () drives the process of discovering routes in
 // the GlobalRouter.  Afterward, you may use GetNumLSAs (), which is a very
-// computationally inexpensive call.  If you call GetNumLSAs () before calling
-// DiscoverLSAs () will get zero as the number since no routes have been
+// computationally inexpensive call.  If you call GetNumLSAs () before calling 
+// DiscoverLSAs () will get zero as the number since no routes have been 
 // found.
 //
       Ptr<Ipv4GlobalRouting> grouting = rtr->GetRoutingProtocol ();
@@ -643,7 +646,7 @@ GlobalRouteManagerImpl::BuildGlobalRoutingDatabase ()
         {
           GlobalRoutingLSA* lsa = new GlobalRoutingLSA ();
 //
-// This is the call to actually fetch a Link State Advertisement from the
+// This is the call to actually fetch a Link State Advertisement from the 
 // router.
 //
           rtr->GetLSA (j, *lsa);
@@ -651,7 +654,7 @@ GlobalRouteManagerImpl::BuildGlobalRoutingDatabase ()
 //
 // Write the newly discovered link state advertisement to the database.
 //
-          m_lsdb->Insert (lsa->GetLinkStateId (), lsa);
+          m_lsdb->Insert (lsa->GetLinkStateId (), lsa); 
         }
     }
 }
@@ -687,7 +690,7 @@ GlobalRouteManagerImpl::BuildGlobalRoutingDatabase ()
 // candidate list, and its adjacent vertices are examined for
 // possible addition to/modification of the candidate list.  The
 // algorithm then iterates again.  It terminates when the candidate
-// list becomes empty.
+// list becomes empty. 
 //
 void
 GlobalRouteManagerImpl::InitializeRoutes ()
@@ -705,12 +708,12 @@ GlobalRouteManagerImpl::InitializeRoutes ()
 // Look for the GlobalRouter interface that indicates that the node is
 // participating in routing.
 //
-      Ptr<GlobalRouter> rtr =
+      Ptr<GlobalRouter> rtr = 
         node->GetObject<GlobalRouter> ();
 
       uint32_t systemId = MpiInterface::GetSystemId ();
       // Ignore nodes that are not assigned to our systemId (distributed sim)
-      if (node->GetSystemId () != systemId)
+      if (node->GetSystemId () != systemId) 
         {
           continue;
         }
@@ -728,7 +731,7 @@ GlobalRouteManagerImpl::InitializeRoutes ()
 }
 
 //
-// This method is derived from quagga ospf_spf_next ().  See RFC2328 Section
+// This method is derived from quagga ospf_spf_next ().  See RFC2328 Section 
 // 16.1 (2) for further details.
 //
 // We're passed a parameter <v> that is a vertex which is already in the SPF
@@ -756,19 +759,19 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
 //
   if (v->GetVertexType () == SPFVertex::VertexRouter)
     {
-      numRecordsInVertex = v->GetLSA ()->GetNLinkRecords ();
+      numRecordsInVertex = v->GetLSA ()->GetNLinkRecords (); 
     }
   if (v->GetVertexType () == SPFVertex::VertexNetwork)
     {
-      numRecordsInVertex = v->GetLSA ()->GetNAttachedRouters ();
+      numRecordsInVertex = v->GetLSA ()->GetNAttachedRouters (); 
     }
 
   for (uint32_t i = 0; i < numRecordsInVertex; i++)
     {
 // Get w_lsa:  In case of V is Router-LSA
-      if (v->GetVertexType () == SPFVertex::VertexRouter)
+      if (v->GetVertexType () == SPFVertex::VertexRouter) 
         {
-          NS_LOG_LOGIC ("Examining link " << i << " of " <<
+          NS_LOG_LOGIC ("Examining link " << i << " of " << 
                         v->GetVertexId () << "'s " <<
                         v->GetLSA ()->GetNLinkRecords () << " link records");
 //
@@ -786,7 +789,7 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
 //
 // (b) Otherwise, W is a transit vertex (router or transit network).  Look up
 // the vertex W's LSA (router-LSA or network-LSA) in Area A's link state
-// database.
+// database. 
 //
           if (l->GetLinkType () == GlobalRoutingLinkRecord::PointToPoint)
             {
@@ -796,32 +799,32 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
 //
               w_lsa = m_lsdb->GetLSA (l->GetLinkId ());
               NS_ASSERT (w_lsa);
-              NS_LOG_LOGIC ("Found a P2P record from " <<
+              NS_LOG_LOGIC ("Found a P2P record from " << 
                             v->GetVertexId () << " to " << w_lsa->GetLinkStateId ());
             }
-          else if (l->GetLinkType () ==
+          else if (l->GetLinkType () == 
                    GlobalRoutingLinkRecord::TransitNetwork)
             {
               w_lsa = m_lsdb->GetLSA (l->GetLinkId ());
               NS_ASSERT (w_lsa);
-              NS_LOG_LOGIC ("Found a Transit record from " <<
+              NS_LOG_LOGIC ("Found a Transit record from " << 
                             v->GetVertexId () << " to " << w_lsa->GetLinkStateId ());
             }
-          else
+          else 
             {
               NS_ASSERT_MSG (0, "illegal Link Type");
             }
         }
 // Get w_lsa:  In case of V is Network-LSA
-      if (v->GetVertexType () == SPFVertex::VertexNetwork)
+      if (v->GetVertexType () == SPFVertex::VertexNetwork) 
         {
-          w_lsa = m_lsdb->GetLSAByLinkData
+          w_lsa = m_lsdb->GetLSAByLinkData 
               (v->GetLSA ()->GetAttachedRouter (i));
           if (!w_lsa)
             {
               continue;
             }
-          NS_LOG_LOGIC ("Found a Network LSA from " <<
+          NS_LOG_LOGIC ("Found a Network LSA from " << 
                         v->GetVertexId () << " to " << w_lsa->GetLinkStateId ());
         }
 
@@ -833,15 +836,15 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
 // If the link is to a router that is already in the shortest path first tree
 // then we have it covered -- ignore it.
 //
-      if (w_lsa->GetStatus () == GlobalRoutingLSA::LSA_SPF_IN_SPFTREE)
+      if (w_lsa->GetStatus () == GlobalRoutingLSA::LSA_SPF_IN_SPFTREE) 
         {
-          NS_LOG_LOGIC ("Skipping ->  LSA "<<
+          NS_LOG_LOGIC ("Skipping ->  LSA "<< 
                         w_lsa->GetLinkStateId () << " already in SPF tree");
           continue;
         }
 //
-// (d) Calculate the link state cost D of the resulting path from the root to
-// vertex W.  D is equal to the sum of the link state cost of the (already
+// (d) Calculate the link state cost D of the resulting path from the root to 
+// vertex W.  D is equal to the sum of the link state cost of the (already 
 // calculated) shortest path to vertex V and the advertised cost of the link
 // between vertices V and W.
 //
@@ -876,13 +879,13 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
 // root node).
 //
               candidate.Push (w);
-              NS_LOG_LOGIC ("Pushing " <<
+              NS_LOG_LOGIC ("Pushing " << 
                             w->GetVertexId () << ", parent vertexId: " <<
                             v->GetVertexId () << ", distance: " <<
                             w->GetDistanceFromRoot ());
             }
           else
-            NS_ASSERT_MSG (0, "SPFNexthopCalculation never "
+            NS_ASSERT_MSG (0, "SPFNexthopCalculation never " 
                            << "return false, but it does now!");
         }
       else if (w_lsa->GetStatus () == GlobalRoutingLSA::LSA_SPF_CANDIDATE)
@@ -892,7 +895,7 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
 // do now is to decide if this new router represents a route with a shorter
 // distance metric.
 //
-// So, locate the vertex in the candidate queue and take a look at the
+// So, locate the vertex in the candidate queue and take a look at the 
 // distance.
 
 /* (quagga-0.98.6) W is already on the candidate list; call it cw.
@@ -919,12 +922,12 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
 // At this point, there are two instances 'w' and 'cw' of the
 // same vertex, the vertex that is currently being considered
 // for adding into the shortest path tree. 'w' is the instance
-// as seen from the root via vertex 'v', and 'cw' is the instance
+// as seen from the root via vertex 'v', and 'cw' is the instance 
 // as seen from the root via some other vertices other than 'v'.
 // These two instances are being merged in the following code.
 // In particular, the parent nodes, the next hops, and the root's
 // output interfaces of the two instances are being merged.
-//
+// 
 // Note that this is functionally equivalent to calling
 // ospf_nexthop_merge (cw->nexthop, w->nexthop) in quagga-0.98.6
 // (ospf_spf.c::859), although the detail implementation
@@ -935,7 +938,7 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
               SPFNexthopCalculation (v, w, l, distance);
               cw->MergeRootExitDirections (w);
               cw->MergeParent (w);
-// SPFVertexAddParent (w) is necessary as the destructor of
+// SPFVertexAddParent (w) is necessary as the destructor of 
 // SPFVertex checks if the vertex and its parent is linked
 // bidirectionally
               SPFVertexAddParent (w);
@@ -943,7 +946,7 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
             }
           else // cw->GetDistanceFromRoot () > w->GetDistanceFromRoot ()
             {
-//
+// 
 // this path represents a new, lower-cost path to <w> (the vertex we found in
 // the current link record of the link state advertisement of the current root
 // (vertex <v>)
@@ -954,7 +957,7 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
               if (SPFNexthopCalculation (v, cw, l, distance))
                 {
 //
-// If we've changed the cost to get to the vertex represented by <w>, we
+// If we've changed the cost to get to the vertex represented by <w>, we 
 // must reorder the priority queue keyed to that cost.
 //
                   candidate.Reorder ();
@@ -976,7 +979,7 @@ GlobalRouteManagerImpl::SPFNext (SPFVertex* v, CandidateQueue& candidate)
 //
 int
 GlobalRouteManagerImpl::SPFNexthopCalculation (
-  SPFVertex* v,
+  SPFVertex* v, 
   SPFVertex* w,
   GlobalRoutingLinkRecord* l,
   uint32_t distance)
@@ -1004,7 +1007,7 @@ GlobalRouteManagerImpl::SPFNexthopCalculation (
 // case we need to use the forwarding information from the vertex on the path
 // to the destination that is directly adjacent [node 1] in both cases of the
 // diagram below.
-//
+// 
 // (1) [root] -> [point-to-point] -> [node 1]
 // (2) [root] -> [point-to-point] -> [node 1] -> [point-to-point] -> [node 2]
 //
@@ -1012,7 +1015,7 @@ GlobalRouteManagerImpl::SPFNexthopCalculation (
 // "inheriting" the next hop information.
 //
 // The point-to-point link information is only useful in this calculation when
-// we are examining the root node.
+// we are examining the root node. 
 //
   if (v == m_spfroot)
     {
@@ -1024,7 +1027,7 @@ GlobalRouteManagerImpl::SPFNexthopCalculation (
 // node if this root node is a router.  We then need to see if this node <w>
 // is a router.
 //
-      if (w->GetVertexType () == SPFVertex::VertexRouter)
+      if (w->GetVertexType () == SPFVertex::VertexRouter) 
         {
 //
 // In the case of point-to-point links, the link data field (m_linkData) of a
@@ -1032,7 +1035,7 @@ GlobalRouteManagerImpl::SPFNexthopCalculation (
 // link record describing the link from the perspecive of <w> (the remote
 // node from the viewpoint of <v>) back to the root node, we can discover the
 // IP address of the router to which <v> is adjacent.  This is a distinguished
-// address -- the next hop address to get from <v> to <w> and all networks
+// address -- the next hop address to get from <v> to <w> and all networks 
 // accessed through that path.
 //
 // SPFGetNextLink () is a little odd.  used in this way it is just going to
@@ -1042,19 +1045,19 @@ GlobalRouteManagerImpl::SPFNexthopCalculation (
           NS_ASSERT (l);
           GlobalRoutingLinkRecord *linkRemote = 0;
           linkRemote = SPFGetNextLink (w, v, linkRemote);
-//
+// 
 // At this point, <l> is the Global Router Link Record describing the point-
 // to point link from <v> to <w> from the perspective of <v>; and <linkRemote>
-// is the Global Router Link Record describing that same link from the
-// perspective of <w> (back to <v>).  Now we can just copy the next hop
+// is the Global Router Link Record describing that same link from the 
+// perspective of <w> (back to <v>).  Now we can just copy the next hop 
 // address from the m_linkData member variable.
-//
+// 
 // The next hop member variable we put in <w> has the sense "in order to get
 // from the root node to the host represented by vertex <w>, you have to send
 // the packet to the next hop address specified in w->m_nextHop.
 //
           Ipv4Address nextHop = linkRemote->GetLinkData ();
-//
+// 
 // Now find the outgoing interface corresponding to the point to point link
 // from the perspective of <v> -- remember that <l> is the link "from"
 // <v> "to" <w>.
@@ -1064,34 +1067,34 @@ GlobalRouteManagerImpl::SPFNexthopCalculation (
           w->SetRootExitDirection (nextHop, outIf);
           w->SetDistanceFromRoot (distance);
           w->SetParent (v);
-          NS_LOG_LOGIC ("Next hop from " <<
+          NS_LOG_LOGIC ("Next hop from " << 
                         v->GetVertexId () << " to " << w->GetVertexId () <<
                         " goes through next hop " << nextHop <<
                         " via outgoing interface " << outIf <<
                         " with distance " << distance);
         }  // end W is a router vertes
-      else
+      else 
         {
           NS_ASSERT (w->GetVertexType () == SPFVertex::VertexNetwork);
 // W is a directly connected network; no next hop is required
           GlobalRoutingLSA* w_lsa = w->GetLSA ();
           NS_ASSERT (w_lsa->GetLSType () == GlobalRoutingLSA::NetworkLSA);
 // Find outgoing interface ID for this network
-          uint32_t outIf = FindOutgoingInterfaceId (w_lsa->GetLinkStateId (),
+          uint32_t outIf = FindOutgoingInterfaceId (w_lsa->GetLinkStateId (), 
                                                     w_lsa->GetNetworkLSANetworkMask () );
 // Set the next hop to 0.0.0.0 meaning "not exist"
           Ipv4Address nextHop = Ipv4Address::GetZero ();
           w->SetRootExitDirection (nextHop, outIf);
           w->SetDistanceFromRoot (distance);
           w->SetParent (v);
-          NS_LOG_LOGIC ("Next hop from " <<
+          NS_LOG_LOGIC ("Next hop from " << 
                         v->GetVertexId () << " to network " << w->GetVertexId () <<
                         " via outgoing interface " << outIf <<
                         " with distance " << distance);
           return 1;
         }
     } // end v is the root
-  else if (v->GetVertexType () == SPFVertex::VertexNetwork)
+  else if (v->GetVertexType () == SPFVertex::VertexNetwork) 
     {
 // See if any of v's parents are the root
       if (v->GetParent () == m_spfroot)
@@ -1107,7 +1110,7 @@ GlobalRouteManagerImpl::SPFNexthopCalculation (
 /* ...For each link in the router-LSA that points back to the
  * parent network, the link's Link Data field provides the IP
  * address of a next hop router.  The outgoing interface to
- * use can then be derived from the next hop IP address (or
+ * use can then be derived from the next hop IP address (or 
  * it can be inherited from the parent network).
  */
               Ipv4Address nextHop = linkRemote->GetLinkData ();
@@ -1119,15 +1122,15 @@ GlobalRouteManagerImpl::SPFNexthopCalculation (
                             " via outgoing interface " << outIf);
             }
         }
-      else
+      else 
         {
           w->SetRootExitDirection (v->GetRootExitDirection ());
         }
     }
-  else
+  else 
     {
 //
-// If we're calculating the next hop information from a node (v) that is
+// If we're calculating the next hop information from a node (v) that is 
 // *not* the root, then we need to "inherit" the information needed to
 // forward the packet from the vertex closer to the root.  That is, we'll
 // still send packets to the next hop address of the router adjacent to the
@@ -1158,7 +1161,7 @@ GlobalRouteManagerImpl::SPFNexthopCalculation (
 //
 // What is done depends on prev_link.  Contrary to appearances, prev_link just
 // acts as a flag here.  If prev_link is NULL, we return the first Global
-// Router Link Record we find that describes a point-to-point link from <v>
+// Router Link Record we find that describes a point-to-point link from <v> 
 // to <w>.  If prev_link is not NULL, we return a Global Router Link Record
 // representing a possible *second* link from <v> to <w>.
 //
@@ -1166,7 +1169,7 @@ GlobalRoutingLinkRecord*
 GlobalRouteManagerImpl::SPFGetNextLink (
   SPFVertex* v,
   SPFVertex* w,
-  GlobalRoutingLinkRecord* prev_link)
+  GlobalRoutingLinkRecord* prev_link) 
 {
   NS_LOG_FUNCTION (this << v << w << prev_link);
 
@@ -1174,7 +1177,7 @@ GlobalRouteManagerImpl::SPFGetNextLink (
   bool found_prev_link = false;
   GlobalRoutingLinkRecord* l;
 //
-// If prev_link is 0, we are really looking for the first link, not the next
+// If prev_link is 0, we are really looking for the first link, not the next 
 // link.
 //
   if (prev_link == 0)
@@ -1198,7 +1201,7 @@ GlobalRouteManagerImpl::SPFGetNextLink (
 // We're just checking to see if the link <l> is actually the link from <v> to
 // <w>.
 //
-      if (l->GetLinkId () == w->GetVertexId ())
+      if (l->GetLinkId () == w->GetVertexId ()) 
         {
           if (!found_prev_link)
             {
@@ -1210,9 +1213,9 @@ GlobalRouteManagerImpl::SPFGetNextLink (
           NS_LOG_LOGIC ("Found matching link l:  linkId = " <<
                         l->GetLinkId () << " linkData = " << l->GetLinkData ());
 //
-// If skip is false, don't (not too surprisingly) skip the link found -- it's
-// the one we're interested in.  That's either because we didn't pass in a
-// previous link, and we're interested in the first one, or because we've
+// If skip is false, don't (not too surprisingly) skip the link found -- it's 
+// the one we're interested in.  That's either because we didn't pass in a 
+// previous link, and we're interested in the first one, or because we've 
 // skipped a previous link and moved forward to the next (which is then the
 // one we want).
 //
@@ -1321,10 +1324,10 @@ GlobalRouteManagerImpl::CheckForStubNode (Ipv4Address root)
                   NS_ASSERT (router);
                   Ptr<Ipv4GlobalRouting> gr = router->GetRoutingProtocol ();
                   NS_ASSERT (gr);
-                  gr->AddNetworkRouteTo (Ipv4Address ("0.0.0.0"), Ipv4Mask ("0.0.0.0"), lr->GetLinkData (),
+                  gr->AddNetworkRouteTo (Ipv4Address ("0.0.0.0"), Ipv4Mask ("0.0.0.0"), lr->GetLinkData (), 
                                          FindOutgoingInterfaceId (transitLink->GetLinkData ()));
-                  NS_LOG_LOGIC ("Inserting default route for node " << myRouterId << " to next hop " <<
-                                lr->GetLinkData () << " via interface " <<
+                  NS_LOG_LOGIC ("Inserting default route for node " << myRouterId << " to next hop " << 
+                                lr->GetLinkData () << " via interface " << 
                                 FindOutgoingInterfaceId (transitLink->GetLinkData ()));
                   return true;
                 }
@@ -1353,12 +1356,12 @@ GlobalRouteManagerImpl::SPFCalculate (Ipv4Address root)
   CandidateQueue candidate;
   NS_ASSERT (candidate.Size () == 0);
 //
-// Initialize the shortest-path tree to only contain the router doing the
+// Initialize the shortest-path tree to only contain the router doing the 
 // calculation.  Each router (and corresponding network) is a vertex in the
 // shortest path first (SPF) tree.
 //
   v = new SPFVertex (m_lsdb->GetLSA (root));
-//
+// 
 // This vertex is the root of the SPF tree and it is distance 0 from the root.
 // We also mark this vertex as being in the SPF tree.
 //
@@ -1370,7 +1373,7 @@ GlobalRouteManagerImpl::SPFCalculate (Ipv4Address root)
 //
 // Optimize SPF calculation, for ns-3.
 // We do not need to calculate SPF for every node in the network if this
-// node has only one interface through which another router can be
+// node has only one interface through which another router can be 
 // reached.  Instead, short-circuit this computation and just install
 // a default route in the CheckForStubNode() method.
 //
@@ -1387,9 +1390,9 @@ GlobalRouteManagerImpl::SPFCalculate (Ipv4Address root)
 // The operations we need to do are given in the OSPF RFC which we reference
 // as we go along.
 //
-// RFC2328 16.1. (2).
+// RFC2328 16.1. (2). 
 //
-// We examine the Global Router Link Records in the Link State
+// We examine the Global Router Link Records in the Link State 
 // Advertisements of the current vertex.  If there are any point-to-point
 // links to unexplored adjacent vertices we add them to the tree and update
 // the distance and next hop information on how to get there.  We also add
@@ -1399,11 +1402,11 @@ GlobalRouteManagerImpl::SPFCalculate (Ipv4Address root)
 //
       SPFNext (v, candidate);
 //
-// RFC2328 16.1. (3).
+// RFC2328 16.1. (3). 
 //
 // If at this step the candidate list is empty, the shortest-path tree (of
 // transit vertices) has been completely built and this stage of the
-// procedure terminates.
+// procedure terminates. 
 //
       if (candidate.Size () == 0)
         {
@@ -1415,7 +1418,7 @@ GlobalRouteManagerImpl::SPFCalculate (Ipv4Address root)
 // list in the process).
 //
 // Recall that in the previous step, we created SPFVertex structures for each
-// of the routers found in the Global Router Link Records and added tehm to
+// of the routers found in the Global Router Link Records and added tehm to 
 // the candidate list.
 //
       NS_LOG_LOGIC (candidate);
@@ -1427,8 +1430,8 @@ GlobalRouteManagerImpl::SPFCalculate (Ipv4Address root)
 //
       v->GetLSA ()->SetStatus (GlobalRoutingLSA::LSA_SPF_IN_SPFTREE);
 //
-// The current vertex has a parent pointer.  By calling this rather oddly
-// named method (blame quagga) we add the current vertex to the list of
+// The current vertex has a parent pointer.  By calling this rather oddly 
+// named method (blame quagga) we add the current vertex to the list of 
 // children of that parent vertex.  In the next hop calculation called during
 // SPFNext, the parent pointer was set but the vertex has been orphaned up
 // to now.
@@ -1437,25 +1440,25 @@ GlobalRouteManagerImpl::SPFCalculate (Ipv4Address root)
 //
 // Note that when there is a choice of vertices closest to the root, network
 // vertices must be chosen before router vertices in order to necessarily
-// find all equal-cost paths.
+// find all equal-cost paths. 
 //
-// RFC2328 16.1. (4).
+// RFC2328 16.1. (4). 
 //
 // This is the method that actually adds the routes.  It'll walk the list
 // of nodes in the system, looking for the node corresponding to the router
 // ID of the root of the tree -- that is the router we're building the routes
 // for.  It looks for the Ipv4 interface of that node and remembers it.  So
-// we are only actually adding routes to that one node at the root of the SPF
+// we are only actually adding routes to that one node at the root of the SPF 
 // tree.
 //
-// We're going to pop of a pointer to every vertex in the tree except the
+// We're going to pop of a pointer to every vertex in the tree except the 
 // root in order of distance from the root.  For each of the vertices, we call
-// SPFIntraAddRouter ().  Down in SPFIntraAddRouter, we look at all of the
+// SPFIntraAddRouter ().  Down in SPFIntraAddRouter, we look at all of the 
 // point-to-point Global Router Link Records (the links to nodes adjacent to
-// the node represented by the vertex).  We add a route to the IP address
+// the node represented by the vertex).  We add a route to the IP address 
 // specified by the m_linkData field of each of those link records.  This will
-// be the *local* IP address associated with the interface attached to the
-// link.  We use the outbound interface and next hop information present in
+// be the *local* IP address associated with the interface attached to the 
+// link.  We use the outbound interface and next hop information present in 
 // the vertex <v> which have possibly been inherited from the root.
 //
 // To summarize, we're going to look at the node represented by <v> and loop
@@ -1475,7 +1478,7 @@ GlobalRouteManagerImpl::SPFCalculate (Ipv4Address root)
           NS_ASSERT_MSG (0, "illegal SPFVertex type");
         }
 //
-// RFC2328 16.1. (5).
+// RFC2328 16.1. (5). 
 //
 // Iterate the algorithm by returning to Step 2 until there are no more
 // candidate vertices.
@@ -1505,7 +1508,7 @@ void
 GlobalRouteManagerImpl::ProcessASExternals (SPFVertex* v, GlobalRoutingLSA* extlsa)
 {
   NS_LOG_FUNCTION (this << v << extlsa);
-  NS_LOG_LOGIC ("Processing external for destination " <<
+  NS_LOG_LOGIC ("Processing external for destination " << 
                 extlsa->GetLinkStateId () <<
                 ", for router "  << v->GetVertexId () <<
                 ", advertised by " << extlsa->GetAdvertisingRouter ());
@@ -1546,11 +1549,11 @@ GlobalRouteManagerImpl::SPFAddASExternal (GlobalRoutingLSA *extlsa, SPFVertex *v
 // OR find best path to the advertising router
   if (v->GetVertexId () == m_spfroot->GetVertexId ())
     {
-      NS_LOG_LOGIC ("External is on local host: "
+      NS_LOG_LOGIC ("External is on local host: " 
                     << v->GetVertexId () << "; returning");
       return;
     }
-  NS_LOG_LOGIC ("External is on remote host: "
+  NS_LOG_LOGIC ("External is on remote host: " 
                 << extlsa->GetAdvertisingRouter () << "; installing");
 
   Ipv4Address routerId = m_spfroot->GetVertexId ();
@@ -1561,7 +1564,7 @@ GlobalRouteManagerImpl::SPFAddASExternal (GlobalRoutingLSA *extlsa, SPFVertex *v
 // ID corresponding to the root vertex.  This is the one we're going to write
 // the routing information to.
 //
-  NodeList::Iterator i = NodeList::Begin ();
+  NodeList::Iterator i = NodeList::Begin (); 
   NodeList::Iterator listEnd = NodeList::End ();
   for (; i != listEnd; i++)
     {
@@ -1570,7 +1573,7 @@ GlobalRouteManagerImpl::SPFAddASExternal (GlobalRoutingLSA *extlsa, SPFVertex *v
 // The router ID is accessible through the GlobalRouter interface, so we need
 // to QI for that interface.  If there's no GlobalRouter interface, the node
 // in question cannot be the router we want, so we continue.
-//
+// 
       Ptr<GlobalRouter> rtr = node->GetObject<GlobalRouter> ();
 
       if (rtr == 0)
@@ -1579,8 +1582,8 @@ GlobalRouteManagerImpl::SPFAddASExternal (GlobalRoutingLSA *extlsa, SPFVertex *v
           continue;
         }
 //
-// If the router ID of the current node is equal to the router ID of the
-// root of the SPF tree, then this node is the one for which we need to
+// If the router ID of the current node is equal to the router ID of the 
+// root of the SPF tree, then this node is the one for which we need to 
 // write the routing tables.
 //
       NS_LOG_LOGIC ("Considering router " << rtr->GetRouterId ());
@@ -1594,7 +1597,7 @@ GlobalRouteManagerImpl::SPFAddASExternal (GlobalRoutingLSA *extlsa, SPFVertex *v
 // should absolutely have an Ipv4 interface.
 //
           Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
-          NS_ASSERT_MSG (ipv4,
+          NS_ASSERT_MSG (ipv4, 
                          "GlobalRouteManagerImpl::SPFIntraAddRouter (): "
                          "QI for <Ipv4> interface failed");
 //
@@ -1603,7 +1606,7 @@ GlobalRouteManagerImpl::SPFAddASExternal (GlobalRoutingLSA *extlsa, SPFVertex *v
 // Link Records corresponding to links off of that vertex / node.  We're going
 // to be interested in the records corresponding to point-to-point links.
 //
-          NS_ASSERT_MSG (v->GetLSA (),
+          NS_ASSERT_MSG (v->GetLSA (), 
                          "GlobalRouteManagerImpl::SPFIntraAddRouter (): "
                          "Expected valid LSA in SPFVertex* v");
           Ipv4Mask tempmask = extlsa->GetNetworkLSANetworkMask ();
@@ -1616,8 +1619,8 @@ GlobalRouteManagerImpl::SPFAddASExternal (GlobalRoutingLSA *extlsa, SPFVertex *v
 // record.  In the case of a point-to-point link, this is the local IP address
 // of the node connected to the link.  Each of these point-to-point links
 // will correspond to a local interface that has an IP address to which
-// the node at the root of the SPF tree can send packets.  The vertex <v>
-// (corresponding to the node that has these links and interfaces) has
+// the node at the root of the SPF tree can send packets.  The vertex <v> 
+// (corresponding to the node that has these links and interfaces) has 
 // an m_nextHop address precalculated for us that is the address to which the
 // root node should send packets to be forwarded to these IP addresses.
 // Similarly, the vertex <v> has an m_rootOif (outbound interface index) to
@@ -1673,7 +1676,7 @@ GlobalRouteManagerImpl::SPFProcessStubs (SPFVertex* v)
       NS_LOG_LOGIC ("Processing router LSA with id " << rlsa->GetLinkStateId ());
       for (uint32_t i = 0; i < rlsa->GetNLinkRecords (); i++)
         {
-          NS_LOG_LOGIC ("Examining link " << i << " of " <<
+          NS_LOG_LOGIC ("Examining link " << i << " of " << 
                         v->GetVertexId () << "'s " <<
                         v->GetLSA ()->GetNLinkRecords () << " link records");
           GlobalRoutingLinkRecord *l = v->GetLSA ()->GetLinkRecord (i);
@@ -1695,13 +1698,13 @@ GlobalRouteManagerImpl::SPFProcessStubs (SPFVertex* v)
     }
 }
 
-// RFC2328 16.1. second stage.
+// RFC2328 16.1. second stage. 
 void
 GlobalRouteManagerImpl::SPFIntraAddStub (GlobalRoutingLinkRecord *l, SPFVertex* v)
 {
   NS_LOG_FUNCTION (this << l << v);
 
-  NS_ASSERT_MSG (m_spfroot,
+  NS_ASSERT_MSG (m_spfroot, 
                  "GlobalRouteManagerImpl::SPFIntraAddStub (): Root pointer not set");
 
   // XXX simplifed logic for the moment.  There are two cases to consider:
@@ -1716,7 +1719,7 @@ GlobalRouteManagerImpl::SPFIntraAddStub (GlobalRoutingLinkRecord *l, SPFVertex*
     }
   NS_LOG_LOGIC ("Stub is on remote host: " << v->GetVertexId () << "; installing");
 //
-// The root of the Shortest Path First tree is the router to which we are
+// The root of the Shortest Path First tree is the router to which we are 
 // going to write the actual routing table entries.  The vertex corresponding
 // to this router has a vertex ID which is the router ID of that node.  We're
 // going to use this ID to discover which node it is that we're actually going
@@ -1730,7 +1733,7 @@ GlobalRouteManagerImpl::SPFIntraAddStub (GlobalRoutingLinkRecord *l, SPFVertex*
 // ID corresponding to the root vertex.  This is the one we're going to write
 // the routing information to.
 //
-  NodeList::Iterator i = NodeList::Begin ();
+  NodeList::Iterator i = NodeList::Begin (); 
   NodeList::Iterator listEnd = NodeList::End ();
   for (; i != listEnd; i++)
     {
@@ -1739,19 +1742,19 @@ GlobalRouteManagerImpl::SPFIntraAddStub (GlobalRoutingLinkRecord *l, SPFVertex*
 // The router ID is accessible through the GlobalRouter interface, so we need
 // to QI for that interface.  If there's no GlobalRouter interface, the node
 // in question cannot be the router we want, so we continue.
-//
-      Ptr<GlobalRouter> rtr =
+// 
+      Ptr<GlobalRouter> rtr = 
         node->GetObject<GlobalRouter> ();
 
       if (rtr == 0)
         {
-          NS_LOG_LOGIC ("No GlobalRouter interface on node " <<
+          NS_LOG_LOGIC ("No GlobalRouter interface on node " << 
                         node->GetId ());
           continue;
         }
 //
-// If the router ID of the current node is equal to the router ID of the
-// root of the SPF tree, then this node is the one for which we need to
+// If the router ID of the current node is equal to the router ID of the 
+// root of the SPF tree, then this node is the one for which we need to 
 // write the routing tables.
 //
       NS_LOG_LOGIC ("Considering router " << rtr->GetRouterId ());
@@ -1765,7 +1768,7 @@ GlobalRouteManagerImpl::SPFIntraAddStub (GlobalRoutingLinkRecord *l, SPFVertex*
 // should absolutely have an Ipv4 interface.
 //
           Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
-          NS_ASSERT_MSG (ipv4,
+          NS_ASSERT_MSG (ipv4, 
                          "GlobalRouteManagerImpl::SPFIntraAddRouter (): "
                          "QI for <Ipv4> interface failed");
 //
@@ -1774,7 +1777,7 @@ GlobalRouteManagerImpl::SPFIntraAddStub (GlobalRoutingLinkRecord *l, SPFVertex*
 // Link Records corresponding to links off of that vertex / node.  We're going
 // to be interested in the records corresponding to point-to-point links.
 //
-          NS_ASSERT_MSG (v->GetLSA (),
+          NS_ASSERT_MSG (v->GetLSA (), 
                          "GlobalRouteManagerImpl::SPFIntraAddRouter (): "
                          "Expected valid LSA in SPFVertex* v");
           Ipv4Mask tempmask (l->GetLinkData ().Get ());
@@ -1786,8 +1789,8 @@ GlobalRouteManagerImpl::SPFIntraAddStub (GlobalRoutingLinkRecord *l, SPFVertex*
 // record.  In the case of a point-to-point link, this is the local IP address
 // of the node connected to the link.  Each of these point-to-point links
 // will correspond to a local interface that has an IP address to which
-// the node at the root of the SPF tree can send packets.  The vertex <v>
-// (corresponding to the node that has these links and interfaces) has
+// the node at the root of the SPF tree can send packets.  The vertex <v> 
+// (corresponding to the node that has these links and interfaces) has 
 // an m_nextHop address precalculated for us that is the address to which the
 // root node should send packets to be forwarded to these IP addresses.
 // Similarly, the vertex <v> has an m_rootOif (outbound interface index) to
@@ -1854,13 +1857,13 @@ GlobalRouteManagerImpl::FindOutgoingInterfaceId (Ipv4Address a, Ipv4Mask amask)
 // the node at the root of the SPF tree.  This is the node for which we are
 // building the routing table.
 //
-  NodeList::Iterator i = NodeList::Begin ();
+  NodeList::Iterator i = NodeList::Begin (); 
   NodeList::Iterator listEnd = NodeList::End ();
   for (; i != listEnd; i++)
     {
       Ptr<Node> node = *i;
 
-      Ptr<GlobalRouter> rtr =
+      Ptr<GlobalRouter> rtr = 
         node->GetObject<GlobalRouter> ();
 //
 // If the node doesn't have a GlobalRouter interface it can't be the one
@@ -1876,11 +1879,11 @@ GlobalRouteManagerImpl::FindOutgoingInterfaceId (Ipv4Address a, Ipv4Mask amask)
 //
 // This is the node we're building the routing table for.  We're going to need
 // the Ipv4 interface to look for the ipv4 interface index.  Since this node
-// is participating in routing IP version 4 packets, it certainly must have
+// is participating in routing IP version 4 packets, it certainly must have 
 // an Ipv4 interface.
 //
           Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
-          NS_ASSERT_MSG (ipv4,
+          NS_ASSERT_MSG (ipv4, 
                          "GlobalRouteManagerImpl::FindOutgoingInterfaceId (): "
                          "GetObject for <Ipv4> interface failed");
 //
@@ -1896,7 +1899,7 @@ GlobalRouteManagerImpl::FindOutgoingInterfaceId (Ipv4Address a, Ipv4Mask amask)
               NS_FATAL_ERROR ("GlobalRouteManagerImpl::FindOutgoingInterfaceId(): "
                               "Expected an interface associated with address a:" << a);
             }
-#endif
+#endif 
           return interface;
         }
     }
@@ -1928,10 +1931,10 @@ GlobalRouteManagerImpl::SPFIntraAddRouter (SPFVertex* v)
 {
   NS_LOG_FUNCTION (this << v);
 
-  NS_ASSERT_MSG (m_spfroot,
+  NS_ASSERT_MSG (m_spfroot, 
                  "GlobalRouteManagerImpl::SPFIntraAddRouter (): Root pointer not set");
 //
-// The root of the Shortest Path First tree is the router to which we are
+// The root of the Shortest Path First tree is the router to which we are 
 // going to write the actual routing table entries.  The vertex corresponding
 // to this router has a vertex ID which is the router ID of that node.  We're
 // going to use this ID to discover which node it is that we're actually going
@@ -1945,28 +1948,28 @@ GlobalRouteManagerImpl::SPFIntraAddRouter (SPFVertex* v)
 // ID corresponding to the root vertex.  This is the one we're going to write
 // the routing information to.
 //
-  NodeList::Iterator i = NodeList::Begin ();
+  NodeList::Iterator i = NodeList::Begin (); 
   NodeList::Iterator listEnd = NodeList::End ();
   for (; i != listEnd; i++)
     {
       Ptr<Node> node = *i;
 //
 // The router ID is accessible through the GlobalRouter interface, so we need
-// to GetObject for that interface.  If there's no GlobalRouter interface,
+// to GetObject for that interface.  If there's no GlobalRouter interface, 
 // the node in question cannot be the router we want, so we continue.
-//
-      Ptr<GlobalRouter> rtr =
+// 
+      Ptr<GlobalRouter> rtr = 
         node->GetObject<GlobalRouter> ();
 
       if (rtr == 0)
         {
-          NS_LOG_LOGIC ("No GlobalRouter interface on node " <<
+          NS_LOG_LOGIC ("No GlobalRouter interface on node " << 
                         node->GetId ());
           continue;
         }
 //
-// If the router ID of the current node is equal to the router ID of the
-// root of the SPF tree, then this node is the one for which we need to
+// If the router ID of the current node is equal to the router ID of the 
+// root of the SPF tree, then this node is the one for which we need to 
 // write the routing tables.
 //
       NS_LOG_LOGIC ("Considering router " << rtr->GetRouterId ());
@@ -1975,12 +1978,12 @@ GlobalRouteManagerImpl::SPFIntraAddRouter (SPFVertex* v)
         {
           NS_LOG_LOGIC ("Setting routes for node " << node->GetId ());
 //
-// Routing information is updated using the Ipv4 interface.  We need to
-// GetObject for that interface.  If the node is acting as an IP version 4
+// Routing information is updated using the Ipv4 interface.  We need to 
+// GetObject for that interface.  If the node is acting as an IP version 4 
 // router, it should absolutely have an Ipv4 interface.
 //
           Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
-          NS_ASSERT_MSG (ipv4,
+          NS_ASSERT_MSG (ipv4, 
                          "GlobalRouteManagerImpl::SPFIntraAddRouter (): "
                          "GetObject for <Ipv4> interface failed");
 //
@@ -1990,7 +1993,7 @@ GlobalRouteManagerImpl::SPFIntraAddRouter (SPFVertex* v)
 // to be interested in the records corresponding to point-to-point links.
 //
           GlobalRoutingLSA *lsa = v->GetLSA ();
-          NS_ASSERT_MSG (lsa,
+          NS_ASSERT_MSG (lsa, 
                          "GlobalRouteManagerImpl::SPFIntraAddRouter (): "
                          "Expected valid LSA in SPFVertex* v");
 
@@ -2021,8 +2024,8 @@ GlobalRouteManagerImpl::SPFIntraAddRouter (SPFVertex* v)
 // record.  In the case of a point-to-point link, this is the local IP address
 // of the node connected to the link.  Each of these point-to-point links
 // will correspond to a local interface that has an IP address to which
-// the node at the root of the SPF tree can send packets.  The vertex <v>
-// (corresponding to the node that has these links and interfaces) has
+// the node at the root of the SPF tree can send packets.  The vertex <v> 
+// (corresponding to the node that has these links and interfaces) has 
 // an m_nextHop address precalculated for us that is the address to which the
 // root node should send packets to be forwarded to these IP addresses.
 // Similarly, the vertex <v> has an m_rootOif (outbound interface index) to
@@ -2073,10 +2076,10 @@ GlobalRouteManagerImpl::SPFIntraAddTransit (SPFVertex* v)
 {
   NS_LOG_FUNCTION (this << v);
 
-  NS_ASSERT_MSG (m_spfroot,
+  NS_ASSERT_MSG (m_spfroot, 
                  "GlobalRouteManagerImpl::SPFIntraAddTransit (): Root pointer not set");
 //
-// The root of the Shortest Path First tree is the router to which we are
+// The root of the Shortest Path First tree is the router to which we are 
 // going to write the actual routing table entries.  The vertex corresponding
 // to this router has a vertex ID which is the router ID of that node.  We're
 // going to use this ID to discover which node it is that we're actually going
@@ -2090,28 +2093,28 @@ GlobalRouteManagerImpl::SPFIntraAddTransit (SPFVertex* v)
 // ID corresponding to the root vertex.  This is the one we're going to write
 // the routing information to.
 //
-  NodeList::Iterator i = NodeList::Begin ();
+  NodeList::Iterator i = NodeList::Begin (); 
   NodeList::Iterator listEnd = NodeList::End ();
   for (; i != listEnd; i++)
     {
       Ptr<Node> node = *i;
 //
 // The router ID is accessible through the GlobalRouter interface, so we need
-// to GetObject for that interface.  If there's no GlobalRouter interface,
+// to GetObject for that interface.  If there's no GlobalRouter interface, 
 // the node in question cannot be the router we want, so we continue.
-//
-      Ptr<GlobalRouter> rtr =
+// 
+      Ptr<GlobalRouter> rtr = 
         node->GetObject<GlobalRouter> ();
 
       if (rtr == 0)
         {
-          NS_LOG_LOGIC ("No GlobalRouter interface on node " <<
+          NS_LOG_LOGIC ("No GlobalRouter interface on node " << 
                         node->GetId ());
           continue;
         }
 //
-// If the router ID of the current node is equal to the router ID of the
-// root of the SPF tree, then this node is the one for which we need to
+// If the router ID of the current node is equal to the router ID of the 
+// root of the SPF tree, then this node is the one for which we need to 
 // write the routing tables.
 //
       NS_LOG_LOGIC ("Considering router " << rtr->GetRouterId ());
@@ -2120,12 +2123,12 @@ GlobalRouteManagerImpl::SPFIntraAddTransit (SPFVertex* v)
         {
           NS_LOG_LOGIC ("setting routes for node " << node->GetId ());
 //
-// Routing information is updated using the Ipv4 interface.  We need to
-// GetObject for that interface.  If the node is acting as an IP version 4
+// Routing information is updated using the Ipv4 interface.  We need to 
+// GetObject for that interface.  If the node is acting as an IP version 4 
 // router, it should absolutely have an Ipv4 interface.
 //
           Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
-          NS_ASSERT_MSG (ipv4,
+          NS_ASSERT_MSG (ipv4, 
                          "GlobalRouteManagerImpl::SPFIntraAddTransit (): "
                          "GetObject for <Ipv4> interface failed");
 //
@@ -2135,7 +2138,7 @@ GlobalRouteManagerImpl::SPFIntraAddTransit (SPFVertex* v)
 // to be interested in the records corresponding to point-to-point links.
 //
           GlobalRoutingLSA *lsa = v->GetLSA ();
-          NS_ASSERT_MSG (lsa,
+          NS_ASSERT_MSG (lsa, 
                          "GlobalRouteManagerImpl::SPFIntraAddTransit (): "
                          "Expected valid LSA in SPFVertex* v");
           Ipv4Mask tempmask = lsa->GetNetworkLSANetworkMask ();
@@ -2174,14 +2177,14 @@ GlobalRouteManagerImpl::SPFIntraAddTransit (SPFVertex* v)
                 }
             }
         }
-    }
+    } 
 }
 
 // Derived from quagga ospf_vertex_add_parents ()
 //
 // This is a somewhat oddly named method (blame quagga).  Although you might
 // expect it to add a parent *to* something, it actually adds a vertex
-// to the list of children *in* each of its parents.
+// to the list of children *in* each of its parents. 
 //
 // Given a pointer to a vertex, it links back to the vertex's parent that it
 // already has set and adds itself to that vertex's list of children.
diff --git a/src/internet/model/ipv4-end-point-demux.cc b/src/internet/model/ipv4-end-point-demux.cc
index 470b71e..7e06770 100644
--- a/src/internet/model/ipv4-end-point-demux.cc
+++ b/src/internet/model/ipv4-end-point-demux.cc
@@ -35,7 +35,7 @@ Ipv4EndPointDemux::Ipv4EndPointDemux ()
 Ipv4EndPointDemux::~Ipv4EndPointDemux ()
 {
   NS_LOG_FUNCTION (this);
-  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++)
+  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++) 
     {
       Ipv4EndPoint *endPoint = *i;
       delete endPoint;
@@ -47,9 +47,9 @@ bool
 Ipv4EndPointDemux::LookupPortLocal (uint16_t port)
 {
   NS_LOG_FUNCTION (this << port);
-  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++)
+  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++) 
     {
-      if ((*i)->GetLocalPort  () == port)
+      if ((*i)->GetLocalPort  () == port) 
         {
           return true;
         }
@@ -61,10 +61,10 @@ bool
 Ipv4EndPointDemux::LookupLocal (Ipv4Address addr, uint16_t port)
 {
   NS_LOG_FUNCTION (this << addr << port);
-  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++)
+  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++) 
     {
       if ((*i)->GetLocalPort () == port &&
-          (*i)->GetLocalAddress () == addr)
+          (*i)->GetLocalAddress () == addr) 
         {
           return true;
         }
@@ -72,41 +72,12 @@ Ipv4EndPointDemux::LookupLocal (Ipv4Address addr, uint16_t port)
   return false;
 }
 
-//Ipv4EndPointDemux::EndPoints
-//Ipv4EndPointDemux::LookupMpTcpToken (uint32_t token)
-//{
-//  NS_LOG_FUNCTION (this);
-//  EndPoints ret;
-//
-//  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++)
-//    {
-//      Ipv4EndPoint* endP = *i;
-//      NS_LOG_DEBUG ("Looking at endpoint m_mptcpToken=" << endP->m_mptcpToken
-//                    << " daddr=" << endP->GetLocalAddress ()
-//                        );
-//
-//      if (endP->m_mptcpToken == token
-//          /*
-//          TODO as a temporary measure we say that if the token matches then it's ok
-//          but we should check if the endpoint node has an IP that matches the dest IP !!
-//          */
-////          && endP->GetLocalAddress () == addr
-//          )
-//        {
-//          NS_LOG_DEBUG("Found a match for token with endpoint=" << endP);
-//          //GetBoundNetDevice
-//          ret.push_back (endP);
-//        }
-//    }
-//    return ret;
-//}
-
 Ipv4EndPoint *
 Ipv4EndPointDemux::Allocate (void)
 {
   NS_LOG_FUNCTION (this);
   uint16_t port = AllocateEphemeralPort ();
-  if (port == 0)
+  if (port == 0) 
     {
       NS_LOG_WARN ("Ephemeral port allocation failed.");
       return 0;
@@ -122,7 +93,7 @@ Ipv4EndPointDemux::Allocate (Ipv4Address address)
 {
   NS_LOG_FUNCTION (this << address);
   uint16_t port = AllocateEphemeralPort ();
-  if (port == 0)
+  if (port == 0) 
     {
       NS_LOG_WARN ("Ephemeral port allocation failed.");
       return 0;
@@ -145,7 +116,7 @@ Ipv4EndPoint *
 Ipv4EndPointDemux::Allocate (Ipv4Address address, uint16_t port)
 {
   NS_LOG_FUNCTION (this << address << port);
-  if (LookupLocal (address, port))
+  if (LookupLocal (address, port)) 
     {
       NS_LOG_WARN ("Duplicate address/port; failing.");
       return 0;
@@ -161,12 +132,12 @@ Ipv4EndPointDemux::Allocate (Ipv4Address localAddress, uint16_t localPort,
                              Ipv4Address peerAddress, uint16_t peerPort)
 {
   NS_LOG_FUNCTION (this << localAddress << localPort << peerAddress << peerPort);
-  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++)
+  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++) 
     {
       if ((*i)->GetLocalPort () == localPort &&
           (*i)->GetLocalAddress () == localAddress &&
           (*i)->GetPeerPort () == peerPort &&
-          (*i)->GetPeerAddress () == peerAddress)
+          (*i)->GetPeerAddress () == peerAddress) 
         {
           NS_LOG_WARN ("No way we can allocate this end-point.");
           /* no way we can allocate this end-point. */
@@ -182,11 +153,11 @@ Ipv4EndPointDemux::Allocate (Ipv4Address localAddress, uint16_t localPort,
   return endPoint;
 }
 
-void
+void 
 Ipv4EndPointDemux::DeAllocate (Ipv4EndPoint *endPoint)
 {
   NS_LOG_FUNCTION (this << endPoint);
-  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++)
+  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++) 
     {
       if (*i == endPoint)
         {
@@ -221,26 +192,26 @@ Ipv4EndPointDemux::GetAllEndPoints (void)
  * Otherwise, we return 0.
  */
 Ipv4EndPointDemux::EndPoints
-Ipv4EndPointDemux::Lookup (Ipv4Address daddr, uint16_t dport,
+Ipv4EndPointDemux::Lookup (Ipv4Address daddr, uint16_t dport, 
                            Ipv4Address saddr, uint16_t sport,
                            Ptr<Ipv4Interface> incomingInterface)
 {
   NS_LOG_FUNCTION (this << daddr << dport << saddr << sport << incomingInterface);
-
+  
   EndPoints retval1; // Matches exact on local port, wildcards on others
   EndPoints retval2; // Matches exact on local port/adder, wildcards on others
   EndPoints retval3; // Matches all but local address
   EndPoints retval4; // Exact match on all 4
 
   NS_LOG_DEBUG ("Looking up endpoint for destination address " << daddr);
-  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++)
+  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++) 
     {
       Ipv4EndPoint* endP = *i;
       NS_LOG_DEBUG ("Looking at endpoint dport=" << endP->GetLocalPort ()
                                                  << " daddr=" << endP->GetLocalAddress ()
                                                  << " sport=" << endP->GetPeerPort ()
                                                  << " saddr=" << endP->GetPeerAddress ());
-      if (endP->GetLocalPort () != dport)
+      if (endP->GetLocalPort () != dport) 
         {
           NS_LOG_LOGIC ("Skipping endpoint " << &endP
                                              << " because endpoint dport "
@@ -273,7 +244,7 @@ Ipv4EndPointDemux::Lookup (Ipv4Address daddr, uint16_t dport,
         }
       bool isBroadcast = (daddr.IsBroadcast () || subnetDirected == true);
       NS_LOG_DEBUG ("dest addr " << daddr << " broadcast? " << isBroadcast);
-      bool localAddressMatchesWildCard =
+      bool localAddressMatchesWildCard = 
         endP->GetLocalAddress () == Ipv4Address::GetAny ();
       bool localAddressMatchesExact = endP->GetLocalAddress () == daddr;
 
@@ -289,7 +260,7 @@ Ipv4EndPointDemux::Lookup (Ipv4Address daddr, uint16_t dport,
         }
       // if no match here, keep looking
       if (!(localAddressMatchesExact || localAddressMatchesWildCard))
-        continue;
+        continue; 
       bool remotePeerMatchesExact = endP->GetPeerPort () == sport;
       bool remotePeerMatchesWildCard = endP->GetPeerPort () == 0;
       bool remoteAddressMatchesExact = endP->GetPeerAddress () == saddr;
@@ -337,9 +308,9 @@ Ipv4EndPointDemux::Lookup (Ipv4Address daddr, uint16_t dport,
 }
 
 Ipv4EndPoint *
-Ipv4EndPointDemux::SimpleLookup (Ipv4Address daddr,
-                                 uint16_t dport,
-                                 Ipv4Address saddr,
+Ipv4EndPointDemux::SimpleLookup (Ipv4Address daddr, 
+                                 uint16_t dport, 
+                                 Ipv4Address saddr, 
                                  uint16_t sport)
 {
   NS_LOG_FUNCTION (this << daddr << dport << saddr << sport);
@@ -348,29 +319,29 @@ Ipv4EndPointDemux::SimpleLookup (Ipv4Address daddr,
   // function.
   uint32_t genericity = 3;
   Ipv4EndPoint *generic = 0;
-  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++)
+  for (EndPointsI i = m_endPoints.begin (); i != m_endPoints.end (); i++) 
     {
-      if ((*i)->GetLocalPort () != dport)
+      if ((*i)->GetLocalPort () != dport) 
         {
           continue;
         }
       if ((*i)->GetLocalAddress () == daddr &&
           (*i)->GetPeerPort () == sport &&
-          (*i)->GetPeerAddress () == saddr)
+          (*i)->GetPeerAddress () == saddr) 
         {
           /* this is an exact match. */
           return *i;
         }
       uint32_t tmp = 0;
-      if ((*i)->GetLocalAddress () == Ipv4Address::GetAny ())
+      if ((*i)->GetLocalAddress () == Ipv4Address::GetAny ()) 
         {
           tmp++;
         }
-      if ((*i)->GetPeerAddress () == Ipv4Address::GetAny ())
+      if ((*i)->GetPeerAddress () == Ipv4Address::GetAny ()) 
         {
           tmp++;
         }
-      if (tmp < genericity)
+      if (tmp < genericity) 
         {
           generic = (*i);
           genericity = tmp;
@@ -385,7 +356,7 @@ Ipv4EndPointDemux::AllocateEphemeralPort (void)
   NS_LOG_FUNCTION (this);
   uint16_t port = m_ephemeral;
   int count = m_portLast - m_portFirst;
-  do
+  do 
     {
       if (count-- < 0)
         {
diff --git a/src/internet/model/ipv4-end-point-demux.h b/src/internet/model/ipv4-end-point-demux.h
index cb4ef86..7cb0e0d 100644
--- a/src/internet/model/ipv4-end-point-demux.h
+++ b/src/internet/model/ipv4-end-point-demux.h
@@ -85,9 +85,9 @@ public:
    * \param incomingInterface the incoming interface
    * \return list of IPv4EndPoints (could be 0 element)
    */
-  EndPoints Lookup (Ipv4Address daddr,
-                    uint16_t dport,
-                    Ipv4Address saddr,
+  EndPoints Lookup (Ipv4Address daddr, 
+                    uint16_t dport, 
+                    Ipv4Address saddr, 
                     uint16_t sport,
                     Ptr<Ipv4Interface> incomingInterface);
 
@@ -99,18 +99,12 @@ public:
    * \param sport source port to test
    * \return IPv4EndPoint (0 if not found)
    */
-  Ipv4EndPoint *SimpleLookup (Ipv4Address daddr,
-                              uint16_t dport,
-                              Ipv4Address saddr,
+  Ipv4EndPoint *SimpleLookup (Ipv4Address daddr, 
+                              uint16_t dport, 
+                              Ipv4Address saddr, 
                               uint16_t sport);
 
   /**
-   * Returns endpoints with tokens
-   * \return list of it in case of token collisions
-   */
-//  EndPoints LookupMpTcpToken (Ipv4Address addr, uint32_t token);
-
-  /**
    * \brief Allocate a Ipv4EndPoint.
    * \return an empty Ipv4EndPoint instance
    */
@@ -146,9 +140,9 @@ public:
    * \param peerPort peer port
    * \return an Ipv4EndPoint instance
    */
-  Ipv4EndPoint *Allocate (Ipv4Address localAddress,
+  Ipv4EndPoint *Allocate (Ipv4Address localAddress, 
                           uint16_t localPort,
-                          Ipv4Address peerAddress,
+                          Ipv4Address peerAddress, 
                           uint16_t peerPort);
 
   /**
diff --git a/src/internet/model/ipv4-end-point.cc b/src/internet/model/ipv4-end-point.cc
index 4b12831..3967e5f 100644
--- a/src/internet/model/ipv4-end-point.cc
+++ b/src/internet/model/ipv4-end-point.cc
@@ -28,7 +28,7 @@ namespace ns3 {
 NS_LOG_COMPONENT_DEFINE ("Ipv4EndPoint");
 
 Ipv4EndPoint::Ipv4EndPoint (Ipv4Address address, uint16_t port)
-  : m_localAddr (address),
+  : m_localAddr (address), 
     m_localPort (port),
     m_peerAddr (Ipv4Address::GetAny ()),
     m_peerPort (0)
@@ -47,46 +47,39 @@ Ipv4EndPoint::~Ipv4EndPoint ()
   m_destroyCallback.Nullify ();
 }
 
-void 
-Ipv4EndPoint::Print (std::ostream &os) const
-{
-  os << "src.ip=" << GetLocalAddress () << " src.port="<< GetLocalPort()
-    << "dst.ip=" << GetPeerAddress () << " dst.port="<< GetPeerPort();
-}
- 
-Ipv4Address
-Ipv4EndPoint::GetLocalAddress (void) const
+Ipv4Address 
+Ipv4EndPoint::GetLocalAddress (void)
 {
   NS_LOG_FUNCTION (this);
   return m_localAddr;
 }
 
-void
+void 
 Ipv4EndPoint::SetLocalAddress (Ipv4Address address)
 {
   NS_LOG_FUNCTION (this << address);
   m_localAddr = address;
 }
 
-uint16_t
-Ipv4EndPoint::GetLocalPort (void) const
+uint16_t 
+Ipv4EndPoint::GetLocalPort (void)
 {
   NS_LOG_FUNCTION (this);
   return m_localPort;
 }
-Ipv4Address
-Ipv4EndPoint::GetPeerAddress (void) const
+Ipv4Address 
+Ipv4EndPoint::GetPeerAddress (void)
 {
   NS_LOG_FUNCTION (this);
   return m_peerAddr;
 }
-uint16_t
-Ipv4EndPoint::GetPeerPort (void) const
+uint16_t 
+Ipv4EndPoint::GetPeerPort (void)
 {
   NS_LOG_FUNCTION (this);
   return m_peerPort;
 }
-void
+void 
 Ipv4EndPoint::SetPeer (Ipv4Address address, uint16_t port)
 {
   NS_LOG_FUNCTION (this << address << port);
@@ -102,59 +95,59 @@ Ipv4EndPoint::BindToNetDevice (Ptr<NetDevice> netdevice)
   return;
 }
 
-Ptr<NetDevice>
+Ptr<NetDevice> 
 Ipv4EndPoint::GetBoundNetDevice (void)
 {
   NS_LOG_FUNCTION (this);
   return m_boundnetdevice;
 }
 
-void
+void 
 Ipv4EndPoint::SetRxCallback (Callback<void,Ptr<Packet>, Ipv4Header, uint16_t, Ptr<Ipv4Interface> > callback)
 {
   NS_LOG_FUNCTION (this << &callback);
   m_rxCallback = callback;
 }
-void
+void 
 Ipv4EndPoint::SetIcmpCallback (Callback<void,Ipv4Address,uint8_t,uint8_t,uint8_t,uint32_t> callback)
 {
   NS_LOG_FUNCTION (this << &callback);
   m_icmpCallback = callback;
 }
 
-void
+void 
 Ipv4EndPoint::SetDestroyCallback (Callback<void> callback)
 {
   NS_LOG_FUNCTION (this << &callback);
   m_destroyCallback = callback;
 }
 
-void
+void 
 Ipv4EndPoint::ForwardUp (Ptr<Packet> p, const Ipv4Header& header, uint16_t sport,
                          Ptr<Ipv4Interface> incomingInterface)
 {
   NS_LOG_FUNCTION (this << p << &header << sport << incomingInterface);
-
+  
   if (!m_rxCallback.IsNull ())
     {
-      Simulator::ScheduleNow (&Ipv4EndPoint::DoForwardUp, this, p, header, sport,
+      Simulator::ScheduleNow (&Ipv4EndPoint::DoForwardUp, this, p, header, sport, 
                               incomingInterface);
     }
 }
-void
+void 
 Ipv4EndPoint::DoForwardUp (Ptr<Packet> p, const Ipv4Header& header, uint16_t sport,
                            Ptr<Ipv4Interface> incomingInterface)
 {
   NS_LOG_FUNCTION (this << p << &header << sport << incomingInterface);
-
+  
   if (!m_rxCallback.IsNull ())
     {
       m_rxCallback (p, header, sport, incomingInterface);
     }
 }
 
-void
-Ipv4EndPoint::ForwardIcmp (Ipv4Address icmpSource, uint8_t icmpTtl,
+void 
+Ipv4EndPoint::ForwardIcmp (Ipv4Address icmpSource, uint8_t icmpTtl, 
                            uint8_t icmpType, uint8_t icmpCode,
                            uint32_t icmpInfo)
 {
@@ -162,17 +155,17 @@ Ipv4EndPoint::ForwardIcmp (Ipv4Address icmpSource, uint8_t icmpTtl,
                    (uint32_t)icmpCode << icmpInfo);
   if (!m_icmpCallback.IsNull ())
     {
-      Simulator::ScheduleNow (&Ipv4EndPoint::DoForwardIcmp, this,
+      Simulator::ScheduleNow (&Ipv4EndPoint::DoForwardIcmp, this, 
                               icmpSource, icmpTtl, icmpType, icmpCode, icmpInfo);
     }
 }
-void
-Ipv4EndPoint::DoForwardIcmp (Ipv4Address icmpSource, uint8_t icmpTtl,
+void 
+Ipv4EndPoint::DoForwardIcmp (Ipv4Address icmpSource, uint8_t icmpTtl, 
                              uint8_t icmpType, uint8_t icmpCode,
                              uint32_t icmpInfo)
 {
   NS_LOG_FUNCTION (this << icmpSource << static_cast<uint32_t> (icmpTtl) << static_cast<uint32_t> (icmpType) << static_cast<uint32_t> (icmpCode) << icmpInfo);
-
+  
   if (!m_icmpCallback.IsNull ())
     {
       m_icmpCallback (icmpSource,icmpTtl,icmpType,icmpCode,icmpInfo);
diff --git a/src/internet/model/ipv4-end-point.h b/src/internet/model/ipv4-end-point.h
index 16f6a34..c8dea7a 100644
--- a/src/internet/model/ipv4-end-point.h
+++ b/src/internet/model/ipv4-end-point.h
@@ -36,7 +36,7 @@ class Packet;
 /**
  * \brief A representation of an internet endpoint/connection
  *
- * This class provides an internet four-tuple (source and destination ports
+ * This class provides an internet four-tuple (source and destination ports 
  * and addresses).  These are used in the ns3::Ipv4EndPointDemux as targets
  * of lookups.  The class also has a callback for notification to higher
  * layers that a packet from a lower layer was received.  In the ns3
@@ -58,7 +58,7 @@ public:
    * \brief Get the local address.
    * \return the local address
    */
-  Ipv4Address GetLocalAddress (void) const;
+  Ipv4Address GetLocalAddress (void);
 
   /**
    * \brief Set the local address.
@@ -70,19 +70,19 @@ public:
    * \brief Get the local port.
    * \return the local port
    */
-  uint16_t GetLocalPort (void) const;
+  uint16_t GetLocalPort (void);
 
   /**
    * \brief Get the peer address.
    * \return the peer address
    */
-  Ipv4Address GetPeerAddress (void) const;
+  Ipv4Address GetPeerAddress (void);
 
   /**
    * \brief Get the peer port.
    * \return the peer port
    */
-  uint16_t GetPeerPort (void) const;
+  uint16_t GetPeerPort (void);
 
   /**
    * \brief Set the peer informations (address and port).
@@ -149,7 +149,7 @@ public:
    * \param sport source port
    * \param incomingInterface incoming interface
    */
-  void ForwardUp (Ptr<Packet> p, const Ipv4Header& header, uint16_t sport,
+  void ForwardUp (Ptr<Packet> p, const Ipv4Header& header, uint16_t sport, 
                   Ptr<Ipv4Interface> incomingInterface);
 
   /**
@@ -164,12 +164,10 @@ public:
    * \param icmpCode ICMP code
    * \param icmpInfo ICMP info
    */
-  void ForwardIcmp (Ipv4Address icmpSource, uint8_t icmpTtl,
+  void ForwardIcmp (Ipv4Address icmpSource, uint8_t icmpTtl, 
                     uint8_t icmpType, uint8_t icmpCode,
                     uint32_t icmpInfo);
 
-  void Print (std::ostream &os) const;
-
 private:
   /**
    * \brief ForwardUp wrapper.
diff --git a/src/internet/model/ipv4-interface.cc b/src/internet/model/ipv4-interface.cc
index 3d72a78..0d99bf4 100644
--- a/src/internet/model/ipv4-interface.cc
+++ b/src/internet/model/ipv4-interface.cc
@@ -315,8 +315,7 @@ Ipv4Interface::GetAddress (uint32_t index) const
           ++tmp;
         }
     }
-//  NS_ASSERT (false);  // Assert if not found
-  NS_FATAL_ERROR ("address " << index << " not found");
+  NS_ASSERT (false);  // Assert if not found
   Ipv4InterfaceAddress addr;
   return (addr);  // quiet compiler
 }
@@ -342,7 +341,7 @@ Ipv4Interface::RemoveAddress (uint32_t index)
       ++tmp;
       ++i;
     }
-  NS_FATAL_ERROR ("Address " << index << " not found");
+  NS_ASSERT_MSG (false, "Address " << index << " not found");
   Ipv4InterfaceAddress addr;
   return (addr);  // quiet compiler
 }
diff --git a/src/internet/model/ipv4-static-routing.cc b/src/internet/model/ipv4-static-routing.cc
index 6c6cdb9..76d0fb7 100644
--- a/src/internet/model/ipv4-static-routing.cc
+++ b/src/internet/model/ipv4-static-routing.cc
@@ -53,16 +53,16 @@ Ipv4StaticRouting::GetTypeId (void)
   return tid;
 }
 
-Ipv4StaticRouting::Ipv4StaticRouting ()
+Ipv4StaticRouting::Ipv4StaticRouting () 
   : m_ipv4 (0)
 {
   NS_LOG_FUNCTION (this);
 }
 
-void
-Ipv4StaticRouting::AddNetworkRouteTo (Ipv4Address network,
-                                      Ipv4Mask networkMask,
-                                      Ipv4Address nextHop,
+void 
+Ipv4StaticRouting::AddNetworkRouteTo (Ipv4Address network, 
+                                      Ipv4Mask networkMask, 
+                                      Ipv4Address nextHop, 
                                       uint32_t interface,
                                       uint32_t metric)
 {
@@ -75,9 +75,9 @@ Ipv4StaticRouting::AddNetworkRouteTo (Ipv4Address network,
   m_networkRoutes.push_back (make_pair (route,metric));
 }
 
-void
-Ipv4StaticRouting::AddNetworkRouteTo (Ipv4Address network,
-                                      Ipv4Mask networkMask,
+void 
+Ipv4StaticRouting::AddNetworkRouteTo (Ipv4Address network, 
+                                      Ipv4Mask networkMask, 
                                       uint32_t interface,
                                       uint32_t metric)
 {
@@ -89,8 +89,8 @@ Ipv4StaticRouting::AddNetworkRouteTo (Ipv4Address network,
   m_networkRoutes.push_back (make_pair (route,metric));
 }
 
-void
-Ipv4StaticRouting::AddHostRouteTo (Ipv4Address dest,
+void 
+Ipv4StaticRouting::AddHostRouteTo (Ipv4Address dest, 
                                    Ipv4Address nextHop,
                                    uint32_t interface,
                                    uint32_t metric)
@@ -99,8 +99,8 @@ Ipv4StaticRouting::AddHostRouteTo (Ipv4Address dest,
   AddNetworkRouteTo (dest, Ipv4Mask::GetOnes (), nextHop, interface, metric);
 }
 
-void
-Ipv4StaticRouting::AddHostRouteTo (Ipv4Address dest,
+void 
+Ipv4StaticRouting::AddHostRouteTo (Ipv4Address dest, 
                                    uint32_t interface,
                                    uint32_t metric)
 {
@@ -108,16 +108,16 @@ Ipv4StaticRouting::AddHostRouteTo (Ipv4Address dest,
   AddNetworkRouteTo (dest, Ipv4Mask::GetOnes (), interface, metric);
 }
 
-void
-Ipv4StaticRouting::SetDefaultRoute (Ipv4Address nextHop,
+void 
+Ipv4StaticRouting::SetDefaultRoute (Ipv4Address nextHop, 
                                     uint32_t interface,
                                     uint32_t metric)
 {
-  NS_LOG_FUNCTION (this << "nextHop=" << nextHop << " if=" << interface << " metric=" << metric);
+  NS_LOG_FUNCTION (this << nextHop << " " << interface << " " << metric);
   AddNetworkRouteTo (Ipv4Address ("0.0.0.0"), Ipv4Mask::GetZero (), nextHop, interface, metric);
 }
 
-void
+void 
 Ipv4StaticRouting::AddMulticastRoute (Ipv4Address origin,
                                       Ipv4Address group,
                                       uint32_t inputInterface,
@@ -125,7 +125,7 @@ Ipv4StaticRouting::AddMulticastRoute (Ipv4Address origin,
 {
   NS_LOG_FUNCTION (this << origin << " " << group << " " << inputInterface << " " << &outputInterfaces);
   Ipv4MulticastRoutingTableEntry *route = new Ipv4MulticastRoutingTableEntry ();
-  *route = Ipv4MulticastRoutingTableEntry::CreateMulticastRoute (origin, group,
+  *route = Ipv4MulticastRoutingTableEntry::CreateMulticastRoute (origin, group, 
                                                                  inputInterface, outputInterfaces);
   m_multicastRoutes.push_back (route);
 }
@@ -133,7 +133,7 @@ Ipv4StaticRouting::AddMulticastRoute (Ipv4Address origin,
 // default multicast routes are stored as a network route
 // these routes are _not_ consulted in the forwarding process-- only
 // for originating packets
-void
+void 
 Ipv4StaticRouting::SetDefaultMulticastRoute (uint32_t outputInterface)
 {
   NS_LOG_FUNCTION (this << outputInterface);
@@ -146,7 +146,7 @@ Ipv4StaticRouting::SetDefaultMulticastRoute (uint32_t outputInterface)
   m_networkRoutes.push_back (make_pair (route,0));
 }
 
-uint32_t
+uint32_t 
 Ipv4StaticRouting::GetNMulticastRoutes (void) const
 {
   NS_LOG_FUNCTION (this);
@@ -163,9 +163,9 @@ Ipv4StaticRouting::GetMulticastRoute (uint32_t index) const
   if (index < m_multicastRoutes.size ())
     {
       uint32_t tmp = 0;
-      for (MulticastRoutesCI i = m_multicastRoutes.begin ();
-           i != m_multicastRoutes.end ();
-           i++)
+      for (MulticastRoutesCI i = m_multicastRoutes.begin (); 
+           i != m_multicastRoutes.end (); 
+           i++) 
         {
           if (tmp  == index)
             {
@@ -183,9 +183,9 @@ Ipv4StaticRouting::RemoveMulticastRoute (Ipv4Address origin,
                                          uint32_t inputInterface)
 {
   NS_LOG_FUNCTION (this << origin << " " << group << " " << inputInterface);
-  for (MulticastRoutesI i = m_multicastRoutes.begin ();
-       i != m_multicastRoutes.end ();
-       i++)
+  for (MulticastRoutesI i = m_multicastRoutes.begin (); 
+       i != m_multicastRoutes.end (); 
+       i++) 
     {
       Ipv4MulticastRoutingTableEntry *route = *i;
       if (origin == route->GetOrigin () &&
@@ -200,14 +200,14 @@ Ipv4StaticRouting::RemoveMulticastRoute (Ipv4Address origin,
   return false;
 }
 
-void
+void 
 Ipv4StaticRouting::RemoveMulticastRoute (uint32_t index)
 {
   NS_LOG_FUNCTION (this << index);
   uint32_t tmp = 0;
-  for (MulticastRoutesI i = m_multicastRoutes.begin ();
-       i != m_multicastRoutes.end ();
-       i++)
+  for (MulticastRoutesI i = m_multicastRoutes.begin (); 
+       i != m_multicastRoutes.end (); 
+       i++) 
     {
       if (tmp  == index)
         {
@@ -222,7 +222,7 @@ Ipv4StaticRouting::RemoveMulticastRoute (uint32_t index)
 Ptr<Ipv4Route>
 Ipv4StaticRouting::LookupStatic (Ipv4Address dest, Ptr<NetDevice> oif)
 {
-  NS_LOG_FUNCTION (this << dest << " request interface=" << oif);
+  NS_LOG_FUNCTION (this << dest << " " << oif);
   Ptr<Ipv4Route> rtentry = 0;
   uint16_t longest_mask = 0;
   uint32_t shortest_metric = 0xffffffff;
@@ -240,20 +240,17 @@ Ipv4StaticRouting::LookupStatic (Ipv4Address dest, Ptr<NetDevice> oif)
     }
 
 
-  for (NetworkRoutesI i = m_networkRoutes.begin ();
-       i != m_networkRoutes.end ();
-       i++)
+  for (NetworkRoutesI i = m_networkRoutes.begin (); 
+       i != m_networkRoutes.end (); 
+       i++) 
     {
       Ipv4RoutingTableEntry *j=i->first;
       uint32_t metric =i->second;
       Ipv4Mask mask = (j)->GetDestNetworkMask ();
       uint16_t masklen = mask.GetPrefixLength ();
       Ipv4Address entry = (j)->GetDestNetwork ();
-      NS_LOG_LOGIC ("Searching for route to " << dest << ", checking against route to "
-                    << entry << "/" << masklen
-                    << " on interface " << j->GetInterface()
-                    );
-      if (mask.IsMatch (dest, entry))
+      NS_LOG_LOGIC ("Searching for route to " << dest << ", checking against route to " << entry << "/" << masklen);
+      if (mask.IsMatch (dest, entry)) 
         {
           NS_LOG_LOGIC ("Found global network route " << j << ", mask length " << masklen << ", metric " << metric);
           if (oif != 0)
@@ -288,15 +285,10 @@ Ipv4StaticRouting::LookupStatic (Ipv4Address dest, Ptr<NetDevice> oif)
           rtentry->SetGateway (route->GetGateway ());
           rtentry->SetOutputDevice (m_ipv4->GetNetDevice (interfaceIdx));
         }
-        else {
-            NS_LOG_LOGIC ("Not a match");
-        }
     }
-
   if (rtentry != 0)
     {
-      NS_LOG_LOGIC ("Matching route via gateway " << rtentry->GetGateway () << " at the end");
-//      PrintRoutingTable(std::cout);
+      NS_LOG_LOGIC ("Matching route via " << rtentry->GetGateway () << " at the end");
     }
   else
     {
@@ -307,20 +299,20 @@ Ipv4StaticRouting::LookupStatic (Ipv4Address dest, Ptr<NetDevice> oif)
 
 Ptr<Ipv4MulticastRoute>
 Ipv4StaticRouting::LookupStatic (
-  Ipv4Address origin,
+  Ipv4Address origin, 
   Ipv4Address group,
   uint32_t    interface)
 {
   NS_LOG_FUNCTION (this << origin << " " << group << " " << interface);
   Ptr<Ipv4MulticastRoute> mrtentry = 0;
 
-  for (MulticastRoutesI i = m_multicastRoutes.begin ();
-       i != m_multicastRoutes.end ();
-       i++)
+  for (MulticastRoutesI i = m_multicastRoutes.begin (); 
+       i != m_multicastRoutes.end (); 
+       i++) 
     {
       Ipv4MulticastRoutingTableEntry *route = *i;
 //
-// We've been passed an origin address, a multicast group address and an
+// We've been passed an origin address, a multicast group address and an 
 // interface index.  We have to decide if the current route in the list is
 // a match.
 //
@@ -334,7 +326,7 @@ Ipv4StaticRouting::LookupStatic (
         }
       if (group == route->GetGroup ())
         {
-          if (interface == Ipv4::IF_ANY ||
+          if (interface == Ipv4::IF_ANY || 
               interface == route->GetInputInterface ())
             {
               NS_LOG_LOGIC ("Found multicast route" << *i);
@@ -357,7 +349,7 @@ Ipv4StaticRouting::LookupStatic (
   return mrtentry;
 }
 
-uint32_t
+uint32_t 
 Ipv4StaticRouting::GetNRoutes (void) const
 {
   NS_LOG_FUNCTION (this);
@@ -372,9 +364,9 @@ Ipv4StaticRouting::GetDefaultRoute ()
   Ipv4Address dest ("0.0.0.0");
   uint32_t shortest_metric = 0xffffffff;
   Ipv4RoutingTableEntry *result = 0;
-  for (NetworkRoutesI i = m_networkRoutes.begin ();
-       i != m_networkRoutes.end ();
-       i++)
+  for (NetworkRoutesI i = m_networkRoutes.begin (); 
+       i != m_networkRoutes.end (); 
+       i++) 
     {
       Ipv4RoutingTableEntry *j = i->first;
       uint32_t metric = i->second;
@@ -401,14 +393,14 @@ Ipv4StaticRouting::GetDefaultRoute ()
     }
 }
 
-Ipv4RoutingTableEntry
+Ipv4RoutingTableEntry 
 Ipv4StaticRouting::GetRoute (uint32_t index) const
 {
   NS_LOG_FUNCTION (this << index);
   uint32_t tmp = 0;
-  for (NetworkRoutesCI j = m_networkRoutes.begin ();
-       j != m_networkRoutes.end ();
-       j++)
+  for (NetworkRoutesCI j = m_networkRoutes.begin (); 
+       j != m_networkRoutes.end (); 
+       j++) 
     {
       if (tmp  == index)
         {
@@ -427,8 +419,8 @@ Ipv4StaticRouting::GetMetric (uint32_t index) const
   NS_LOG_FUNCTION (this << index);
   uint32_t tmp = 0;
   for (NetworkRoutesCI j = m_networkRoutes.begin ();
-       j != m_networkRoutes.end ();
-       j++)
+       j != m_networkRoutes.end (); 
+       j++) 
     {
       if (tmp == index)
         {
@@ -440,14 +432,14 @@ Ipv4StaticRouting::GetMetric (uint32_t index) const
   // quiet compiler.
   return 0;
 }
-void
+void 
 Ipv4StaticRouting::RemoveRoute (uint32_t index)
 {
   NS_LOG_FUNCTION (this << index);
   uint32_t tmp = 0;
-  for (NetworkRoutesI j = m_networkRoutes.begin ();
-       j != m_networkRoutes.end ();
-       j++)
+  for (NetworkRoutesI j = m_networkRoutes.begin (); 
+       j != m_networkRoutes.end (); 
+       j++) 
     {
       if (tmp == index)
         {
@@ -460,7 +452,7 @@ Ipv4StaticRouting::RemoveRoute (uint32_t index)
   NS_ASSERT (false);
 }
 
-Ptr<Ipv4Route>
+Ptr<Ipv4Route> 
 Ipv4StaticRouting::RouteOutput (Ptr<Packet> p, const Ipv4Header &header, Ptr<NetDevice> oif, Socket::SocketErrno &sockerr)
 {
   NS_LOG_FUNCTION (this << p<< header << oif << sockerr);
@@ -473,24 +465,24 @@ Ipv4StaticRouting::RouteOutput (Ptr<Packet> p, const Ipv4Header &header, Ptr<Net
       // Note:  Multicast routes for outbound packets are stored in the
       // normal unicast table.  An implication of this is that it is not
       // possible to source multicast datagrams on multiple interfaces.
-      // This is a well-known property of sockets implementation on
+      // This is a well-known property of sockets implementation on 
       // many Unix variants.
       // So, we just log it and fall through to LookupStatic ()
       NS_LOG_LOGIC ("RouteOutput()::Multicast destination");
     }
   rtentry = LookupStatic (destination, oif);
   if (rtentry)
-    {
+    { 
       sockerr = Socket::ERROR_NOTERROR;
     }
   else
-    {
+    { 
       sockerr = Socket::ERROR_NOROUTETOHOST;
     }
   return rtentry;
 }
 
-bool
+bool 
 Ipv4StaticRouting::RouteInput  (Ptr<const Packet> p, const Ipv4Header &ipHeader, Ptr<const NetDevice> idev,
                                 UnicastForwardCallback ucb, MulticastForwardCallback mcb,
                                 LocalDeliverCallback lcb, ErrorCallback ecb)
@@ -498,9 +490,9 @@ Ipv4StaticRouting::RouteInput  (Ptr<const Packet> p, const Ipv4Header &ipHeader,
   NS_LOG_FUNCTION (this << p << ipHeader << ipHeader.GetSource () << ipHeader.GetDestination () << idev << &ucb << &mcb << &lcb << &ecb);
 
   NS_ASSERT (m_ipv4 != 0);
-  // Check if input device supports IP
+  // Check if input device supports IP 
   NS_ASSERT (m_ipv4->GetInterfaceForDevice (idev) >= 0);
-  uint32_t iif = m_ipv4->GetInterfaceForDevice (idev);
+  uint32_t iif = m_ipv4->GetInterfaceForDevice (idev); 
 
   // Multicast recognition; handle local delivery here
   //
@@ -595,15 +587,15 @@ void
 Ipv4StaticRouting::DoDispose (void)
 {
   NS_LOG_FUNCTION (this);
-  for (NetworkRoutesI j = m_networkRoutes.begin ();
-       j != m_networkRoutes.end ();
-       j = m_networkRoutes.erase (j))
+  for (NetworkRoutesI j = m_networkRoutes.begin (); 
+       j != m_networkRoutes.end (); 
+       j = m_networkRoutes.erase (j)) 
     {
       delete (j->first);
     }
-  for (MulticastRoutesI i = m_multicastRoutes.begin ();
-       i != m_multicastRoutes.end ();
-       i = m_multicastRoutes.erase (i))
+  for (MulticastRoutesI i = m_multicastRoutes.begin (); 
+       i != m_multicastRoutes.end (); 
+       i = m_multicastRoutes.erase (i)) 
     {
       delete (*i);
     }
@@ -611,7 +603,7 @@ Ipv4StaticRouting::DoDispose (void)
   Ipv4RoutingProtocol::DoDispose ();
 }
 
-void
+void 
 Ipv4StaticRouting::NotifyInterfaceUp (uint32_t i)
 {
   NS_LOG_FUNCTION (this << i);
@@ -630,7 +622,7 @@ Ipv4StaticRouting::NotifyInterfaceUp (uint32_t i)
     }
 }
 
-void
+void 
 Ipv4StaticRouting::NotifyInterfaceDown (uint32_t i)
 {
   NS_LOG_FUNCTION (this << i);
@@ -649,7 +641,7 @@ Ipv4StaticRouting::NotifyInterfaceDown (uint32_t i)
     }
 }
 
-void
+void 
 Ipv4StaticRouting::NotifyAddAddress (uint32_t interface, Ipv4InterfaceAddress address)
 {
   NS_LOG_FUNCTION (this << interface << " " << address.GetLocal ());
@@ -667,7 +659,7 @@ Ipv4StaticRouting::NotifyAddAddress (uint32_t interface, Ipv4InterfaceAddress ad
                          networkMask, interface);
     }
 }
-void
+void 
 Ipv4StaticRouting::NotifyRemoveAddress (uint32_t interface, Ipv4InterfaceAddress address)
 {
   NS_LOG_FUNCTION (this << interface << " " << address.GetLocal ());
@@ -696,7 +688,7 @@ Ipv4StaticRouting::NotifyRemoveAddress (uint32_t interface, Ipv4InterfaceAddress
     }
 }
 
-void
+void 
 Ipv4StaticRouting::SetIpv4 (Ptr<Ipv4> ipv4)
 {
   NS_LOG_FUNCTION (this << ipv4);
@@ -778,7 +770,7 @@ Ipv4StaticRouting::SourceAddressSelection (uint32_t interfaceIdx, Ipv4Address de
       Ipv4InterfaceAddress test = m_ipv4->GetAddress (interfaceIdx, i);
       if (test.GetLocal ().CombineMask (test.GetMask ()) == dest.CombineMask (test.GetMask ()))
         {
-          if (test.IsSecondary () == false)
+          if (test.IsSecondary () == false) 
             {
               return test.GetLocal ();
             }
diff --git a/src/internet/model/ipv4-static-routing.h b/src/internet/model/ipv4-static-routing.h
index db7b04c..7f75544 100644
--- a/src/internet/model/ipv4-static-routing.h
+++ b/src/internet/model/ipv4-static-routing.h
@@ -49,17 +49,17 @@ class Node;
  */
 /**
  * \ingroup ipv4StaticRouting
- *
+ * 
  * \brief Static routing protocol for IP version 4 stacks.
  *
  * This class provides a basic set of methods for inserting static
  * unicast and multicast routes into the Ipv4 routing system.
- * This particular protocol is designed to be inserted into an
+ * This particular protocol is designed to be inserted into an 
  * Ipv4ListRouting protocol but can be used also as a standalone
  * protocol.
- *
- * The Ipv4StaticRouting class inherits from the abstract base class
- * Ipv4RoutingProtocol that defines the interface methods that a routing
+ * 
+ * The Ipv4StaticRouting class inherits from the abstract base class 
+ * Ipv4RoutingProtocol that defines the interface methods that a routing 
  * protocol must support.
  *
  * \see Ipv4RoutingProtocol
@@ -103,9 +103,9 @@ public:
  *
  * \see Ipv4Address
  */
-  virtual void AddNetworkRouteTo (Ipv4Address network,
-                          Ipv4Mask networkMask,
-                          Ipv4Address nextHop,
+  void AddNetworkRouteTo (Ipv4Address network, 
+                          Ipv4Mask networkMask, 
+                          Ipv4Address nextHop, 
                           uint32_t interface,
                           uint32_t metric = 0);
 
@@ -120,8 +120,8 @@ public:
  *
  * \see Ipv4Address
  */
-  virtual void AddNetworkRouteTo (Ipv4Address network,
-                          Ipv4Mask networkMask,
+  void AddNetworkRouteTo (Ipv4Address network, 
+                          Ipv4Mask networkMask, 
                           uint32_t interface,
                           uint32_t metric = 0);
 
@@ -136,8 +136,8 @@ public:
  *
  * \see Ipv4Address
  */
-  void AddHostRouteTo (Ipv4Address dest,
-                       Ipv4Address nextHop,
+  void AddHostRouteTo (Ipv4Address dest, 
+                       Ipv4Address nextHop, 
                        uint32_t interface,
                        uint32_t metric = 0);
 /**
@@ -150,7 +150,7 @@ public:
  *
  * \see Ipv4Address
  */
-  void AddHostRouteTo (Ipv4Address dest,
+  void AddHostRouteTo (Ipv4Address dest, 
                        uint32_t interface,
                        uint32_t metric = 0);
 /**
@@ -159,8 +159,8 @@ public:
  * This method tells the routing system what to do in the case where a specific
  * route to a destination is not found.  The system forwards packets to the
  * specified node in the hope that it knows better how to route the packet.
- *
- * If the default route is set, it is returned as the selected route from
+ * 
+ * If the default route is set, it is returned as the selected route from 
  * LookupStatic irrespective of destination address if no specific route is
  * found.
  *
@@ -172,7 +172,7 @@ public:
  * \see Ipv4Address
  * \see Ipv4StaticRouting::Lookup
  */
-  virtual void SetDefaultRoute (Ipv4Address nextHop,
+  void SetDefaultRoute (Ipv4Address nextHop, 
                         uint32_t interface,
                         uint32_t metric = 0);
 
@@ -189,7 +189,7 @@ public:
  * \brief Get the default route with lowest metric from the static routing table.
  *
  * \return If the default route is set, a pointer to that Ipv4RoutingTableEntry is
- * returned, otherwise an empty routing table entry is returned.
+ * returned, otherwise an empty routing table entry is returned. 
 *  If multiple default routes exist, the one with lowest metric is returned.
  *
  * \see Ipv4RoutingTableEntry
@@ -242,7 +242,7 @@ public:
  * output network interface indices over which packets matching the conditions
  * are sent.
  *
- * Typically there are two main types of multicast routes:  routes of the
+ * Typically there are two main types of multicast routes:  routes of the 
  * first kind are used during forwarding.  All of the conditions must be
  * explicitly provided.  The second kind of routes are used to get packets off
  * of a local node.  The difference is in the input interface.  Routes for
@@ -251,25 +251,25 @@ public:
  * by the index Ipv4RoutingProtocol::INTERFACE_ANY.
  *
  * For routes off of a local node wildcards may be used in the origin and
- * multicast group addresses.  The wildcard used for Ipv4Adresses is that
+ * multicast group addresses.  The wildcard used for Ipv4Adresses is that 
  * address returned by Ipv4Address::GetAny () -- typically "0.0.0.0".  Usage
  * of a wildcard allows one to specify default behavior to varying degrees.
  *
- * For example, making the origin address a wildcard, but leaving the
+ * For example, making the origin address a wildcard, but leaving the 
  * multicast group specific allows one (in the case of a node with multiple
  * interfaces) to create different routes using different output interfaces
  * for each multicast group.
  *
  * If the origin and multicast addresses are made wildcards, you have created
- * essentially a default multicast address that can forward to multiple
+ * essentially a default multicast address that can forward to multiple 
  * interfaces.  Compare this to the actual default multicast address that is
  * limited to specifying a single output interface for compatibility with
  * existing functionality in other systems.
- *
+ * 
  * \param origin The Ipv4Address of the origin of packets for this route.  May
  * be Ipv4Address:GetAny for open groups.
  * \param group The Ipv4Address of the multicast group or this route.
- * \param inputInterface The input network interface index over which to
+ * \param inputInterface The input network interface index over which to 
  * expect packets destined for this route.  May be
  * Ipv4RoutingProtocol::INTERFACE_ANY for packets of local origin.
  * \param outputInterfaces A vector of network interface indices used to specify
@@ -287,9 +287,9 @@ public:
  *
  * This is the multicast equivalent of the unicast version SetDefaultRoute.
  * We tell the routing system what to do in the case where a specific route
- * to a destination multicast group is not found.  The system forwards
+ * to a destination multicast group is not found.  The system forwards 
  * packets out the specified interface in the hope that "something out there"
- * knows better how to route the packet.  This method is only used in
+ * knows better how to route the packet.  This method is only used in 
  * initially sending packets off of a host.  The default multicast route is
  * not consulted during forwarding -- exact routes must be specified using
  * AddMulticastRoute for that case.
@@ -297,7 +297,7 @@ public:
  * Since we're basically sending packets to some entity we think may know
  * better what to do, we don't pay attention to "subtleties" like origin
  * address, nor do we worry about forwarding out multiple  interfaces.  If the
- * default multicast route is set, it is returned as the selected route from
+ * default multicast route is set, it is returned as the selected route from 
  * LookupStatic irrespective of origin or multicast group if another specific
  * route is not found.
  *
@@ -320,9 +320,9 @@ public:
 /**
  * \brief Get a route from the static multicast routing table.
  *
- * Externally, the multicast static routing table appears simply as a table
+ * Externally, the multicast static routing table appears simply as a table 
  * with n entries.
- *
+ * 
  * \param i The index (into the routing table) of the multicast route to
  * retrieve.
  * \return If route \e i is set, a pointer to that Ipv4MulticastRoutingTableEntry is
@@ -336,7 +336,7 @@ public:
 /**
  * \brief Remove a route from the static multicast routing table.
  *
- * Externally, the multicast static routing table appears simply as a table
+ * Externally, the multicast static routing table appears simply as a table 
  * with n entries.
  * This method causes the multicast routing table to be searched for the first
  * route that matches the parameters and removes it.
@@ -365,7 +365,7 @@ public:
 /**
  * \brief Remove a route from the static multicast routing table.
  *
- * Externally, the multicast static routing table appears simply as a table
+ * Externally, the multicast static routing table appears simply as a table 
  * with n entries.
  *
  * \param index The index (into the multicast routing table) of the route to
diff --git a/src/internet/model/ipv4.h b/src/internet/model/ipv4.h
index acdcb59..e45ad12 100644
--- a/src/internet/model/ipv4.h
+++ b/src/internet/model/ipv4.h
@@ -183,7 +183,7 @@ public:
    * is acceptable), or if address corresponds to a broadcast address.
    *
    * If the Ipv4 attribute WeakEsModel is true, the unicast address may
-   * match any of the Ipv4 addresses on any interfpace.  If the attribute is
+   * match any of the Ipv4 addresses on any interface.  If the attribute is
    * false, the address must match one assigned to the incoming device.
    */
   virtual bool IsDestinationAddress (Ipv4Address address, uint32_t iif) const = 0;
diff --git a/src/internet/model/mptcp-cc-lia.cc b/src/internet/model/mptcp-cc-lia.cc
deleted file mode 100644
index 09cefa9..0000000
--- a/src/internet/model/mptcp-cc-lia.cc
+++ /dev/null
@@ -1,167 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-
-#include "ns3/log.h"
-#include "ns3/mptcp-cc-lia.h"
-#include "ns3/mptcp-subflow.h"
-#include "ns3/mptcp-socket-base.h"
-
-NS_LOG_COMPONENT_DEFINE ("MpTcpCongestionLia");
-
-namespace ns3
-{
-
-NS_OBJECT_ENSURE_REGISTERED (MpTcpCongestionLia);
-
-TypeId
-MpTcpCongestionLia::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::MpTcpCongestionLia")
-//    .SetParent<TcpCongestionOps> ()
-    .SetParent<TcpNewReno> ()
-    .SetGroupName ("Internet")
-    .AddConstructor<MpTcpCongestionLia> ()
-//    .AddTraceSource ("Alpha",
-//                     "Value of the alp",
-//                     MakeTraceSourceAccessor (&MpTcpCongestionLia::m_alpha),
-//                     "ns3::WTH_IS_ZIS_TracedValueCallback"
-//                     )
-      ;
-  ;
-  return tid;
-}
-
-TypeId 
-MpTcpCongestionLia::GetInstanceTypeId (void)
-{
-  return GetTypeId ();
-}
-
-
-// TODO we should aggregate CC for the mptcp case ?
-MpTcpCongestionLia::MpTcpCongestionLia() : 
-//  TcpCongestionOps (),
-  TcpNewReno(),
-  m_alpha (1)
-//  , m_totalCwnd (0)
-{
-  NS_LOG_FUNCTION_NOARGS();
-}
-
-MpTcpCongestionLia::~MpTcpCongestionLia ()
-{
-  NS_LOG_FUNCTION_NOARGS();
-}
-
-
-std::string
-MpTcpCongestionLia::GetName () const
-{
-  return "MpTcpLia";
-}
-
-
-double
-MpTcpCongestionLia::ComputeAlpha (Ptr<MpTcpSocketBase> metaSock, Ptr<TcpSocketState> tcb) const
-{
-  // this method is called whenever a congestion happen in order to regulate the agressivety of m_subflows
-  // m_alpha = cwnd_total * MAX(cwnd_i / rtt_i^2) / {SUM(cwnd_i / rtt_i))^2}   //RFC 6356 formula (2)
-  
-  NS_LOG_FUNCTION(this);
-  
-  double alpha = 0;
-  double maxi = 0; // Matches the MAX(cwnd_i / rtt_i^2) part
-  double sumi = 0; // SUM(cwnd_i / rtt_i)
-
-  
-  NS_ASSERT (metaSock);
-  // TODO here
-  for (uint32_t i = 0; i < metaSock->GetNActiveSubflows(); i++)
-    {
-      Ptr<MpTcpSubflow> sFlow = metaSock->GetSubflow(i);
-
-      Time time = sFlow->GetRttEstimator()->GetEstimate();
-      double rtt = time.GetSeconds();
-      double tmpi = tcb->m_cWnd.Get() / (rtt * rtt);
-      
-      if (maxi < tmpi)
-        maxi = tmpi;
-
-      sumi += tcb->m_cWnd.Get() / rtt;
-    }
-  alpha = (metaSock->m_tcb->m_cWnd.Get () * maxi) / (sumi * sumi);
-  return alpha;
-}
-
-
-// TODO in this version, this function is called for each segment size
-// in future versions (>3.25), one can 
-void
-MpTcpCongestionLia::IncreaseWindow (Ptr<TcpSocketBase> sf, Ptr<TcpSocketState> tcb)
-{
-  NS_LOG_FUNCTION (this);
-
-  // Increase of cwnd based on current phase (slow start or congestion avoidance)
-  if (tcb->m_cWnd < tcb->m_ssThresh)
-    {
-      tcb->m_cWnd += tcb->m_segmentSize;
-      NS_LOG_INFO ("In SlowStart, updated tcb " << tcb << " cwnd to " << tcb->m_cWnd << " ssthresh " << tcb->m_ssThresh);
-    }
-  else
-    { 
-      
-      Ptr<MpTcpSubflow> subflow = DynamicCast<MpTcpSubflow> (sf);
-      Ptr<MpTcpSocketBase> metaSock = subflow->GetMeta();
-      
-      // rename into get ?
-      uint32_t totalCwnd = metaSock->ComputeTotalCWND ();
-//      metaSock->
-  
-      m_alpha = ComputeAlpha (metaSock, tcb);
-      double alpha_scale = 1;
-//         The alpha_scale parameter denotes the precision we want for computing
-//   alpha
-//                alpha * bytes_acked * MSS_i   bytes_acked * MSS_i
-//          min ( --------------------------- , ------------------- )  (3)
-//                 alpha_scale * cwnd_total              cwnd_i
-    
-    double adder = std::min ( 
-      m_alpha* tcb->m_segmentSize * tcb->m_segmentSize / (totalCwnd* alpha_scale),
-        static_cast<double>((tcb->m_segmentSize * tcb->m_segmentSize) / tcb->m_cWnd.Get ())
-      );
-    // Congestion avoidance mode, increase by (segSize*segSize)/cwnd. (RFC2581, sec.3.1)
-      // To increase cwnd for one segSize per RTT, it should be (ackBytes*segSize)/cwnd
-//      double adder = static_cast<double> (tcb->m_segmentSize * tcb->m_segmentSize) / tcb->m_cWnd.Get ();
-//      adder = std::max (1.0, adder);
-      tcb->m_cWnd += static_cast<uint32_t> (adder);
-      NS_LOG_INFO ("In CongAvoid, updated tcb " << tcb << " cwnd to " << tcb->m_cWnd << " ssthresh " << tcb->m_ssThresh);
-    }
-}
-
-Ptr<TcpCongestionOps> 
-MpTcpCongestionLia::Fork ()
-{
-  return CreateObject<MpTcpCongestionLia>();
-}
-
-
-}
diff --git a/src/internet/model/mptcp-cc-lia.h b/src/internet/model/mptcp-cc-lia.h
deleted file mode 100644
index 3e3fbcf..0000000
--- a/src/internet/model/mptcp-cc-lia.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#ifndef MPTCP_CC_LIA_H
-#define MPTCP_CC_LIA_H
-
-
-#include <stdint.h>
-#include "ns3/object.h"
-#include "tcp-congestion-ops.h"
-//#include "ns3/mptcp-mapping.h"
-
-
-namespace ns3
-{
-
-class MpTcpSocketBase;
-
-/**
-\brief Defined in RFC 6356 (http://tools.ietf.org/html/rfc6356)
- TODO inherit from reno rather ?
- 
- TODO rename to LIA (Linked Increase Algorithm)
-*/
-class MpTcpCongestionLia : 
-//  public TcpCongestionOps
-  public TcpNewReno
-{
-public:
-  /**
-   * \brief Get the type ID.
-   * \return the object TypeId
-   */
-  static TypeId GetTypeId (void);
-  virtual TypeId GetInstanceTypeId (void);
-
-  MpTcpCongestionLia ();
-  MpTcpCongestionLia (const MpTcpCongestionLia& sock);
-
-  ~MpTcpCongestionLia ();
-
-  virtual std::string GetName () const;
-
-  /**
-   *
-   Note that the calculation of alpha does not take into account path
-   MSS and is the same for stacks that keep cwnd in bytes or packets.
-   */
-  virtual void IncreaseWindow (Ptr<TcpSocketBase> sf, Ptr<TcpSocketState> tcb);
-//  virtual uint32_t GetSsThresh (Ptr<const TcpSocketState> tcb);
-
-  virtual Ptr<TcpCongestionOps> Fork ();
-
-protected:
-
-  /**
-   * TODO should update m_totalCwnd as well ?
-   // TODO just return alpha and put const everywhere
-   * assume metaSock->totalCwnd is already computed
-   */
-  double ComputeAlpha (Ptr<MpTcpSocketBase> metaSock, Ptr<TcpSocketState> tcb) const;
-
-  double m_alpha;
-//  uint32_t m_totalCwnd;
-
-
-};
-
-
-}
-
-
-#endif /* MPTCP_CC_H */
diff --git a/src/internet/model/mptcp-cc-olia.cc b/src/internet/model/mptcp-cc-olia.cc
deleted file mode 100644
index 688ad02..0000000
--- a/src/internet/model/mptcp-cc-olia.cc
+++ /dev/null
@@ -1,125 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-#include "ns3/mptcp-olia.h"
-#include "ns3/log.h"
-#include "ns3/object.h"
-
-NS_LOG_COMPONENT_DEFINE("MpTcpCCOlia");
-
-
-namespace ns3 {
-
-
-
-NS_OBJECT_ENSURE_REGISTERED (MpTcpCCOlia);
-
-TypeId
-MpTcpCCOlia::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::MpTcpCCOlia")
-    .SetParent<TcpCongestionOps> ()
-    .AddConstructor<MpTcpCCOlia> ()
-//    .AddAttribute ("ReTxThreshold", "Threshold for fast retransmit",
-//                    UintegerValue (3),
-//                    MakeUintegerAccessor (&TcpNewReno::m_retxThresh),
-//                    MakeUintegerChecker<uint32_t> ())
-//    .AddAttribute ("LimitedTransmit", "Enable limited transmit",
-//		    BooleanValue (false),
-//		    MakeBooleanAccessor (&TcpNewReno::m_limitedTx),
-//		    MakeBooleanChecker ())
-//    .AddTraceSource ("CongestionWindow",
-//                     "The TCP connection's congestion window",
-//                     MakeTraceSourceAccessor (&MpTcpCCOlia::m_cWnd))
-  ;
-  return tid;
-}
-
-
-//TypeId
-//MpTcpCCOlia::GetInstanceTypeId(void) const
-//{
-//  return GetTypeId();
-//}
-std::string
-MpTcpCCOlia::GetName(void) const {
-    return "OLIA";
-};
-
-MpTcpCCOlia::MpTcpCCOlia(void) :
-  TcpCongestionOps()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-MpTcpCCOlia::MpTcpCCOlia(const MpTcpCCOlia& sock) :
-  TcpCongestionOps(sock)
-{
-  NS_LOG_FUNCTION (this);
-  NS_LOG_LOGIC ("Invoked the copy constructor");
-}
-
-MpTcpCCOlia::~MpTcpCCOlia()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-//uint32_t
-//MpTcpCCOlia::OpenCWND(uint32_t cwnd, uint32_t ackedBytes) {
-//
-//  return 1;
-//}
-//
-//uint32_t
-//MpTcpCCOlia::ReduceCWND(uint32_t cwnd)
-//{
-//  return cwnd/2;
-//}
-//
-//  // inherited function, no need to doc.
-//TypeId
-//MpTcpCCOlia::GetInstanceTypeId (void) const
-//{
-//  return GetTypeId();
-//}
-
-Ptr<MpTcpSocketBase>
-MpTcpCCOlia::ForkAsMeta(void)
-{
-  NS_LOG_UNCOND ("Fork as meta" << this->GetInstanceTypeId() << " to " << GetTypeId());
-//  Ptr<MpTcpCCOlia> p =
-
-  return CopyObject<MpTcpCCOlia>(this);
-}
-
-uint32_t
-MpTcpCCOlia::GetSSThresh(void) const
-{
-  return 2;
-}
-
-virtual Ptr<TcpCongestionOps>
-uint32_t MpTcpCCOlia::Fork ()
-{
-  //!
-  return CreateObject<MpTcpCCOlia>(*this);
-}
-
-} //end of ns3
diff --git a/src/internet/model/mptcp-cc-olia.h b/src/internet/model/mptcp-cc-olia.h
deleted file mode 100644
index 8ec07d7..0000000
--- a/src/internet/model/mptcp-cc-olia.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-#ifndef MPTCP_CC_OLIA_H
-#define MPTCP_CC_OLIA_H
-
-//#include"ns3/mp-tcp-cc.h"
-//#include"ns3/mp-tcp-subflow.h"
-//#include"ns3/mp-tcp-socket-base.h"
-#include"ns3/tcp-congestion-ops.h"
-//#include"ns3/callback.h"
-
-namespace ns3
-{
-
-
-/**
-This is the linux struct.  We may try to get sthg close to this
-http://www.nsnam.org/wiki/New_TCP_Socket_Architecture#Pluggable_Congestion_Control_in_Linux_TCP
-static struct tcp_congestion_ops mptcp_olia = {
-	.init		= mptcp_olia_init,
-	.ssthresh	= tcp_reno_ssthresh,
-	.cong_avoid	= mptcp_olia_cong_avoid,
-	.set_state	= mptcp_olia_set_state,
-	.min_cwnd	= tcp_reno_min_cwnd,
-};
-
-* \ingroup mptcp
-*/
-class MpTcpCCOlia : public TcpCongestionOps
-{
-
-public:
-  static TypeId GetTypeId (void);
-
-  MpTcpCCOlia();
-  MpTcpCCOlia(const MpTcpCCOlia& sock);
-  virtual ~MpTcpCCOlia();
-
-
-  virtual void IncreaseWindow (Ptr<TcpSocketState> tcb);
-
-  virtual uint32_t GetSsThresh (Ptr<const TcpSocketState> tcb);
-  /**
-  **/
-//  virtual Ptr<TcpSocketBase> Fork(void);
-  // transform into a callback ?
-  // Callback<Ptr<MpTcpSubflow>, Ptr<MpTcpSocketBase>, Ptr<MpTcpCongestionControl> >
-  //Ptr<MpTcpSubflow>
-
-  // Called by SendPendingData() to get a subflow based on round robin algorithm
-//  virtual int GeneratePartition(Ptr<MpTcpSocketBase> metaSock);
-
-  virtual std::string
-  GetName(void) const;
-
-  virtual Ptr<TcpCongestionOps> Fork ();
-protected:
-};
-
-
-}
-
-
-#endif /* MPTCP_CC_OLIA_H */
diff --git a/src/internet/model/mptcp-cc-uncoupled.ccc b/src/internet/model/mptcp-cc-uncoupled.ccc
deleted file mode 100644
index 8b13789..0000000
--- a/src/internet/model/mptcp-cc-uncoupled.ccc
+++ /dev/null
@@ -1 +0,0 @@
-
diff --git a/src/internet/model/mptcp-cc-uncoupled.h b/src/internet/model/mptcp-cc-uncoupled.h
deleted file mode 100644
index 1e83d62..0000000
--- a/src/internet/model/mptcp-cc-uncoupled.h
+++ /dev/null
@@ -1,5 +0,0 @@
-        adder = static_cast<double>(MSS * MSS) / cwnd;
-        adder = std::max(1.0, adder);
-        sFlow->cwnd += static_cast<double>(adder);
-        NS_LOG_WARN ("Subflow "<<(int)sFlowIdx<<" Congestion Control (Uncoupled_TCPs) increment is "<<adder<<" GetSSThresh() "<< GetSSThresh() << " cwnd "<<cwnd);
-        break;
diff --git a/src/internet/model/mptcp-crypto.cc b/src/internet/model/mptcp-crypto.cc
deleted file mode 100644
index 1acf60a..0000000
--- a/src/internet/model/mptcp-crypto.cc
+++ /dev/null
@@ -1,122 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2007 Georgia Tech Research Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-
-#include <stdint.h>
-#include "ns3/mptcp-crypto.h"
-#include "ns3/log.h"
-#include "ns3/node.h"
-#include "ns3/buffer.h"
-#include "ns3/assert.h"
-#include <cstddef> // for size_t
-
-#ifdef HAVE_CRYPTO
-    #include <gcrypt.h> // for the sha1 hash
-#else
-    #include <functional> // to emulate some hash function
-    #include <iostream>
-    #include <string>
-//    #include "ns3/hash.h"
-//    Create<Hash::Function::Fnv1a> ()
-#endif
-
-NS_LOG_COMPONENT_DEFINE ("MpTcpCrypto");
-
-namespace ns3 {
-
-//#ifdef HAVE_CRYPTO
-//static gcry_md_algos
-//map_ns_to_gcrypt_alg(mptcp_crypto_alg_t alg)
-//{
-//    return GCRY_MD_SHA1;
-//}
-//
-//#endif
-
-
-//https://www.gnupg.org/documentation/manuals/gcrypt/Working-with-hash-algorithms.html#Working-with-hash-algorithms
-void
-GenerateTokenForKey( mptcp_crypto_alg_t ns_alg, uint64_t key, uint32_t *token, uint64_t *idsn)
-{
-
-  NS_LOG_LOGIC ("Generating token/key from key=" << key);
-
-//  uint8_t digest[DIGEST_SIZE_IN_BYTES];
-  #ifdef HAVE_CRYPTO
-
-  NS_LOG_DEBUG ("Using libgcrypt");
-//  gcry_md_algos gcry_algo = map_ns_to_gcrypt_alg(ns_alg);
-  gcry_md_algos gcry_algo = GCRY_MD_SHA1;
-//  NS_LOG_UNCOND("Used algorithm [" << gcry_md_algo_name(alg) << "]");
-
-  static const int KEY_SIZE_IN_BYTES = sizeof(key);
-  /* converts the key into a buffer */
-  Buffer keyBuff;
-
-  keyBuff.AddAtStart(KEY_SIZE_IN_BYTES);
-  Buffer::Iterator it = keyBuff.Begin();
-  it.WriteHtonU64(key);
-
-
-    NS_LOG_DEBUG ("Used algorithm [" << gcry_md_algo_name(gcry_algo) << "]");
-    int hash_length = gcry_md_get_algo_dlen( gcry_algo );
-//    unsigned char digest[ hash_length ];
-    unsigned char digest[ 20 ];
-
-    NS_LOG_DEBUG("Key length=" <<KEY_SIZE_IN_BYTES << " and hash_len=" << hash_length);
-
-    Buffer digestBuf; /* to store the generated hash */
-    digestBuf.AddAtStart(hash_length);
-
-    /*
-    gcry_md_hash_buffer (int algo, void *digest, const void *buffer, size_t length);
-    gcry_md_hash_buffer is a shortcut function to calculate a message digest of a buffer.
-    This function does not require a context and immediately returns the message digest
-    of the length bytes at buffer. digest must be allocated by the caller,
-    large enough to hold the message digest yielded by the the specified algorithm algo.
-    This required size may be obtained by using the function gcry_md_get_algo_dlen.
-    */
-    gcry_md_hash_buffer( GCRY_MD_SHA1, digest, keyBuff.PeekData(), KEY_SIZE_IN_BYTES );
-
-    Buffer::Iterator it_digest = digestBuf.Begin();
-    it_digest.Write( digest , hash_length ); // strlen( (const char*)digest)
-    it_digest = digestBuf.Begin();
-    *token = it_digest.ReadNtohU32();
-    it_digest.Next( 8 );
-    *idsn = it_digest.ReadNtohU64();
-  #else
-    /* the cryptographic library is not available so we rely on a ns3 specific implementation
-    that does not comply with the standard.
-    In the following, the idsn = the key (could be 0) and the token a truncated key
-
-    */
-    NS_LOG_DEBUG ("Using ns3 method");
-    *idsn = key;
-    *token = (uint32_t)key;
-
-//     Hasher hasher = Hasher ( Create<Hash::Function::Fnv1a> () );
-//uint32_t hash = Hasher.GetHash32 (data);
-//     Create<Hash::Function::Fnv1a> ();
-  #endif // HAVE_CRYPTO
-
-  NS_LOG_DEBUG("Resulting token=" << token << " and idsn=" << idsn);
-}
-
-
-} // end of 'ns3'
diff --git a/src/internet/model/mptcp-crypto.h b/src/internet/model/mptcp-crypto.h
deleted file mode 100644
index e7fd63e..0000000
--- a/src/internet/model/mptcp-crypto.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2007 Georgia Tech Research Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-
-#ifndef MPTCP_CRYPTO_H
-#define MPTCP_CRYPTO_H
-
-
-/**
-   Token:  A locally unique identifier given to a multipath connection
-      by a host.  May also be referred to as a "Connection ID".
-
-In this specification, with only the SHA-1 algorithm
-   (bit "H") specified and selected, the token MUST be a truncated (most
-   significant 32 bits) SHA-1 hash ([4], [15]) of the key.  A different,
-   64-bit truncation (the least significant 64 bits) of the SHA-1 hash
-   of the key MUST be used as the initial data sequence number.  Note
-   that the key MUST be hashed in network byte order.  Also note that
-   the "least significant" bits MUST be the rightmost bits of the SHA-1
-   digest, as per [4].  Future specifications of the use of the crypto
-   bits may choose to specify different algorithms for token and IDSN
-   generation.
-*/
-namespace ns3
-{
-  /**
-   * \brief Only SHA1 is defined in the RFC up to now.
-   */
-  enum mptcp_crypto_alg_t
-  {
-    HMAC_SHA1 = 1 /**< Default choice */
-      /* more may come in the future depending on the standardization */
-  };
-
-  /**
-   * \brief This function generates the token and idsn based on the passed key
-   *
-   * \note This function operates in different modes depending on if the library libgcrypt
-   *   was available when running ./waf config . The result conforms to the standard when libgcrypt
-   *  is present, otherwise it relies on a simpler incompatible ns3 implementation.
-   *
-   * In the case of sha1 (only one standardized), the token MUST be a truncated (most
-   * significant 32 bits) SHA-1 hash according to \rfc{6824}.
-   * The least significant 64 bits of the SHA-1 hash
-   * of the key MUST be used as the initial data sequence number.
-   *
-   * \param alg The hmac algorith m to use to generate the hash
-   * \param key Given key for a connection
-   * \param token Resulting token generated from the key
-   * \param idsn Resulting initial data sequence number generated from the key
-   */
-  void
-  GenerateTokenForKey ( mptcp_crypto_alg_t alg, uint64_t key, uint32_t *token, uint64_t *idsn);
-}
-
-
-#endif
diff --git a/src/internet/model/mptcp-id-manager-impl.cc b/src/internet/model/mptcp-id-manager-impl.cc
deleted file mode 100644
index f289489..0000000
--- a/src/internet/model/mptcp-id-manager-impl.cc
+++ /dev/null
@@ -1,316 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#include "ns3/mptcp-id-manager-impl.h"
-#include "ns3/log.h"
-#include <algorithm>
-
-
-namespace ns3
-{
-
-NS_LOG_COMPONENT_DEFINE ("MpTcpPathIdManagerImpl");
-
-NS_OBJECT_ENSURE_REGISTERED (MpTcpPathIdManagerImpl);
-
-MpTcpPathIdManagerImpl::MpTcpPathIdManagerImpl(
-//const bool localPM
-) :
-  MpTcpPathIdManager (),
-  m_localSubflowUid (0)
-  
-//,  m_localPM (localPM)
-{
-  NS_LOG_INFO(this);
-}
-
-MpTcpPathIdManagerImpl::~MpTcpPathIdManagerImpl()
-{
-  NS_LOG_INFO(this);
-}
-
-
-TypeId
-MpTcpPathIdManagerImpl::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::MpTcpPathIdManagerImpl")
-    .SetParent<MpTcpPathIdManager> ()
-    //
-    .AddConstructor<MpTcpPathIdManagerImpl> ()
-  ;
-//  NS_LOG_UNCOND("TcpOptionMpTcp::GetTypeId called !");
-  return tid;
-}
-
-
-TypeId
-MpTcpPathIdManagerImpl::GetInstanceTypeId (void) const
-{
-//  NS_LOG_UNCOND("TcpOptionMpTcp::GetInstanceTypeId called");
-  return MpTcpPathIdManagerImpl::GetTypeId ();
-}
-
-
-
-//MpTcpAddressContainer::iterator
-////uint8_t
-//MpTcpPathIdManagerImpl::FindAddrIdOfAddr(Address addr )
-//{
-//
-//  ;
-//  for(MpTcpAddressContainer::iterator it = m_addrs.begin(); it = m_addrs.end() ; it ++)
-//  {
-//
-//    if( it->second.first == addr)
-//    {
-//      NS_LOG_INFO("Found a match for addr " << addr << " : associated id is " << it->first)
-////      return it->first;
-//      return it;
-//    }
-//  }
-//  return m_addrs.end();
-//}
-
-
-bool
-MpTcpPathIdManagerImpl::AddLocalId (uint8_t *addrId, const Address& address)
-{
-  NS_LOG_FUNCTION (address);
-//  NS_ASSERT_MSG (m_localPM, "Can't call this function with a remote id manager");
-
-  
-  bool res = AddId (m_localSubflowUid, address);
-  if(res) 
-  {
-    *addrId = m_localSubflowUid++;;
-  }
-  return res;
-}
-
-// 
-bool
-MpTcpPathIdManagerImpl::AddId (
-uint8_t addrId, const Address& addressToRegister
-//, uint16_t portToRegister
-)
-{
-  NS_LOG_FUNCTION (addrId << addressToRegister);
-//  MpTcpAddressContainer& container = m_addrs;
-
-//  MpTcpAddressInfo addrInfo = std::make_pair(address,port);
-
-  uint8_t temp;
-  if (GetMatch (&temp, addressToRegister)) 
-  {
-    NS_LOG_DEBUG ("Can't add twice the same address");
-    return false;
-  }
-
-  NS_LOG_INFO ("Trying to add addrId [" << static_cast<int>(addrId) << "] ");
-
-  MpTcpAddressContainer::iterator it = m_addrs.find( addrId );
-  // if id already registered then we need to check the IPs are the same as the one advertised and that ports are different
-
-//  bool insert;
-//  NS_LOG_ERROR ("TODO not implemented : should lookup closest match");
-  if(it != m_addrs.end() )
-  {
-    NS_LOG_FUNCTION ("Id already registered");
-    return false;
-//    Address match = it->second;
-//    if (match.GetSerializedSize () != addressToRegister.GetSerializedSize () ) 
-//    {
-//      NS_LOG_WARN ("it could be ok to add it anyway");
-//    }
-    // if there is a match, we
-//    Ipv4Address addrRegisteredWithId = it->second.first;
-////    uint16_t portRegisteredTo)
-////    for(MpTcpAddressContainer::iterator it2 = it.first; it2 != it.second; it2++)
-////    {
-//
-//      // id already registered to another IP
-//      if (addrRegisteredWithId != addressToRegister)
-//      {
-//        NS_LOG_WARN("Rejected ADD_ADDR because id [" << addrId
-//              << "] already registered with IP " << addressToRegister
-//              );
-//        return false;
-//      }
-//
-//      std::vector<uint16_t>& ports = it->second.second;
-
-      // if port specified
-//      if(portToRegister != 0 )
-//      {
-//        std::vector<uint16_t>::iterator it2 = std::find(ports.begin(), ports.end(), portToRegister);
-//
-//        // if port already registered
-//        if( it2 != ports.end() )
-//        {
-//          NS_LOG_WARN ("Rejected ADD_ADDR because this port " << portToRegister
-//                << " was already advertised with id [" << addrId << "] "
-//                );
-//          return false;
-//        }
-//        else 
-//        {
-//          ports.push_back(portToRegister);
-//        }
-//
-//      }
-    }
-    else
-    {
-      NS_LOG_DEBUG ("Registering " << addressToRegister << addrId );
-      m_addrs.insert (std::make_pair (addrId, addressToRegister));
-    }
-
-// callback to know if we should accept it ?
-//  }
-
-  // assume it works
-
-  // Should be RFC compliant to addaddr
-//  NotifyAddAddr( addrInfo );
-  return true;
-}
-
-
-//uint8_t
-//MpTcpPathIdManagerImpl::GenerateAddrId(MpTcpAddressInfo)
-//{
-//
-//}
-
-
-bool
-MpTcpPathIdManagerImpl::RemoveId (uint8_t addrId)
-{
-//  MpTcpAddressContainer& container = m_remoteAddrs[remote];
-
-  // TODO retreive the address, check there is no subflow establish with this ID
-  // Than remove it from available addresses
-//  NS_LOG_ERROR ("Function not implemented ");
-
-  MpTcpAddressContainer::size_type res = m_addrs.erase( addrId );
-//  NotifyRemAddress(addrId);
-  return (res != 0);
-}
-
-//
-//bool
-//MpTcpPathIdManagerImpl::RemoveLocalId(
-//  Address address
-//  )
-////  Ipv4Address address, uint8_t& id)
-//{
-//  NS_ASSERT_MSG (InetSocketAddress::IsMatchingType(address), "Only ipv4 supported");
-//  
-//  std::map<Ipv4Address,uint8_t>::iterator it  = m_localAddresses.find( address.GetIpv4() );
-//  if(it != m_localAddresses.end() )
-//  {
-////    id = it->second;
-//    return true;
-//  }
-//  return false;
-//}
-
-
-
-bool
-MpTcpPathIdManagerImpl::GetMatch (uint8_t *result, const Address& address)
-{
-  NS_LOG_FUNCTION (address);
-  //TODO should be able to improve AddrId allocation to allow for more choices
-  // converts Static into member function ? add a modulo in case we add too many local addr ?
-  static uint8_t addrId = 0;
-  addrId++;
-
-  bool res = InetSocketAddress::IsMatchingType (address);
-  NS_ASSERT_MSG (res, "only support InetSocketAddress for now");
-  
-  // TODO check if it's owned by the node ? or not ?
-//  MpTcpAddressContainer::const_iterator it = std::find (m_addrs.being(), m_addrs.edn());
-  for (MpTcpAddressContainer::const_iterator it(m_addrs.begin()); it != m_addrs.end(); it++ )
-  {
-    if(it->second == address)
-    {
-      NS_LOG_DEBUG ( it->first << " match " << address);
-      *result = it->first;
-      return true;
-    }
-  }
-//  if (it != m_addrs.end())
-//  {
-//    result = it->first;
-//  }
-//  std::pair< std::map<Ipv4Address,uint8_t>::iterator , bool > result = m_localAddresses.insert(
-//              std::make_pair(address.GetIpv4(), addrId)
-//              );
-//  std::map<Ipv4Address,uint8_t>::iterator it = m_localAddresses.find( address );
-//  if( ! result.second) addrId--;
-
-  return false;
-}
-
-
-
-
-#if 0
-void
-MpTcpPathIdManagerImpl::GetAllAdvertisedDestinations (std::vector<InetSocketAddress>& addresses)
-{
-  addresses.clear();
-  for(MpTcpAddressContainer::iterator externIt = m_addrs.begin(); externIt != m_addrs.end(); externIt++)
-  {
-    std::vector<uint16_t>& portList = externIt->second.second;
-
-    for( std::vector<uint16_t>::iterator internIt = portList.begin(); internIt != portList.end() ;internIt++ )
-    {
-      // ip / port
-      addresses.push_back( InetSocketAddress( externIt->second.first, *internIt) );
-    }
-  }
-}
-
-
-
-void
-MpTcpSocketBase::SetAddAddrCallback(Callback<bool, Ptr<Socket>, Address, uint8_t> addAddr)
-{
-  NS_LOG_FUNCTION (this << &addAddr);
-
-  m_onAddAddr = addAddr;
-}
-
-void
-MpTcpSocketBase::NotifyAddAddr(MpTcpAddressInfo info)
-{
-  if (!m_onAddAddr.IsNull())
-  {
-    // TODO user should not have to deal with MpTcpAddressInfo
-    m_onAddAddr (this, info.first, info.second);
-  }
-}
-
-#endif
-
-} // namespace ns3
diff --git a/src/internet/model/mptcp-id-manager-impl.h b/src/internet/model/mptcp-id-manager-impl.h
deleted file mode 100644
index 3fedef0..0000000
--- a/src/internet/model/mptcp-id-manager-impl.h
+++ /dev/null
@@ -1,175 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#ifndef MPTCP_PATH_ID_MANAGER_IMPL_H
-#define MPTCP_PATH_ID_MANAGER_IMPL_H
-
-#include "ns3/callback.h"
-//#include "ns3/mptcp-mapping.h"
-//#include "ns3/tcp-socket-base.h"
-//#include "ns3/mp-tcp-path-manager.h"
-//#include "ns3/gnuplot.h"
-//#include "mp-tcp-subflow.h"
-
-#include "ns3/object.h"
-#include "ns3/address.h"
-#include "ns3/inet-socket-address.h"
-#include "ns3/mptcp-id-manager.h"
-#include <map>
-#include <vector>
-
-
-namespace ns3
-{
-
-
-/**
-* TODO setup callbacks in order to know if we shall accept the addition
-* \brief The MPTCP path manager tracks ADD_ADDR/REM_ADDR in case the user wants to later open new subflows.
-* It is possible to use callbacks from the MPTCP metasocket to be notified in case of a new ADD_ADDR.
-* Thus it is possible to immediately create the desired subflows
-*
-RFC6824
-   The Address IDs of the subflow used in the initial SYN exchange of
-   the first subflow in the connection are implicit, and have the value
-   zero.  A host MUST store the mappings between Address IDs and
-   addresses both for itself and the remote host.  An implementation
-   will also need to know which local and remote Address IDs are
-   associated with which established subflows, for when addresses are
-   removed from a local or remote host.
-
-* There should be a testsuite to
-* \class MpTcpPathIdManagerImpl
-**/
-class MpTcpPathIdManagerImpl : public MpTcpPathIdManager
-{
-
-public:
-
-  /**
-   * \param 
-   */
-  MpTcpPathIdManagerImpl (
-//  const bool local_pm
-  );
-
-  virtual ~MpTcpPathIdManagerImpl ();
-
-  static TypeId
-  GetTypeId (void);
-
-  TypeId
-  GetInstanceTypeId (void) const;
-
-  /**
-  Will generate an appropriate ID
-  (InetSocketAddress addr
-  **/
-//  virtual uint8_t GetIdForLocalAddr( Ipv4Address address );
-//  virtual bool RemoveLocalId(Ipv4Address addr);
-
-  /**
-  \param addresses
-  \warning Don't forget to clear the vector first !
-  **/
-
-//  virtual void
-//  GetAllAdvertisedDestinations (std::vector<Address>& addresses);
-
-  // TODO move callbacks here + local address Mgmt ?
-
-  // GetClosestMatchingId
-//  uint8_t
-//  GetLocalAddrId (const Address& address);
-
-  /**
-   * For now only search for exact matches of InetSocketAddress, while it should 
-   * also look for closest match (in case just ip is searched, no port for instance).
-   */
-  bool GetMatch (uint8_t *result, const Address& address );
-
-  /**
-  Can force the ID with which to register
-  //    const Ipv4Address& address, uint16_t port = 0
-  // TODO rename into registerId ?
-  **/
-  virtual bool
-  AddId (uint8_t addrId, const Address& address);
-
-  virtual bool
-  AddLocalId (uint8_t *addrId, const Address& address);
-
-  /**
-  * del/rem
-  */
-  virtual bool
-  RemoveId (uint8_t addrId);
-
-//  virtual bool
-//  RemoveLocalId(uint8_t addrId) ;
-
-protected:
-  friend class MpTcpSocketBase;
-
-  uint8_t m_localSubflowUid;  /**!< Used to generate local subflow ids */
-//  const bool m_localPM;
-  
-  // MPTCP containers
-  // INetSocketAddress
-//  InetSocketAddress
-  //!< Ipv4/v6 address and its port
-//  typedef std::pair<const Ipv4Address, std::vector<uint16_t> > MpTcpAddressInfo;
-
-//  typedef std::multimap<uint8_t,MpTcpAddressInfo>  MpTcpAddressContainer;
-  typedef std::map<uint8_t, Address>  MpTcpAddressContainer;
-
-  //! Maps an Address Id to the pair  (Ipv4/v6, port)
-//  std::map<uint8_t,MpTcpAddressInfo> m_localAddrs;
-
-   //! List addresses advertised by the remote host
-   //! index 0 for local, 1 for remote addr
-  MpTcpAddressContainer m_addrs;
-
-
-  /** Associate every local IP with an unique identifier
-   */
-//  std::map<Address,uint8_t> m_localAddresses; 
-
-  /**
-  Need this to check if an IP has already been advertised, in which case
-  the same id should be associated to the already advertised IP
-
-  **/
-//  virtual MpTcpAddressContainer::iterator FindAddrIdOfAddr(Address addr );
-
-
-//  virtual uint8_t GenerateAddrId(MpTcpAddressInfo);
-//  virtual uint8_t GenerateAddrId(const InetSocketAddress&);
-//  virtual uint8_t GenerateAddrId(const InetSocketAddress6&);
-};
-
-
-
-}
-
-
-
-#endif // MPTCP_PATH_ID_MANAGER_IMPL_H
diff --git a/src/internet/model/mptcp-id-manager.cc b/src/internet/model/mptcp-id-manager.cc
deleted file mode 100644
index 1d47efb..0000000
--- a/src/internet/model/mptcp-id-manager.cc
+++ /dev/null
@@ -1,61 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#include "mptcp-id-manager.h"
-#include "ns3/log.h"
-
-namespace ns3
-{
-
-NS_LOG_COMPONENT_DEFINE ("MpTcpPathIdManager");
-
-
-NS_OBJECT_ENSURE_REGISTERED (MpTcpPathIdManager);
-
-TypeId
-MpTcpPathIdManager::GetTypeId (void)
-{
-  static TypeId tid = TypeId("ns3::MpTcpPathIdManager")
-      .SetParent<Object>()
-//      .AddConstructor<MpTcpSubflow>()
-      // TODO should be inherited
-//      .AddTraceSource("cWindow",
-//          "The congestion control window to trace.",
-//           MakeTraceSourceAccessor(&MpTcpSubflow::m_cWnd))
-    ;
-  return tid;
-}
-
-MpTcpPathIdManager::MpTcpPathIdManager () :
-  Object()
-{
-  NS_LOG_INFO(this);
-}
-
-
-TypeId
-MpTcpPathIdManager::GetInstanceTypeId(void) const
-{
-  return MpTcpPathIdManager::GetTypeId();
-}
-
-
-} // end of ns3
diff --git a/src/internet/model/mptcp-id-manager.h b/src/internet/model/mptcp-id-manager.h
deleted file mode 100644
index ff5871b..0000000
--- a/src/internet/model/mptcp-id-manager.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#ifndef MPTCP_ID_MANAGER_H
-#define MPTCP_ID_MANAGER_H
-
-#include "ns3/callback.h"
-//#include "ns3/mptcp-mapping.h"
-//#include "ns3/tcp-socket-base.h"
-//#include "ns3/mp-tcp-path-manager.h"
-//#include "ns3/gnuplot.h"
-//#include "mp-tcp-subflow.h"
-
-#include "ns3/object.h"
-#include "ns3/address.h"
-#include "ns3/inet-socket-address.h"
-#include <map>
-#include <vector>
-
-
-namespace ns3
-{
-
-
-/**
-* TODO setup callbacks in order to know if we shall accept the addition
-* \brief The MPTCP path manager tracks ADD_ADDR/REM_ADDR in case the user wants to later open new subflows.
-* It is possible to use callbacks from the MPTCP metasocket to be notified in case of a new ADD_ADDR.
-* Thus it is possible to immediately create the desired subflows
-*
-RFC6824
-   The Address IDs of the subflow used in the initial SYN exchange of
-   the first subflow in the connection are implicit, and have the value
-   zero.  A host MUST store the mappings between Address IDs and
-   addresses both for itself and the remote host.  An implementation
-   will also need to know which local and remote Address IDs are
-   associated with which established subflows, for when addresses are
-   removed from a local or remote host.
-
-* There should be a testsuite to
-* \class MpTcpPathIdManager
-* TODO tempalte
-
-
-Id identifies only one endpoint (
-
-**/
-class MpTcpPathIdManager
-  : public Object
-{
-
-public:
-  static TypeId GetTypeId();
-  //const bool generate_uid
-  MpTcpPathIdManager ();
-
-  virtual ~MpTcpPathIdManager() {};
-
-  virtual TypeId GetInstanceTypeId(void) const;
-
-  /**
-  Will generate an appropriate ID
-  (InetSocketAddress addr
-  **/
-//  virtual uint8_t GetIdForLocalAddr( Ipv4Address address );
-//  virtual bool RemoveLocalId(Ipv4Address addr);
-
-  /**
-  \param addresses
-  \warning Don't forget to clear the vector first !
-  **/
-//  GetAllAdvertisedDestinations (std::vector<Address>& addresses) = 0;
-//  virtual void
-//  GetRegisteredIds (std::vector<Address>& addresses) = 0;
-
-  // TODO move callbacks here + local address Mgmt ?
-
-  /**
-   * Find closest match
-   *
-   * \return true if found a match
-   * \todo should be const
-   */
-  virtual bool GetMatch (uint8_t *result, const Address& address ) = 0;
-
-  /**
-  Can force the ID with which to register
-  //    const Ipv4Address& address, uint16_t port = 0
-  
-   */
-  virtual bool
-  AddId (uint8_t addrId, const Address& address) = 0;
-
-  virtual bool
-  AddLocalId (uint8_t *addrId, const Address& address) = 0;
-
-  /**
-   * del/rem
-   *
-   */
-  virtual bool RemoveId (uint8_t addrId) = 0;
-  
-/**
-   * Called when closing the subflow
-   */
-//  virtual bool
-//  RemoveLocalId (uint8_t addrId) = 0;
-
-  
-//  virtual uint8_t
-//  GetLocalAddrId (const InetSocketAddress& address) = 0;
-//  RegisterLocalAddress()
-
-  
-  /**
-   * Called when meta receives a REMOVE_ADDRESS. It just contians ids then.
-   */
-//  virtual bool
-//  RemoveLocalId(uint8_t addrId) = 0;
-//
-//protected:
-//  const bool m_localPM;
-};
-
-
-
-}
-
-
-
-#endif // MPTCP_ID_MANAGER_H
diff --git a/src/internet/model/mptcp-lia.cc b/src/internet/model/mptcp-lia.cc
deleted file mode 100644
index 88dffa5..0000000
--- a/src/internet/model/mptcp-lia.cc
+++ /dev/null
@@ -1,130 +0,0 @@
-
-#include "ns3/mp-tcp-olia.h"
-#include "ns3/log.h"
-#include "ns3/object.h"
-#include "ns3/mp-tcp-id-manager.h"
-//#include "ns3/mp-tcp-id-manager.h"
-
-NS_LOG_COMPONENT_DEFINE("MpTcpLia");
-
-
-namespace ns3 {
-
-
-
-NS_OBJECT_ENSURE_REGISTERED (MpTcpLia);
-
-TypeId
-MpTcpLia::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::MpTcpLia")
-    .SetParent<MpTcpSocketBase> ()
-    .AddConstructor<MpTcpLia> ()
-//    .AddAttribute ("ReTxThreshold", "Threshold for fast retransmit",
-//                    UintegerValue (3),
-//                    MakeUintegerAccessor (&TcpNewReno::m_retxThresh),
-//                    MakeUintegerChecker<uint32_t> ())
-//    .AddAttribute ("LimitedTransmit", "Enable limited transmit",
-//		    BooleanValue (false),
-//		    MakeBooleanAccessor (&TcpNewReno::m_limitedTx),
-//		    MakeBooleanChecker ())
-    .AddTraceSource ("Alpha",
-//                     "The TCP connection's congestion window",
-//                     MakeTraceSourceAccessor (&MpTcpLia::m_cWnd))
-  ;
-  return tid;
-}
-
-
-//TypeId
-//MpTcpLia::GetInstanceTypeId(void) const
-//{
-//  return GetTypeId();
-//}
-
-
-MpTcpLia::MpTcpLia(void) :
-  MpTcpSocketBase()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-MpTcpLia::MpTcpLia(const MpTcpLia& sock) :
-  MpTcpSocketBase(sock)
-{
-  NS_LOG_FUNCTION (this);
-  NS_LOG_LOGIC ("Invoked the copy constructor");
-}
-
-MpTcpLia::~MpTcpLia()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-  // inherited function, no need to doc.
-//TypeId
-//MpTcpLia::GetInstanceTypeId (void) const
-//{
-//  return GetTypeId();
-//}
-
-Ptr<MpTcpSocketBase>
-MpTcpLia::ForkAsMeta(void)
-{
-  NS_LOG_UNCOND ("Fork as meta" << this->GetInstanceTypeId() << " to " << GetTypeId());
-//  Ptr<MpTcpLia> p =
-
-  return CopyObject<MpTcpLia>(this);
-}
-
-uint32_t
-MpTcpLia::GetSSThresh(void) const
-{
-  return 2;
-}
-
-
-        calculateAlpha();
-        adder = alpha * MSS * MSS / m_totalCwnd;
-        adder = std::max(1.0, adder);
-        sFlow->cwnd += static_cast<double>(adder);
-
-        NS_LOG_ERROR ("Subflow "
-                <<(int)sFlowIdx
-                <<" Congestion Control (Linked_Increases): alpha "<<alpha
-                <<" increment is "<<adder
-                <<" GetSSThresh() "<< GetSSThresh()
-                << " cwnd "<<cwnd );
-        break;
-
-
-uint32_t
-MpTcpLia::GetInitialCwnd(void) const
-{
-  return 10;
-}
-
-//
-//Ptr<SubFlow>
-//MpTcpLia::GetSubflowToUse(Ptr<MpTcpSocketBase> metaSock)
-//{
-//  uint8_t nextSubFlow = 0;
-//  switch (m_distribAlgo)
-//    {
-//  case Round_Robin:
-//    nextSubFlow = (m_lastUsedsFlowIdx + 1) % m_subflows.size();
-//    break;
-//  default:
-//    break;
-//    }
-//  return nextSubFlow;
-//
-//}
-//
-
-
-
-
-} //end of ns3
-
-
diff --git a/src/internet/model/mptcp-lia.h b/src/internet/model/mptcp-lia.h
deleted file mode 100644
index b9e8aba..0000000
--- a/src/internet/model/mptcp-lia.h
+++ /dev/null
@@ -1,64 +0,0 @@
-#ifndef MPTCP_CC_LIA_H
-#define MPTCP_CC_LIA_H
-
-//#include"ns3/mp-tcp-cc.h"
-//#include"ns3/mp-tcp-subflow.h"
-#include"ns3/mp-tcp-socket-base.h"
-//#include"ns3/callback.h"
-
-namespace ns3
-{
-
-
-/**
-This is the linux struct.  We may try to get sthg close to this
-http://www.nsnam.org/wiki/New_TCP_Socket_Architecture#Pluggable_Congestion_Control_in_Linux_TCP
-static struct tcp_congestion_ops mptcp_olia = {
-	.init		= mptcp_olia_init,
-	.ssthresh	= tcp_reno_ssthresh,
-	.cong_avoid	= mptcp_olia_cong_avoid,
-	.set_state	= mptcp_olia_set_state,
-	.min_cwnd	= tcp_reno_min_cwnd,
-};
-
-* \ingroup mptcp
-*/
-class MpTcpLia : public MpTcpSocketBase
-{
-
-public:
-  static TypeId GetTypeId (void);
-
-  MpTcpLia();
-  MpTcpLia(const MpTcpLia& sock);
-  virtual ~MpTcpLia();
-
-  virtual uint32_t
-  GetSSThresh(void) const;
-
-  virtual uint32_t
-  GetInitialCwnd(void) const;
-
-
-  virtual Ptr<MpTcpSocketBase> ForkAsMeta(void);
-//  virtual Ptr<TcpSocketBase> Fork(void);
-  // transform into a callback ?
-  // Callback<Ptr<MpTcpSubflow>, Ptr<MpTcpSocketBase>, Ptr<MpTcpCongestionControl> >
-  //Ptr<MpTcpSubflow>
-
-  // Called by SendPendingData() to get a subflow based on round robin algorithm
-//  virtual int GeneratePartition(Ptr<MpTcpSocketBase> metaSock);
-
-//  virtual const char*
-//  GetName(void) const {
-//    return "OLIA";
-//  };
-
-//  SendPendingData()
-};
-
-
-}
-
-
-#endif /* MPTCP_CC_LIA_H */
diff --git a/src/internet/model/mptcp-mapping.cc b/src/internet/model/mptcp-mapping.cc
deleted file mode 100644
index 1a7f6fa..0000000
--- a/src/internet/model/mptcp-mapping.cc
+++ /dev/null
@@ -1,430 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#include <iostream>
-#include <set>
-#include <iterator>
-#include <algorithm>
-#include "ns3/mptcp-mapping.h"
-#include "ns3/simulator.h"
-#include "ns3/log.h"
-
-
-NS_LOG_COMPONENT_DEFINE("MpTcpMapping");
-
-namespace ns3
-{
-
-/**
-* \brief sorted on DSNs
-*/
-typedef std::set<MpTcpMapping> MappingList;
-//typedef std::map<SequenceNumber32, MpTcpMapping> MappingList;
-
-
-MpTcpMapping::MpTcpMapping() :
-  m_dataSequenceNumber(0),
-  m_subflowSequenceNumber(0),
-  m_dataLevelLength(0)
-{
-  NS_LOG_FUNCTION(this);
-}
-
-MpTcpMapping::~MpTcpMapping(void)
-{
-  NS_LOG_FUNCTION(this);
-};
-
-
-void
-MpTcpMapping::SetMappingSize(uint16_t const& length)
-{
-  NS_LOG_DEBUG(this << " length=" << length);
-  m_dataLevelLength = length;
-}
-
-bool
-MpTcpMapping::TranslateSSNToDSN(const SequenceNumber32& ssn, SequenceNumber64& dsn) const
-{
-  if (IsSSNInRange(ssn))
-  {
-//      dsn =
-//    NS_FATAL_ERROR("TODO");
-  // TODO check for seq wrapping ? PAWS
-    dsn = SequenceNumber64(ssn - HeadSSN()) + HeadDSN();
-    return true;
-  }
-
-  return false;
-}
-
-
-std::ostream&
-operator<<(std::ostream& os, const MpTcpMapping& mapping)
-{
-  //
-  os << "DSN [" << mapping.HeadDSN() << "-" << mapping.TailDSN ()
-  //of size [" << mapping.GetLength() <<"] from DSN [" << mapping.HeadDSN()
-    << "] mapped to SSN [" <<  mapping.HeadSSN() << "-" <<  mapping.TailSSN() << "] (size=" << mapping.GetLength() << ")";
-  return os;
-}
-
-void
-MpTcpMapping::SetHeadDSN(SequenceNumber64 const& dsn)
-{
-  NS_LOG_DEBUG(this << " headDSN=" << dsn);
-  m_dataSequenceNumber = dsn;
-}
-
-
-void
-MpTcpMapping::MapToSSN( SequenceNumber32 const& seq)
-{
-  NS_LOG_DEBUG(this << " mapping to ssn=" << seq);
-  m_subflowSequenceNumber = seq;
-}
-
-// n'est jamais utilis√© en fait
-//bool
-//MpTcpMapping::Intersect(const MpTcpMapping& mapping) const
-//{
-//  //!
-//  return( IsSSNInRange( mapping.HeadSSN()) || IsSSNInRange( mapping.TailSSN())
-//         || IsDSNInRange( mapping.HeadDSN()) || IsDSNInRange( mapping.TailDSN()) );
-//}
-
-bool
-MpTcpMapping::operator==(const MpTcpMapping& mapping) const
-{
-  //!
-  return (
-    GetLength() == mapping.GetLength()
-    && HeadDSN() == mapping.HeadDSN()
-    && HeadSSN() == mapping.HeadSSN()
-//    && GetLength()  == GetLength()
-    );
-}
-
-bool
-MpTcpMapping::operator!=( const MpTcpMapping& mapping) const
-{
-  //!
-  return !( *this == mapping);
-}
-
-
-SequenceNumber64
-MpTcpMapping::HeadDSN() const
-{
-  return m_dataSequenceNumber;
-}
-
-
-SequenceNumber32
-MpTcpMapping::HeadSSN() const
-{
-  return m_subflowSequenceNumber;
-}
-
-uint16_t
-MpTcpMapping::GetLength() const
-{
-//  NS_LOG_FUNCTION(this);
-  return m_dataLevelLength;
-}
-
-
-SequenceNumber64
-MpTcpMapping::TailDSN(void) const
-{
-  return(HeadDSN()+GetLength()-1);
-}
-
-SequenceNumber32
-MpTcpMapping::TailSSN(void) const
-{
-  return(HeadSSN()+GetLength()-1);
-}
-
-bool
-MpTcpMapping::operator<(MpTcpMapping const& m) const
-{
-
-//  return (HeadDSN() < m.HeadDSN());
-  return (HeadSSN() < m.HeadSSN());
-}
-
-
-bool
-MpTcpMapping::IsSSNInRange(SequenceNumber32 const& ssn) const
-{
-//  return OverlapRangeSSN(ssn,0);
-  return ( (HeadSSN() <= ssn) && (TailSSN() >= ssn) );
-}
-
-bool
-MpTcpMapping::IsDSNInRange(SequenceNumber64 const& dsn) const
-{
-//  return OverlapRangeDSN(dsn,0);
-  return ( (HeadDSN() <= dsn) && (TailDSN() >= dsn) );
-}
-
-
-//SequenceNumber32 subflowSeqNb
-//void
-//MpTcpMapping::Configure(SequenceNumber32  dataSeqNb, uint16_t mappingSize)
-////  m_dataSeqNumber(dataSeqNb),
-////  m_size(mappingSize)
-//{
-//  NS_LOG_LOGIC(this << "dsn [" << dataSeqNb << "], mappingSize [" << mappingSize << "]");
-//  m_dataSequenceNumber = dataSeqNb;
-//  m_dataLevelLength = mappingSize;
-//}
-
-
-bool
-MpTcpMapping::OverlapRangeSSN(const SequenceNumber32& headSSN, const uint16_t& len) const
-{
-  SequenceNumber32 tailSSN = headSSN + len-1;
-  //!
-  if( HeadSSN() >  tailSSN || TailSSN() < headSSN)
-  {
-    return false;
-  }
-  NS_LOG_DEBUG("SSN overlap");
-  return true;
-}
-
-bool
-MpTcpMapping::OverlapRangeDSN(const SequenceNumber64& headDSN, const uint16_t& len) const
-{
-  SequenceNumber64 tailDSN = headDSN + len-1;
-  //!
-  if( HeadDSN() >  tailDSN || TailDSN() < headDSN)
-  {
-    return false;
-  }
-
-  NS_LOG_DEBUG("DSN overlap");
-  return true;
-}
-
-///////////////////////////////////////////////////////////
-///// MpTcpMappingContainer
-/////
-MpTcpMappingContainer::MpTcpMappingContainer(void)
-{
-  NS_LOG_LOGIC(this);
-}
-
-MpTcpMappingContainer::~MpTcpMappingContainer(void)
-{
-  NS_LOG_LOGIC(this);
-}
-
-void
-MpTcpMappingContainer::Dump() const
-{
-  NS_LOG_UNCOND("\n==== Dumping list of mappings ====");
-  for( MappingList::const_iterator it = m_mappings.begin(); it != m_mappings.end(); it++ )
-  {
-    NS_LOG_UNCOND( *it );
-  }
-  NS_LOG_UNCOND("==== End of dump ====\n");
-}
-
-
-#if 0
-// This is wrong
-bool
-//MpTcpMappingContainer::FindOverlappingMapping(SequenceNumber32 headSSN, uint32_t len,  MpTcpMapping& ret) const
-MpTcpMappingContainer::FindOverlappingMapping(const MpTcpMapping& mapping, bool ignore_identical, MpTcpMapping& ret) const
-{
-//  SequenceNumber32 tailSSN = headSSN + SequenceNumber32(len);
-  NS_LOG_DEBUG("Looking for a mapping that overlaps with " << mapping );
-  for( MappingList::const_iterator it = m_mappings.begin(); it != m_mappings.end(); it++ )
-  {
-    // Check if mappings overlap
-//    if(it->IsSSNInRange(mapping) && mapping != *it )
-  // Faux si le mapping est encore plus petit
-    if(it->OverlapRangeSSN(mapping.HeadSSN(), mapping.GetLength())
-      || it->OverlapRangeDSN(mapping.HeadDSN(), mapping.GetLength()) )
-    {
-      if( ignore_identical && (*it == mapping))
-      {
-        NS_LOG_DEBUG("Ignoring identical mapping " << *it);
-        continue;
-      }
-
-      // Intersect, il devrait continuer ptet qu'il y en a un autre
-      NS_LOG_WARN("Mapping " << mapping << " intersects with " << *it );
-      ret = *it;
-      return true;
-    }
-
-  }
-  return false;
-}
-
-
-
-#endif
-
-
-
-//! should return a boolean
-bool
-MpTcpMappingContainer::AddMapping(const MpTcpMapping& mapping)
-//MpTcpMappingContainer::AddMappingEnforceSSN(const MpTcpMapping& mapping)
-{
-  NS_LOG_LOGIC("Adding mapping " << mapping);
-
-  NS_ASSERT(mapping.GetLength() != 0);
-//  NS_ASSERT(mapping.HeadSSN() >= );
-
-//  MpTcpMapping temp;
-
-
-//  if(FindOverlappingMapping(mapping, true, temp))
-//  {
-//    NS_LOG_WARN("Mapping " << mapping << " conflicts with existing " << temp);
-//    Dump();
-//    return false;
-//  }
-
-
-//
-//  std::pair<MappingList::iterator,bool> res = m_mappings.insert( std::make_pair(mapping.HeadSSN(), mapping));
-  std::pair<MappingList::iterator,bool> res = m_mappings.insert( mapping);
-
-  return res.second;
-}
-
-bool
-MpTcpMappingContainer::FirstUnmappedSSN(SequenceNumber32& ssn) const
-{
-//  NS_ASSERT(m_txBuffer);
-  NS_LOG_FUNCTION_NOARGS();
-  if(m_mappings.empty())
-  {
-      return false;
-  }
-  ssn = m_mappings.rbegin()->TailSSN() + 1;
-  return true;
-}
-
-
-bool
-MpTcpMappingContainer::DiscardMapping(const MpTcpMapping& mapping)
-{
-  NS_LOG_LOGIC("discard mapping "<< mapping);
-//  MappingList::iterator it = l.begin(); it != l.end(); it++)
-//  std::size_type count = m_mappings.erase(mapping);
-//  return count != 0;
-//  return m_mappings.erase(HeadSSN());
-  return m_mappings.erase(mapping);
-}
-
-#if 0
-int
-MpTcpMappingContainer::DiscardMappingsUpToSN(const SequenceNumber64& dsn,const SequenceNumber32& ssn)
-{
-  NS_LOG_LOGIC("Discarding mappings up with TailDSN < " << dsn << " AND TailSSN < " << ssn);
-
-  MappingList& l = m_mappings;
-  int erasedMappingCount = 0;
-  // TODO use reverse iterator and then clear from first found to the begin
-  for(MappingList::iterator it = l.begin(); it != l.end(); it++)
-  {
-    // check that meta socket
-    if( it->TailDSN() < dsn && it->TailSSN() < ssn)
-    {
-      erasedMappingCount++;
-      l.erase(it);
-
-    }
-  }
-
-  return erasedMappingCount;
-}
-#endif
-
-bool
-MpTcpMappingContainer::GetMappingsStartingFromSSN(SequenceNumber32 ssn, std::set<MpTcpMapping>& missing)
-{
-    NS_LOG_FUNCTION(this << ssn );
-    missing.clear();
-    //  std::copy(it,m_mappings.end(),);
-//    http://www.cplusplus.com/reference/algorithm/equal_range/
-    MpTcpMapping temp;
-    temp.MapToSSN(ssn);
-    MappingList::const_iterator it = std::lower_bound( m_mappings.begin(), m_mappings.end(), temp);
-
-    std::copy(it, m_mappings.end(), std::inserter(missing, missing.begin()));
-    return false;
-}
-
-// TODO replace by pointer
-bool
-MpTcpMappingContainer::GetMappingForSSN(const SequenceNumber32& ssn, MpTcpMapping& mapping) const
-{
-  NS_LOG_FUNCTION(ssn);
-  if(m_mappings.empty())
-    return false;
-
-  MpTcpMapping temp;
-  temp.MapToSSN(ssn);
-
-  // Returns the first that is not less
-  // upper_bound returns the greater
-  MappingList::const_iterator it = std::upper_bound( m_mappings.begin(), m_mappings.end(), temp);
-//  if(it == m_mappings.end())
-//  {
-//    it = m_mappings.begin();
-//    NS_LOG_DEBUG("could not find anything mapped to ssn" << ssn << "/" << temp.HeadSSN());
-////    return false;
-//  }
-  it--;
-  mapping = *it;
-  NS_LOG_DEBUG("Is ssn "<< ssn << " in " << mapping << " ?");
-  return mapping.IsSSNInRange( ssn );
-
-
-//  if(Mapp)
-//  MappingList& l = m_mappings;
-//  for( MappingList::const_iterator it = l.begin(); it != l.end(); it++ )
-//  {
-//    // check seq nb is within the DSN range
-//    if (
-//      it->IsSSNInRange( ssn )
-//    )
-//    {
-//      mapping = *it;
-//      return true;
-//    }
-//  }
-
-//  return false;
-}
-
-
-
-} // namespace ns3
diff --git a/src/internet/model/mptcp-mapping.h b/src/internet/model/mptcp-mapping.h
deleted file mode 100644
index 3d384a2..0000000
--- a/src/internet/model/mptcp-mapping.h
+++ /dev/null
@@ -1,354 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#ifndef MPTCP_MAPPING_H
-#define MPTCP_MAPPING_H
-
-#include <stdint.h>
-#include <vector>
-#include <queue>
-#include <list>
-#include <set>
-#include <map>
-#include "ns3/object.h"
-#include "ns3/uinteger.h"
-#include "ns3/traced-value.h"
-#include "ns3/trace-source-accessor.h"
-#include "ns3/sequence-number.h"
-#include "ns3/rtt-estimator.h"
-#include "ns3/event-id.h"
-#include "ns3/packet.h"
-#include "ns3/tcp-socket.h"
-#include "ns3/ipv4-end-point.h"
-#include "ns3/ipv4-address.h"
-#include "ns3/tcp-tx-buffer.h"
-#include "ns3/tcp-rx-buffer.h"
-
-namespace ns3
-{
-
-/*
-Only sha1 standardized for now
-TODO remove and use the MPTCP option one ?
-*/
-//typedef enum {
-//MPTCP_SHA1
-//} mptcp_crypto_t;
-
-
-/**
-TODO rename later into MpTcpDSNMapping
-
-=====
-this should work with 64 bits seq number
-======
-
-DSN=Data Sequence Number (mptcp option level)
-SSN=Subflow Sequence Number (TCP legacy seq nb)
-
-\todo dataSeqNb should be a uint64_t but that has implications over a lot of code,
-especially TCP buffers so it should be thought out with ns3 people beforehand
-*/
-class MpTcpMapping
-{
-public:
-  MpTcpMapping(void);
-
-  virtual ~MpTcpMapping(void);
-
-  /**
-  TODO maybe remove
-  **/
-//  void Configure( SequenceNumber32  dataSeqNb, uint16_t mappingSize);
-
-  /**
-  * \brief Set subflow sequence number
-  * \param headSSN
-  */
-  void MapToSSN( SequenceNumber32 const& headSSN);
-
-
-
-  /**
-  \return True if mappings share DSN space
-  Check if there is an overlap over DSN space or SSN space
-  Decline to DSN and SSN ?
-  Rename to overlap
-  */
-//  bool
-//  Intersect(const MpTcpMapping&) const;
-
-  /**
-  TODO do the same for DSNs
-  **/
-  virtual bool
-  OverlapRangeSSN(const SequenceNumber32& headSSN, const uint16_t& len) const;
-
-  virtual bool
-  OverlapRangeDSN(const SequenceNumber64& headDSN, const uint16_t& len) const;
-
-  /**
-   *
-   */
-  void
-  SetHeadDSN (SequenceNumber64 const&);
-
-  /**
-   * \brief Set mapping length
-   */
-  virtual void
-  SetMappingSize(uint16_t const&);
-
-  /**
-  * \param ssn Data seqNb
-  */
-  bool IsSSNInRange(SequenceNumber32 const& ssn) const;
-
-  /**
-  * \param dsn Data seqNb
-  */
-  bool IsDSNInRange(SequenceNumber64 const& dsn) const;
-
-  /**
-  * \param ssn Subflow sequence number
-  * \param dsn Data Sequence Number
-  * \return True if ssn belonged to this mapping, then a dsn would have been computed
-  *
-  */
-  // TODO should be done by the user
-  bool
-  TranslateSSNToDSN(const SequenceNumber32& ssn, SequenceNumber64& dsn) const;
-    /**
-    **/
-//    bool
-//    TranslateSSNtoDSN(const SequenceNumber32& ssn,SequenceNumber32 &dsn);
-
-  /**
-   * \return The last MPTCP sequence number included in the mapping
-   */
-  SequenceNumber64 TailDSN (void) const;
-
-  /**
-  * \return The last subflow sequence number included in the mapping
-  */
-  SequenceNumber32 TailSSN (void) const;
-
-  /**
-
-  **/
-
-
-
-  /**
-  * Necessary for
-  * std::set to sort mappings
-  * Compares ssn
-  * \brief Compares mapping based on their DSN number. It is required when inserting into a set
-  */
-  bool operator<(MpTcpMapping const& ) const;
-
-  /**
-   * \return MPTCP sequence number for the first mapped byte
-   */
-  virtual SequenceNumber64
-  HeadDSN() const;
-
-  // TODO rename into GetMappedSSN Head ?
-  /**
-   * \return subflow sequence number for the first mapped byte
-   */
-  virtual SequenceNumber32
-  HeadSSN() const;
-
-  /**
-  * \return mapping length
-  */
-  virtual uint16_t
-  GetLength() const ;
-
-  /**
-   * \brief Mapping are equal if everything concord, SSN/DSN and length
-  */
-  virtual bool operator==( const MpTcpMapping&) const;
-
-  /**
-   * \return Not ==
-   */
-  virtual bool operator!=( const MpTcpMapping& mapping) const;
-
-
-  // TODO should be SequenceNumber64
-protected:
-//  SequenceNumber64 m_dataSequenceNumber;   //!< MPTCP level
-  SequenceNumber64 m_dataSequenceNumber;   //!< MPTCP sequence number
-  SequenceNumber32 m_subflowSequenceNumber;  //!< subflow sequence number
-  uint16_t m_dataLevelLength;  //!< mapping length / size
-//  bool m_send;  //!< Set to true if mapping already sent & acknowledged ?
-};
-
-
-
-
-
-/**
-Depending on modifications allowed in upstream ns3, it may some day inherit from TcpTxbuffer etc ...
-Meanwhile we have a pointer towards the buffers.
-* \class MpTcpMappingContainer
-* Mapping handling
-Once a mapping has been advertised on a subflow, it must be honored. If the remote host already received the data
-(because it was sent in parallel over another subflow), then the received data must be discarded.
-
-
-TODO: it might be best to use a
-std::lower_bound on map
-Could be fun implemented as an interval tree
-http://www.geeksforgeeks.org/interval-tree/
-*/
-class MpTcpMappingContainer
-{
-  public:
-    MpTcpMappingContainer(void);
-    virtual ~MpTcpMappingContainer(void);
-
-
-    /**
-    * Removes all mappings that covered dataspace seq nbs strictly lower than "dsn"
-    * \param dsn
-    */
-//    virtual void
-//    DiscardMappingsUpToDSN(const SequenceNumber32& dsn) ;
-
-
-  /**
-   * \brief Discard mappings which TailDSN() < maxDsn and TailSSN() < maxSSN
-
-  This can be called only when dsn is in the meta socket Rx buffer and in order
-  (since it may renegate some data when out of order).
-  The mapping should also have been thoroughly fulfilled at the subflow level.
-
-
-  \return Number of mappings discarded. >= 0
-  Never used apparently
-  **/
-//  int
-//  DiscardMappingsUpToSN(const SequenceNumber64& maxDsn, const SequenceNumber32& maxSsn);
-
-
-  /**
-  When Buffers work in non renegotiable mode,
-  it should be possible to remove them one by one
-  **/
-  bool DiscardMapping(const MpTcpMapping& mapping);
-
-  /**
-  return lowest SSN number
-  \return SSN
-  Makes no sense
-  */
-//  SequenceNumber32 FirstMappedSSN (void) const;
-
-  /**
-   * \param firstUnmappedSsn last mapped SSN.
-   * \return true if non empty
-   *
-   */
-  bool FirstUnmappedSSN(SequenceNumber32& firstUnmappedSsn) const;
-
-  /**
-  For debug purpose. Dump all registered mappings
-  **/
-  virtual void Dump() const;
-
-  /*
-
-  */
-//  bool
-//  CheckIfMappingCovered(SequenceNumber32 start, uint32_t len, std::vector<MpTcpMapping>& mappings);
-
-  /**
-   * \brief one can iterate over it to find a range
-   * TODO it should look for DSN and SSN overlaps
-   * \param
-   */
-//  bool FindOverlappingMapping(
-//                    const MpTcpMapping& mapping,
-//                    bool ignore_identical,
-//                    MpTcpMapping& ret
-//                    ) const;
-//  FindOverlappingMapping(SequenceNumber32 headSSN, uint32_t len, MpTcpMapping& ret) const;
-
-
-
-  /**
-  TODO this one generates disturbing logs, we should remove it
-  and do it otherwise
-
-  Will map the mapping to the first unmapped SSN
-  \return Same value as for AddMappingEnforceSSN
-  */
-//  int
-//  AddMappingLooseSSN(MpTcpMapping&);
-
-
-  /**
-   * \brief
-   * Should do no check
-   * The mapping
-   * \note Check for overlap.
-   * \return False if the dsn range overlaps with a registered mapping, true otherwise
-   *
-  **/
-  bool AddMapping(const MpTcpMapping& mapping);
-
-  /**
-  * \param l list
-  * \param m pass on the mapping you want to retrieve
-  */
-  bool
-  GetMappingForSSN(const SequenceNumber32& ssn, MpTcpMapping& m) const;
-
-  /**
-   * \param dsn
-   */
-  virtual bool GetMappingsStartingFromSSN(SequenceNumber32 ssn, std::set<MpTcpMapping>& mappings);
-
-protected:
-
-    /**
-    SSN/ mapping
-    TODO
-    Maybe use a map to recortd extra info
-    we can assume that
-    */
-
-    std::set<MpTcpMapping> m_mappings;     //!< it is a set ordered by SSN
-};
-
-/**
-This should be a set to prevent duplication and keep it ordered
-*/
-
-std::ostream& operator<<(std::ostream &os, const MpTcpMapping& mapping);
-
-
-
-} //namespace ns3
-#endif //MP_TCP_TYPEDEFS_H
diff --git a/src/internet/model/mptcp-scheduler-fastest-rtt.cc b/src/internet/model/mptcp-scheduler-fastest-rtt.cc
deleted file mode 100644
index 98d198c..0000000
--- a/src/internet/model/mptcp-scheduler-fastest-rtt.cc
+++ /dev/null
@@ -1,178 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#include "ns3/mptcp-scheduler-fastest-rtt.h"
-#include "ns3/mptcp-subflow.h"
-#include "ns3/mptcp-socket-base.h"
-#include "ns3/log.h"
-
-NS_LOG_COMPONENT_DEFINE("MpTcpSchedulerFastestRTT");
-
-
-
-namespace ns3
-{
-
-NS_OBJECT_ENSURE_REGISTERED (MpTcpSchedulerFastestRTT);
-
-TypeId
-MpTcpSchedulerFastestRTT::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::MpTcpSchedulerFastestRTT")
-    .SetParent<MpTcpScheduler> ()
-    .AddConstructor<MpTcpSchedulerFastestRTT> ()
-  ;
-
-  return tid;
-}
-
-
-MpTcpSchedulerFastestRTT::MpTcpSchedulerFastestRTT() :
-  MpTcpScheduler(),
-  m_metaSock(0)
-{
-  NS_LOG_FUNCTION(this);
-}
-
-MpTcpSchedulerFastestRTT::~MpTcpSchedulerFastestRTT (void)
-{
-  NS_LOG_FUNCTION(this);
-}
-
-
-void
-MpTcpSchedulerFastestRTT::SetMeta(Ptr<MpTcpSocketBase> metaSock)
-{
-  NS_ASSERT(metaSock);
-  NS_ASSERT_MSG(m_metaSock == 0, "SetMeta already called");
-  m_metaSock = metaSock;
-//  m_firstUnmappedDsn = m_metaSock->m_txBuffer->HeadSequence();
-}
-
-int
-MpTcpSchedulerFastestRTT::FindFastestSubflowWithFreeWindow() const
-{
-    NS_LOG_FUNCTION_NOARGS();
-    int id = -1;
-    Time lowestEstimate = Time::Max();
-
-    for(int i = 0; i < (int) m_metaSock->GetNActiveSubflows() ; i++ )
-    {
-        Ptr<MpTcpSubflow> sf = m_metaSock->GetSubflow(i);
-        if(sf->AvailableWindow() <= 0)
-        {
-            continue;
-        }
-
-        if(sf->GetRttEstimator()->GetEstimate () < lowestEstimate)
-        {
-            //!
-            lowestEstimate = sf->GetRttEstimator()->GetEstimate ();
-            id = i;
-        }
-    }
-    return id;
-}
-
-//uint16_t
-Ptr<MpTcpSubflow>
-MpTcpSchedulerFastestRTT::GetSubflowToUseForEmptyPacket()
-{
-  NS_ASSERT(m_metaSock->GetNActiveSubflows() > 0 );
-  return  m_metaSock->GetSubflow(0);
-//  m_lastUsedFlowId = (m_lastUsedFlowId + 1) % m_metaSock->GetNActiveSubflows();
-//  return m_metaSock->GetSubFlow(m_lastUsedFlowId);
-}
-
-
-// TODO this will be solved
-// We assume scheduler can't send data on subflows, so it can just generate mappings
-//std::vector< std::pair<uint8_t, MappingList>
-// std::pair< start,size , subflow>
-// ca g√©n√®re les mappings ensuite
-bool
-MpTcpSchedulerFastestRTT::GenerateMapping(int& activeSubflowArrayId, SequenceNumber64& dsn, uint16_t& length)
-{
-    NS_LOG_FUNCTION(this);
-    NS_ASSERT(m_metaSock);
-
-    //!
-    int nbOfSubflows = m_metaSock->GetNActiveSubflows();
-    int attempt = 0;
-    uint32_t amountOfDataToSend = 0;
-
-    //! Tx data not sent to subflows yet
-    SequenceNumber32 metaNextTxSeq = m_metaSock->m_nextTxSequence;
-
-    amountOfDataToSend = m_metaSock->m_txBuffer->SizeFromSequence( metaNextTxSeq );
-
-    uint32_t metaWindow = m_metaSock->AvailableWindow();
-
-    NS_LOG_DEBUG("TxData to send=" << amountOfDataToSend  << "; Available meta window=" << metaWindow);
-    if(amountOfDataToSend <= 0)
-    {
-      NS_LOG_DEBUG("Nothing to send from meta");
-      return false;
-    }
-
-
-    if(metaWindow <= 0)
-    {
-        NS_LOG_DEBUG("No meta window available (TODO should be in persist state ?)");
-        return false; // TODO ?
-    }
-
-    int id = FindFastestSubflowWithFreeWindow();
-
-    if(id < 0)
-    {
-        NS_LOG_DEBUG("No valid subflow");
-        return false;
-    }
-//    while(attempt < nbOfSubflows)
-//    {
-//        attempt++;
-//        m_lastUsedFlowId = (m_lastUsedFlowId + 1) % nbOfSubflows;
-        Ptr<MpTcpSubflow> subflow = m_metaSock->GetSubflow(id);
-        uint32_t subflowWindow = subflow->AvailableWindow();
-
-        NS_LOG_DEBUG("subflow AvailableWindow  [" << subflowWindow << "]");
-        uint32_t canSend = std::min( subflowWindow, metaWindow);
-
-        //! Can't send more than SegSize
-        //metaWindow en fait on s'en fout du SegSize ?
-        if(canSend > 0)
-        {
-
-//            activeSubflowArrayId = m_lastUsedFlowId;
-            dsn = metaNextTxSeq;
-            canSend = std::min(canSend, amountOfDataToSend);
-            // For now we limit ourselves to a per packet basis
-            length = std::min(canSend, subflow->GetSegSize());
-            return true;
-        }
-//    }
-    NS_LOG_DEBUG("");
-    return false;
-}
-
-} // namespace ns3
-
diff --git a/src/internet/model/mptcp-scheduler-fastest-rtt.h b/src/internet/model/mptcp-scheduler-fastest-rtt.h
deleted file mode 100644
index 0e37368..0000000
--- a/src/internet/model/mptcp-scheduler-fastest-rtt.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#ifndef MPTCP_SCHEDULER_FASTEST_RTT_H
-#define MPTCP_SCHEDULER_FASTEST_RTT_H
-
-
-#include "ns3/mptcp-scheduler.h"
-#include "ns3/object.h"
-#include "ns3/ptr.h"
-#include "ns3/mptcp-scheduler-fastest-rtt.h"
-#include <vector>
-#include <list>
-
-namespace ns3
-{
-
-class MpTcpSocketBase;
-class MpTcpSubflow;
-
-class MpTcpSchedulerFastestRTT : public MpTcpScheduler
-{
-
-public:
-  static TypeId
-  GetTypeId (void);
-
-  MpTcpSchedulerFastestRTT();
-  virtual ~MpTcpSchedulerFastestRTT ();
-
-
-  void SetMeta(Ptr<MpTcpSocketBase> metaSock);
-
-  /**
-   * \brief This function is responsible for generating a list of packets to send
-   *   and to specify on which subflow to send.
-   *
-   *   These *mappings* will be passed on to the meta socket that will send them without altering the
-   *   mappings.
-   *   It is of utmost importance to generate a perfect mapping !!! Any deviation
-   *   from the foreseen mapping will trigger an error and crash the simulator
-   *
-   * \warn This function MUST NOT fiddle with metasockInternal
-   * subflowId: pair(start,size)
-   *
-   * TODO should take into account backup priorities of subflows
-   */
-  virtual bool GenerateMapping(int& activeSubflowArrayId, SequenceNumber64& dsn, uint16_t& length);
-
-  /**
-   * \return -1 if could not find a valid subflow, the subflow id otherwise
-   */
-  virtual int FindFastestSubflowWithFreeWindow() const;
-
-  /**
-  Return Index of subflow to use
-  */
-  virtual Ptr<MpTcpSubflow> GetSubflowToUseForEmptyPacket();
-
-protected:
-//  uint8_t  m_lastUsedFlowId;        //!< keep track of last used subflow
-  Ptr<MpTcpSocketBase> m_metaSock;  //!<
-};
-
-
-} // end of 'ns3'
-
-#endif /* MPTCP_SCHEDULER_ROUND_ROBIN_H */
diff --git a/src/internet/model/mptcp-scheduler-owd.cc b/src/internet/model/mptcp-scheduler-owd.cc
deleted file mode 100644
index d237bb0..0000000
--- a/src/internet/model/mptcp-scheduler-owd.cc
+++ /dev/null
@@ -1,348 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *
- */
-#include "ns3/mptcp-scheduler-owd.h"
-#include "ns3/mptcp-subflow.h"
-#include "ns3/mptcp-socket-base.h"
-#include "ns3/log.h"
-
-NS_LOG_COMPONENT_DEFINE ("MpTcpSchedulerOwd");
-
-
-namespace ns3
-{
-
-NS_OBJECT_ENSURE_REGISTERED (MpTcpSchedulerOwd);
-
-
-SubflowPair::SubflowPair () :
-    m_index (0)
-{
-    NS_LOG_FUNCTION_NOARGS ();
-}
-
-bool
-SubflowPair::RecordStart (Ptr<MpTcpSubflow> sf, Time start, int *cookie)
-{
-    NS_ASSERT_MSG (m_index < 1, "too many RecordStart calls");
-
-    m_subflows[m_index++] = std::make_pair (sf, start);
-    return true;
-}
-
-
-void
-SubflowPair::FinishRound (Ptr<MpTcpSubflow> sf, int cookie, uint64_t nanosecs)
-{
-
-
-    /*
-        m_subflows[0] (m_subflows[1]) should contain lowest (highest) id
-    */
-    NS_LOG_FUNCTION (cookie << nanosecs);
-
-    NS_ASSERT_MSG ( m_index == 2, "RecordStart should have been called exactly twice !" );
-    //! need to compute delta,
-
-
-    Time remoteDelta =  NanoSeconds(nanosecs);
-
-    // order the m_subflows
-    // m_subflows[0] (m_subflows[1]) should contain lowest (highest) id
-    // so that computations make sense between iterations
-    if(m_subflows[0].first->GetLocalId() > m_subflows[1].first->GetLocalId())
-    {
-        std::swap (m_subflows[0], m_subflows[1]);
-    }
-
-    if (m_subflows[0].first == sf) {
-        remoteDelta = -remoteDelta;
-    }
-
-    Time delta = (m_subflows[1].second - m_subflows[0].second);
-
-    NS_LOG_DEBUG ("Computed delta = " << delta);
-    // adding a new measurement
-    m_estimator.Measurement (delta);
-
-    m_index = 0;
-}
-
-
-
-//m_timer = Simulator::Schedule ();
-
-
-
-
-
-
-
-
-
-TypeId
-MpTcpSchedulerOwd::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::MpTcpSchedulerOwd")
-    .SetParent<MpTcpScheduler> ()
-    //
-    .AddConstructor<MpTcpSchedulerOwd> ()
-  ;
-  return tid;
-}
-
-
-//Ptr<MpTcpSocketBase> metaSock
-MpTcpSchedulerOwd::MpTcpSchedulerOwd() :
-  MpTcpScheduler(),
-  m_lastUsedFlowId(0),
-  m_metaSock(0)
-{
-  NS_LOG_FUNCTION(this);
-//  NS_ASSERT(m_metaSock);
-}
-
-MpTcpSchedulerOwd::~MpTcpSchedulerOwd (void)
-{
-  NS_LOG_FUNCTION(this);
-}
-
-
-void
-MpTcpSchedulerOwd::SetMeta (Ptr<MpTcpSocketBase> metaSock)
-{
-  NS_ASSERT(metaSock);
-  NS_ASSERT_MSG(m_metaSock == 0, "SetMeta already called");
-  m_metaSock = metaSock;
-//  m_firstUnmappedDsn = m_metaSock->m_txBuffer->HeadSequence();
-}
-
-//uint16_t
-Ptr<MpTcpSubflow>
-MpTcpSchedulerOwd::GetSubflowToUseForEmptyPacket ()
-{
-  NS_ASSERT(m_metaSock->GetNActiveSubflows() > 0 );
-  return  m_metaSock->GetSubflow(0);
-//  m_lastUsedFlowId = (m_lastUsedFlowId + 1) % m_metaSock->GetNActiveSubflows();
-//  return m_metaSock->GetSubFlow(m_lastUsedFlowId);
-}
-
-//void
-//MpTcpSchedulerOwd::NotifyOfMove (Ptr<MpTcpSubflow> subflow)
-//{
-//
-//
-//}
-
-
-// TODO this will be solved
-// We assume scheduler can't send data on subflows, so it can just generate mappings
-//std::vector< std::pair<uint8_t, MappingList>
-// std::pair< start,size , subflow>
-// ca g√©n√®re les mappings ensuite
-bool
-MpTcpSchedulerOwd::GenerateMapping(
-    int& activeSubflowArrayId, SequenceNumber64& dsn, uint16_t& length
-)
-{
-    NS_LOG_FUNCTION(this);
-    NS_ASSERT(m_metaSock);
-
-    //!
-    int nbOfSubflows = m_metaSock->GetNActiveSubflows();
-    int attempt = 0;
-    uint32_t amountOfDataToSend = 0;
-
-    //! Tx data not sent to subflows yet
-    SequenceNumber32 metaNextTxSeq = m_metaSock->m_nextTxSequence;
-
-    amountOfDataToSend = m_metaSock->m_txBuffer->SizeFromSequence( metaNextTxSeq );
-
-    uint32_t metaWindow = m_metaSock->AvailableWindow();
-
-    NS_LOG_DEBUG("TxData to send=" << amountOfDataToSend  << "; Available meta window=" << metaWindow);
-    if(amountOfDataToSend <= 0)
-    {
-      NS_LOG_DEBUG("Nothing to send from meta");
-      return false;
-    }
-
-
-    if (metaWindow <= 0)
-    {
-        NS_LOG_DEBUG("No meta window available (TODO should be in persist state ?)");
-        return false; // TODO ?
-    }
-
-    NS_LOG_DEBUG ("Able to choose between [" << nbOfSubflows << "] subflows");
-    while (attempt < nbOfSubflows)
-    {
-        attempt++;
-        m_lastUsedFlowId = (m_lastUsedFlowId + 1) % nbOfSubflows;
-        Ptr<MpTcpSubflow> subflow = m_metaSock->GetSubflow(m_lastUsedFlowId);
-        uint32_t subflowWindow = subflow->AvailableWindow();
-
-        NS_LOG_DEBUG("subflow [" << m_lastUsedFlowId << "] AvailableWindow=" << subflowWindow);
-        uint32_t canSend = std::min( subflowWindow, metaWindow);
-
-        //! Can't send more than SegSize
-        //metaWindow en fait on s'en fout du SegSize ?
-        if(canSend > 0)
-        {
-
-            activeSubflowArrayId = m_lastUsedFlowId;
-            dsn = metaNextTxSeq;
-            canSend = std::min(canSend, amountOfDataToSend);
-            NS_LOG_DEBUG("min(candSend=" << canSend << ", amountOfDataToSend=" << amountOfDataToSend << ")");
-            // For now we limit ourselves to a per packet basis
-            length = std::min(canSend, subflow->GetSegSize());
-            NS_LOG_DEBUG("length=" << length << "=min(candSend=" << canSend << ", segSize=" << subflow->GetSegSize() << ")");
-            return true;
-        }
-    }
-    NS_LOG_DEBUG("");
-    return false;
-}
-
-#if 0
-int
-MpTcpSchedulerOwd::GenerateMappings(MappingVector& mappings)
-{
-  NS_LOG_FUNCTION(this);
-  NS_ASSERT_MSG(m_metaSock,"Call SetMeta() before generating a mapping");
-
-//  #if 0
-  // THis is worng since it depends on what's next
-//  if( m_metaSock->m_txBuffer->Size() == 0) {
-//    NS_LOG_LOGIC("Nothing to send");
-//    return 0;
-//  }
-
-//  uint32_t amountOfDataToSend     = m_metaSock->m_txBuffer->SizeFromSequence(m_metaSock->m_nextTxSequence);
-  SequenceNumber32 metaNextTxSeq = m_metaSock->m_nextTxSequence;
-//  uint8_t i = 0;
-  uint32_t amountOfDataToSend = 0;
-  uint32_t window = m_metaSock->AvailableWindow();
-
-  if(window <= 0)
-  {
-    NS_LOG_DEBUG("No window available [" << window << "] (TODO shoulb be in persist state ?)");
-    return -1; // TODO ?
-  }
-
-//  NS_LOG_DEBUG()metaNextTxSeq
-
-  // TODO rewrite pr que cela fasse comme dans
-  // cette boucle sert √† rien
-  // TODO on ne veut g√©n√©rer des mappings que si besoin est .
-  // Par exemple lors d'une retransmission ca va planter
-  int i = 0;
-  for(
-      ;
-    i < (int)m_metaSock->GetNActiveSubflows()
-    ;
-    i++, m_lastUsedFlowId = (m_lastUsedFlowId + 1) % m_metaSock->GetNActiveSubflows()
-    )
-  {
-//    uint32_t left = m_metaSock->m_txBuffer->SizeFromSequence( metaNextTxSeq );
-    uint32_t left = m_metaSock->m_txBuffer->SizeFromSequence( metaNextTxSeq );
-    if(left <= 0)
-    {
-      NS_LOG_DEBUG("Nothing to send from meta");
-      return 0;
-    }
-
-    NS_LOG_DEBUG("Meta Tx to send:" << left
-              << " over [" << (int)m_metaSock->GetNActiveSubflows() << "] active subflow(s)"
-              );
-
-
-    // TODO check how the windows work
-    //m_metaSock->
-    Ptr<MpTcpSubflow> sf = m_metaSock->GetSubflow(m_lastUsedFlowId);
-    uint32_t window = sf->AvailableWindow(); // Get available window size
-//    sf->DumpInfo();
-
-      NS_LOG_LOGIC ("MpTcpSubflow " << sf << " SendPendingData" <<
-//          " w " << w <<
-//          " rxwin " << sf->m_rWnd <<
-//          " segsize " << sf->m_segmentSize <<
-          " nextTxSeq " << sf->m_nextTxSequence <<
-          " highestRxAck " << sf->m_txBuffer->HeadSequence () <<
-          " pd->Size " << sf->m_txBuffer->Size () <<
-          " pd->SFS " << sf->m_txBuffer->SizeFromSequence (sf->m_nextTxSequence)
-          );
-
-      // Quit if send disallowed
-//    if (sf->m_shutdownSend)
-//      {
-//        continue;
-////          m_errno = ERROR_SHUTDOWN;
-////          return false;
-//      }
-      // Stop sending if we need to wait for a larger Tx window (prevent silly window syndrome)
-//      if (w < sf->m_segmentSize && m_txBuffer->SizeFromSequence(m_nextTxSequence) > w)
-//        {
-//          break; // No more
-//        }
-
-    amountOfDataToSend = 0;
-    MpTcpMapping mapping;
-//    //is protected
-
-//    if( window > 0)
-//    {
-
-    // TODO
-
-    NS_LOG_DEBUG("subflow Window available [" << window << "]");
-    amountOfDataToSend = std::min( window, left );
-
-    //! Can't send more than SegSize
-    amountOfDataToSend = std::min( amountOfDataToSend , sf->GetSegSize());
-    NS_LOG_DEBUG("Amount of data to send [" << amountOfDataToSend  << "]");
-    if(amountOfDataToSend <= 0)
-    {
-      NS_LOG_DEBUG("Most likely window is equal to 0 which should not happen");
-      continue;
-    }
-    NS_ASSERT_MSG(amountOfDataToSend > 0, "Most likely window is equal to 0 which should not happen");
-//    }
-//    else {
-//        NS_LOG_DEBUG("No window available [" << window << "]");
-//      continue;
-//    }
-
-    mapping.SetHeadDSN( metaNextTxSeq);
-    mapping.SetMappingSize(amountOfDataToSend);
-//    NS_LOG_DEBUG("Generated mapping " << mapping);
-    mappings.push_back( std::make_pair( i, mapping) );
-    metaNextTxSeq += amountOfDataToSend;
-//    m_lastUsedFlowId = (m_lastUsedFlowId + 1) %m_metaSock->GetNActiveSubflows();
-  }
-//  #endif
-
-  return 0;
-}
-#endif
-
-
-
-} // end of 'ns3'
diff --git a/src/internet/model/mptcp-scheduler-owd.h b/src/internet/model/mptcp-scheduler-owd.h
deleted file mode 100644
index 45bc7d5..0000000
--- a/src/internet/model/mptcp-scheduler-owd.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *
- */
-#ifndef MPTCP_SCHEDULER_OWD_H
-#define MPTCP_SCHEDULER_OWD_H
-
-
-#include "ns3/mptcp-scheduler.h"
-#include "ns3/object.h"
-#include "ns3/ptr.h"
-#include "ns3/mptcp-scheduler-round-robin.h"
-#include "ns3/rtt-estimator.h"
-#include "ns3/event-id.h"
-#include <vector>
-#include <list>
-
-namespace ns3
-{
-
-class RttMeanDeviation;
-class MpTcpSocketBase;
-class MpTcpSubflow;
-
-
-class ProbingRequest : public Object
-{
-public:
-    ProbingRequest ();
-    ~ProbingRequest ();
-};
-
-/**
- * This class contains characteristics of a pair of subflows
- * Estimations are always made from low to high id,
- * TODO copy latex code here
- */
-class SubflowPair : public Object
-{
-  public:
-    SubflowPair ();
-
-//    RecordResult ();
-    /**
-     *
-     * \param cookie Returned cookie to use
-     *
-     * \return True if it's ok to start
-     */
-    bool RecordStart (Ptr<MpTcpSubflow> sf, Time start,int *cookie);
-
-
-    /**
-     * Called upon reception of a DeltaOWD option answer
-     * should be received on subflow which
-     * \param sf To be able to rearm timer
-     */
-    void FinishRound (Ptr<MpTcpSubflow> sf, int cookie, uint64_t nanosec);
-
-    EventId m_timer;
-    // TODO utiliser un estimator qui
-    RttMeanDeviation m_estimator; /* rename into DelayEstimator ? */
-  protected:
-
-
-    std::pair<Ptr<MpTcpSubflow>, Time> m_subflows[2];    /* */
-    int m_index;    /**!< current index of m_subflows */
-
-};
-
-class MpTcpSchedulerOwd
-//: public Object
-: public MpTcpScheduler
-{
-
-public:
-  static TypeId
-  GetTypeId (void);
-
-  MpTcpSchedulerOwd();
-  virtual ~MpTcpSchedulerOwd ();
-
-
-  void SetMeta(Ptr<MpTcpSocketBase> metaSock);
-
-  /**
-   * \brief This function is responsible for generating a list of packets to send
-   *   and to specify on which subflow to send.
-   *
-   *   These *mappings* will be passed on to the meta socket that will send them without altering the
-   *   mappings.
-   *   It is of utmost importance to generate a perfect mapping !!! Any deviation
-   *   from the foreseen mapping will trigger an error and crash the simulator
-   *
-   * \warn This function MUST NOT fiddle with metasockInternal
-   * subflowId: pair(start,size)
-   *
-   * TODO should take into account backup priorities of subflows
-  */
-  virtual bool GenerateMapping(int& activeSubflowArrayId, SequenceNumber64& dsn, uint16_t& length);
-  /**
-  */
-  // TODO
-  // chooseSubflowForRetransmit
-
-  /**
-  Return Index of subflow to use
-  */
-  virtual Ptr<MpTcpSubflow> GetSubflowToUseForEmptyPacket ();
-
-
-//  std::map<> ;
-  std::list<EventId> m_timers;  /**< */
-protected:
-  uint8_t  m_lastUsedFlowId;        //!< keep track of last used subflow
-  Ptr<MpTcpSocketBase> m_metaSock;  //!<
-};
-
-
-} // end of 'ns3'
-
-#endif /* MPTCP_SCHEDULER_ROUND_ROBIN_H */
diff --git a/src/internet/model/mptcp-scheduler-round-robin.cc b/src/internet/model/mptcp-scheduler-round-robin.cc
deleted file mode 100644
index aac54fa..0000000
--- a/src/internet/model/mptcp-scheduler-round-robin.cc
+++ /dev/null
@@ -1,276 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#include "ns3/mptcp-scheduler-round-robin.h"
-#include "ns3/mptcp-subflow.h"
-#include "ns3/mptcp-socket-base.h"
-#include "ns3/log.h"
-
-NS_LOG_COMPONENT_DEFINE("MpTcpSchedulerRoundRobin");
-
-
-
-namespace ns3
-{
-
-NS_OBJECT_ENSURE_REGISTERED (MpTcpSchedulerRoundRobin);
-
-TypeId
-MpTcpSchedulerRoundRobin::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::MpTcpSchedulerRoundRobin")
-    .SetParent<MpTcpScheduler> ()
-    //
-    .AddConstructor<MpTcpSchedulerRoundRobin> ()
-  ;
-  return tid;
-}
-
-
-//Ptr<MpTcpSocketBase> metaSock
-MpTcpSchedulerRoundRobin::MpTcpSchedulerRoundRobin() :
-  MpTcpScheduler (),
-  m_lastUsedFlowId (0),
-  m_metaSock (0)
-{
-  NS_LOG_FUNCTION(this);
-//  NS_ASSERT(m_metaSock);
-}
-
-MpTcpSchedulerRoundRobin::~MpTcpSchedulerRoundRobin (void)
-{
-  NS_LOG_FUNCTION(this);
-}
-
-
-void
-MpTcpSchedulerRoundRobin::SetMeta(Ptr<MpTcpSocketBase> metaSock)
-{
-  NS_ASSERT(metaSock);
-  NS_ASSERT_MSG(m_metaSock == 0, "SetMeta already called");
-  m_metaSock = metaSock;
-//  m_firstUnmappedDsn = m_metaSock->m_txBuffer->HeadSequence();
-}
-
-//uint16_t
-Ptr<MpTcpSubflow>
-MpTcpSchedulerRoundRobin::GetSubflowToUseForEmptyPacket ()
-{
-  NS_ASSERT(m_metaSock->GetNActiveSubflows() > 0 );
-  return  m_metaSock->GetSubflow(0);
-//  m_lastUsedFlowId = (m_lastUsedFlowId + 1) % m_metaSock->GetNActiveSubflows();
-//  return m_metaSock->GetSubFlow(m_lastUsedFlowId);
-}
-
-
-// TODO this will be solved
-// We assume scheduler can't send data on subflows, so it can just generate mappings
-//std::vector< std::pair<uint8_t, MappingList>
-// std::pair< start,size , subflow>
-// ca g√©n√®re les mappings ensuite
-bool
-MpTcpSchedulerRoundRobin::GenerateMapping(int& activeSubflowArrayId, SequenceNumber64& dsn, uint16_t& length)
-{
-    NS_LOG_FUNCTION(this);
-    NS_ASSERT(m_metaSock);
-
-    //!
-    int nbOfSubflows = m_metaSock->GetNActiveSubflows();
-    int attempt = 0;
-    uint32_t amountOfDataToSend = 0;
-
-    //! Tx data not sent to subflows yet
-    SequenceNumber32 metaNextTxSeq = m_metaSock->m_nextTxSequence;
-
-    amountOfDataToSend = m_metaSock->m_txBuffer->SizeFromSequence( metaNextTxSeq );
-
-    uint32_t metaWindow = m_metaSock->AvailableWindow();
-
-    NS_LOG_DEBUG("TxData to send=" << amountOfDataToSend  << "; Available meta window=" << metaWindow);
-    if(amountOfDataToSend <= 0)
-    {
-      NS_LOG_DEBUG("Nothing to send from meta");
-      return false;
-    }
-
-
-    if(metaWindow <= 0)
-    {
-        NS_LOG_DEBUG("No meta window available (TODO should be in persist state ?)");
-        return false; // TODO ?
-    }
-
-    NS_LOG_DEBUG ("Able to choose between [" << nbOfSubflows << "] subflows");
-    while(attempt < nbOfSubflows)
-    {
-        attempt++;
-        m_lastUsedFlowId = (m_lastUsedFlowId + 1) % nbOfSubflows;
-        Ptr<MpTcpSubflow> subflow = m_metaSock->GetSubflow(m_lastUsedFlowId);
-        uint32_t subflowWindow = subflow->AvailableWindow();
-
-        NS_LOG_DEBUG("subflow [" << (int)m_lastUsedFlowId << "] " << subflow << " AvailableWindow=" << subflowWindow);
-        uint32_t canSend = std::min( subflowWindow, metaWindow);
-
-        //! Can't send more than SegSize
-        //metaWindow en fait on s'en fout du SegSize ?
-        if(canSend > 0)
-        {
-
-            activeSubflowArrayId = m_lastUsedFlowId;
-            dsn = metaNextTxSeq;
-            canSend = std::min(canSend, amountOfDataToSend);
-            NS_LOG_DEBUG("subflow [" << (int)m_lastUsedFlowId << "]" 
-            << "min(canSend=" << canSend << ", amountOfDataToSend=" << amountOfDataToSend << ")");
-            // For now we limit ourselves to a per packet basis
-            length = std::min(canSend, subflow->GetSegSize());
-            NS_LOG_DEBUG("length=" << length << "=min(candSend=" << canSend << ", segSize=" << subflow->GetSegSize() << ")");
-            return true;
-        }
-    }
-    NS_LOG_DEBUG("dsds");
-    return false;
-}
-
-#if 0
-int
-MpTcpSchedulerRoundRobin::GenerateMappings(MappingVector& mappings)
-{
-  NS_LOG_FUNCTION(this);
-  NS_ASSERT_MSG(m_metaSock,"Call SetMeta() before generating a mapping");
-
-//  #if 0
-  // THis is worng since it depends on what's next
-//  if( m_metaSock->m_txBuffer->Size() == 0) {
-//    NS_LOG_LOGIC("Nothing to send");
-//    return 0;
-//  }
-
-//  uint32_t amountOfDataToSend     = m_metaSock->m_txBuffer->SizeFromSequence(m_metaSock->m_nextTxSequence);
-  SequenceNumber32 metaNextTxSeq = m_metaSock->m_nextTxSequence;
-//  uint8_t i = 0;
-  uint32_t amountOfDataToSend = 0;
-  uint32_t window = m_metaSock->AvailableWindow();
-
-  if(window <= 0)
-  {
-    NS_LOG_DEBUG("No window available [" << window << "] (TODO shoulb be in persist state ?)");
-    return -1; // TODO ?
-  }
-
-//  NS_LOG_DEBUG()metaNextTxSeq
-
-  // TODO rewrite pr que cela fasse comme dans
-  // cette boucle sert √† rien
-  // TODO on ne veut g√©n√©rer des mappings que si besoin est .
-  // Par exemple lors d'une retransmission ca va planter
-  int i = 0;
-  for(
-      ;
-    i < (int)m_metaSock->GetNActiveSubflows()
-    ;
-    i++, m_lastUsedFlowId = (m_lastUsedFlowId + 1) % m_metaSock->GetNActiveSubflows()
-    )
-  {
-//    uint32_t left = m_metaSock->m_txBuffer->SizeFromSequence( metaNextTxSeq );
-    uint32_t left = m_metaSock->m_txBuffer->SizeFromSequence( metaNextTxSeq );
-    if(left <= 0)
-    {
-      NS_LOG_DEBUG("Nothing to send from meta");
-      return 0;
-    }
-
-    NS_LOG_DEBUG("Meta Tx to send:" << left
-              << " over [" << (int)m_metaSock->GetNActiveSubflows() << "] active subflow(s)"
-              );
-
-
-    // TODO check how the windows work
-    //m_metaSock->
-    Ptr<MpTcpSubflow> sf = m_metaSock->GetSubflow(m_lastUsedFlowId);
-    uint32_t window = sf->AvailableWindow(); // Get available window size
-//    sf->DumpInfo();
-
-      NS_LOG_LOGIC ("MpTcpSubflow " << sf << " SendPendingData" <<
-//          " w " << w <<
-//          " rxwin " << sf->m_rWnd <<
-//          " segsize " << sf->m_segmentSize <<
-          " nextTxSeq " << sf->m_nextTxSequence <<
-          " highestRxAck " << sf->m_txBuffer->HeadSequence () <<
-          " pd->Size " << sf->m_txBuffer->Size () <<
-          " pd->SFS " << sf->m_txBuffer->SizeFromSequence (sf->m_nextTxSequence)
-          );
-
-      // Quit if send disallowed
-//    if (sf->m_shutdownSend)
-//      {
-//        continue;
-////          m_errno = ERROR_SHUTDOWN;
-////          return false;
-//      }
-      // Stop sending if we need to wait for a larger Tx window (prevent silly window syndrome)
-//      if (w < sf->m_segmentSize && m_txBuffer->SizeFromSequence(m_nextTxSequence) > w)
-//        {
-//          break; // No more
-//        }
-
-    amountOfDataToSend = 0;
-    MpTcpMapping mapping;
-//    //is protected
-
-//    if( window > 0)
-//    {
-
-    // TODO
-
-    NS_LOG_DEBUG("subflow Window available [" << window << "]");
-    amountOfDataToSend = std::min( window, left );
-
-    //! Can't send more than SegSize
-    amountOfDataToSend = std::min( amountOfDataToSend , sf->GetSegSize());
-    NS_LOG_DEBUG("Amount of data to send [" << amountOfDataToSend  << "]");
-    if(amountOfDataToSend <= 0)
-    {
-      NS_LOG_DEBUG("Most likely window is equal to 0 which should not happen");
-      continue;
-    }
-    NS_ASSERT_MSG(amountOfDataToSend > 0, "Most likely window is equal to 0 which should not happen");
-//    }
-//    else {
-//        NS_LOG_DEBUG("No window available [" << window << "]");
-//      continue;
-//    }
-
-    mapping.SetHeadDSN( metaNextTxSeq);
-    mapping.SetMappingSize(amountOfDataToSend);
-//    NS_LOG_DEBUG("Generated mapping " << mapping);
-    mappings.push_back( std::make_pair( i, mapping) );
-    metaNextTxSeq += amountOfDataToSend;
-//    m_lastUsedFlowId = (m_lastUsedFlowId + 1) %m_metaSock->GetNActiveSubflows();
-  }
-//  #endif
-
-  return 0;
-}
-#endif
-
-
-
-} // end of 'ns3'
diff --git a/src/internet/model/mptcp-scheduler-round-robin.h b/src/internet/model/mptcp-scheduler-round-robin.h
deleted file mode 100644
index cc7c067..0000000
--- a/src/internet/model/mptcp-scheduler-round-robin.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#ifndef MPTCP_SCHEDULER_ROUND_ROBIN_H
-#define MPTCP_SCHEDULER_ROUND_ROBIN_H
-
-
-#include "ns3/mptcp-scheduler.h"
-#include "ns3/object.h"
-#include "ns3/ptr.h"
-#include "ns3/mptcp-scheduler-round-robin.h"
-#include <vector>
-#include <list>
-
-namespace ns3
-{
-
-class MpTcpSocketBase;
-class MpTcpSubflow;
-
-class MpTcpSchedulerRoundRobin
-//: public Object
-: public MpTcpScheduler
-{
-
-public:
-  static TypeId
-  GetTypeId (void);
-
-  MpTcpSchedulerRoundRobin();
-  virtual ~MpTcpSchedulerRoundRobin ();
-
-
-  void SetMeta(Ptr<MpTcpSocketBase> metaSock);
-
-  /**
-   * \brief This function is responsible for generating a list of packets to send
-   *   and to specify on which subflow to send.
-   *
-   *   These *mappings* will be passed on to the meta socket that will send them without altering the
-   *   mappings.
-   *   It is of utmost importance to generate a perfect mapping !!! Any deviation
-   *   from the foreseen mapping will trigger an error and crash the simulator
-   *
-   * \warn This function MUST NOT fiddle with metasockInternal
-   * subflowId: pair(start,size)
-   *
-   * TODO should take into account backup priorities of subflows
-  */
-  virtual bool GenerateMapping(int& activeSubflowArrayId, SequenceNumber64& dsn, uint16_t& length);
-  /**
-  */
-  // TODO
-  // chooseSubflowForRetransmit
-
-  /**
-  Return Index of subflow to use
-  */
-  virtual Ptr<MpTcpSubflow> GetSubflowToUseForEmptyPacket();
-
-protected:
-  uint8_t  m_lastUsedFlowId;        //!< keep track of last used subflow
-  Ptr<MpTcpSocketBase> m_metaSock;  //!<
-};
-
-
-} // end of 'ns3'
-
-#endif /* MPTCP_SCHEDULER_ROUND_ROBIN_H */
diff --git a/src/internet/model/mptcp-scheduler.h b/src/internet/model/mptcp-scheduler.h
deleted file mode 100644
index 7210e5d..0000000
--- a/src/internet/model/mptcp-scheduler.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-#ifndef MPTCP_SCHEDULER_H
-#define MPTCP_SCHEDULER_H
-
-
-#include <stdint.h>
-#include "ns3/ptr.h"
-#include "ns3/object.h"
-#include "ns3/sequence-number.h"
-//#include "ns3/mp-tcp-socket-base.h"
-
-
-namespace ns3
-{
-
-class MpTcpSocketBase;
-class MpTcpSubflow;
-
-/**
- * This class is responsible for
- *
- * The mptcp linux 0.90 scheduler is composed of mainly 2 functions:
- * -get_available_subflow
- * -get_next_segment
- *
-* Here we wanted to let a maximum number of possibilities for testing, for instance:
-* - you can generate DSS for data that is not in the meta Tx buffer yet (in order to minimize the number of DSS sent).
-* - you can send the
-*
-* The scheduler maps a dsn range to a subflow. It does not map the dsn to an ssn: this is done
-* by the subflow when it actually receives the Tx data.
-*
-* \warn The decoupling between dsn & ssn mapping may prove hard to debug. There are
-* some checks but you should be especially careful when writing a new scheduler.
- */
-class MpTcpScheduler : public Object
-{
-
-public:
-
-  virtual ~MpTcpScheduler() {}
-//  static TypeId
-//  GetTypeId (void);
-//TypeId
-//MpTcpScheduler::GetTypeId (void)
-//{
-//  static TypeId tid = TypeId ("ns3::MpTcpSchedulerRoundRobin")
-//    .SetParent<Object> ()
-//    //
-//    .AddConstructor<MpTcpScheduler> ()
-//  ;
-//  return tid;
-//}
-
-  /**
-   * Warns scheduler when 
-   */
-  virtual void NotifyOfMove (Ptr<MpTcpSubflow> subflow) 
-  {
-    //! empty
-  }
-
-  /**
-   * \param activeSubflowArrayId
-   * \param uint16_t
-   * \return true if could generate a mapping
-   * \see MpTcpSocketBase::SendPendingData
-   */
-  virtual bool GenerateMapping(
-        int& activeSubflowArrayId, SequenceNumber64& dsn, uint16_t& length
-                              ) = 0;
-
-  virtual void SetMeta(Ptr<MpTcpSocketBase> metaSock) = 0;
-  /**
-  \brief
-  \return Subflow on which to send
-  **/
-//  virtual Ptr<MpTcpSubflow> GetSubflowToUse(Ptr<MpTcpSocketBase> metaSock);
-
-};
-
-
-}
-
-
-#endif /* MPTCP_SCHEDULER_H */
diff --git a/src/internet/model/mptcp-socket-base.cc b/src/internet/model/mptcp-socket-base.cc
deleted file mode 100644
index 0cb0b72..0000000
--- a/src/internet/model/mptcp-socket-base.cc
+++ /dev/null
@@ -1,3225 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#undef NS_LOG_APPEND_CONTEXT
-#define NS_LOG_APPEND_CONTEXT \
-  if (m_node) { std::clog << Simulator::Now ().GetSeconds () << " [node " << m_node->GetId () << "] "; }
-
-#include <algorithm>
-#include <stdlib.h>
-#include <iostream>
-#include <fstream>
-#include <map>
-#include "ns3/abort.h"
-#include "ns3/log.h"
-#include "ns3/string.h"
-#include "ns3/mptcp-socket-base.h"
-#include "ns3/tcp-l4-protocol.h"
-#include "ns3/ipv4-l3-protocol.h"
-#include "ns3/error-model.h"
-#include "ns3/point-to-point-channel.h"
-#include "ns3/point-to-point-net-device.h"
-#include "ns3/pointer.h"
-#include "ns3/drop-tail-queue.h"
-#include "ns3/object-vector.h"
-#include "ns3/mptcp-scheduler-round-robin.h"
-#include "ns3/mptcp-id-manager.h"
-#include "ns3/mptcp-id-manager-impl.h"
-#include "ns3/mptcp-subflow.h"
-#include "ns3/tcp-option-mptcp.h"
-#include "ns3/callback.h"
-#include "ns3/trace-helper.h"
-#include "ns3/mptcp-scheduler-owd.h"
-
-
-using namespace std;
-
-
-namespace ns3
-{
-NS_LOG_COMPONENT_DEFINE("MpTcpSocketBase");
-
-NS_OBJECT_ENSURE_REGISTERED(MpTcpSocketBase);
-
-
-static inline
-SequenceNumber32 SEQ64TO32(SequenceNumber64 seq)
-{
-    //!
-    return SequenceNumber32( seq.GetValue());
-}
-
-static inline
-SequenceNumber64 SEQ32TO64(SequenceNumber32 seq)
-{
-    //!
-    return SequenceNumber64( seq.GetValue());
-}
-
-
-//
-//  void GetMapping (uint64_t& dsn, uint32_t& ssn, uint16_t& length) const;
-//
-//  /**
-//   * \brief
-//   * \param trunc_to_32bits Set to true to send a 32bit DSN
-//   * \warn Mapping can be set only once, otherwise it will crash ns3
-//   */
-
-//! wrapper function
-static inline
-MpTcpMapping
-GetMapping(Ptr<TcpOptionMpTcpDSS> dss)
-{
-    MpTcpMapping mapping;
-    uint64_t dsn;
-    uint32_t ssn;
-    uint16_t length;
-
-    dss->GetMapping (dsn, ssn, length);
-    mapping.SetHeadDSN ( SequenceNumber64(dsn));
-    mapping.SetMappingSize(length);
-    mapping.MapToSSN( SequenceNumber32(ssn));
-    return mapping;
-}
-
-
-
-TypeId
-MpTcpSocketBase::GetTypeId (void)
-{
-  static TypeId tid = TypeId("ns3::MpTcpSocketBase")
-      // To some extent, would ideally derive directly from TcpSocket ?
-      .SetParent<TcpSocketBase>()
-      .AddConstructor<MpTcpSocketBase>()
-      .AddAttribute ("SubflowType",
-               "MPTCP subflow type.",
-               TypeIdValue (MpTcpSubflow::GetTypeId ()),
-               MakeTypeIdAccessor (&MpTcpSocketBase::m_subflowTypeId),
-               MakeTypeIdChecker ())
-      .AddAttribute ("Scheduler",
-               "How to generate the mappings",
-               TypeIdValue (MpTcpSchedulerRoundRobin::GetTypeId ()),
-               MakeTypeIdAccessor (&MpTcpSocketBase::m_schedulerTypeId),
-               MakeTypeIdChecker ())
-      //TODO remove ?
-      .AddAttribute ("KeyGeneratedIDSN", "Generate IDSN from the key",
-               BooleanValue (false),
-               MakeBooleanAccessor (&MpTcpSocketBase::m_generatedIdsn),
-               MakeBooleanChecker ())
-  
-    // TODO rehabilitate
-//      .AddAttribute("SchedulingAlgorithm", "Algorithm for data distribution between m_subflows", EnumValue(Round_Robin),
-//          MakeEnumAccessor(&MpTcpSocketBase::SetDataDistribAlgo),
-//          MakeEnumChecker(Round_Robin, "Round_Robin"))
-    // Would this be cleaner ? perfs ?
-//      .AddAttribute("Subflows", "The list of subflows associated to this protocol.",
-//          ObjectVectorValue(),
-//          MakeObjectVectorAccessor(&MpTcpSocketBase::m_subflows),
-//          MakeObjectVectorChecker<MpTcpSocketBase>())
-//        )
-    ;
-  return tid;
-}
-
-
-static const std::string containerNames[MpTcpSocketBase::Maximum] = {
-  "Established",
-  "Others",
-  "Closing"
-//  ,
-//  "Maximum"
-
-};
-
-
-/*
-When doing this 
-CompleteConstruct
-*/
-//MpTcpSocketBase::MpTcpSocketBase(const TcpSocketBase& sock) :
-//  TcpSocketBase(sock),
-//  m_server (true), // TODO remove or use it
-//  m_peerKey (0),
-//  m_peerToken (0),
-//  m_doChecksum(false),
-//  m_receivedDSS(false),
-//  // TODO here would be best to retrieve default from static GetTypeId 
-//  m_subflowTypeId (MpTcpSubflow::GetTypeId ()),
-//  m_schedulerTypeId (MpTcpSchedulerRoundRobin::GetTypeId () )
-////  , m_localSubflowUid (0)
-////    MpTcpSocketBase()   //! delegatin constructors only available in C++11
-//{
-//    //
-//    NS_LOG_FUNCTION(this);
-//    NS_LOG_LOGIC("Copying from TcpSocketBase");
-//
-//    // TODO make it configurable
-//    m_remoteIdManager = Create<MpTcpPathIdManagerImpl>();
-//    m_localIdManager = Create<MpTcpPathIdManagerImpl>();
-//
-//    m_tcb->m_socket = this;
-//    CreateScheduler (m_schedulerTypeId);
-//}
-
-
-
-MpTcpSocketBase& 
-MpTcpSocketBase::operator =(const TcpSocketBase& s)
-{
-  TcpSocketBase::operator=(s);
-  return *this;
-}
-
-/* Never occurs right ? should prevent it ? */
-MpTcpSocketBase::MpTcpSocketBase(const MpTcpSocketBase& sock) :
-  TcpSocketBase (sock),
-  m_server(sock.m_server), //! true, if I am forked
-  m_peerKey(sock.m_peerKey),
-  m_peerToken(sock.m_peerToken),
-  m_doChecksum(sock.m_doChecksum),
-  m_subflowConnectionSucceeded(sock.m_subflowConnectionSucceeded),
-  m_subflowConnectionFailure(sock.m_subflowConnectionFailure),
-  m_joinRequest(sock.m_joinRequest),
-  m_receivedDSS(sock.m_receivedDSS),
-  m_subflowCreated(sock.m_subflowCreated),
-//  m_localSubflowUid (sock.m_localSubflowUid),
-  m_subflowTypeId (sock.m_subflowTypeId),
-  m_schedulerTypeId (sock.m_schedulerTypeId)
-
-{
-  NS_LOG_FUNCTION(this);
-  NS_LOG_LOGIC ("Invoked the copy constructor");
-  //! Scheduler may have some states, thus generate a new one
-  m_remoteIdManager = Create<MpTcpPathIdManagerImpl>();
-  m_localIdManager = Create<MpTcpPathIdManagerImpl>();
-
-  // TODO remove
-  m_tcb->m_socket = this;
-
-  // TODO
-  CreateScheduler ();
-//  CreateScheduler (m_schedulerTypeId);
-
-  //! TODO here I should generate a new Key
-}
-
-
-// TODO implement a copy constructor
-MpTcpSocketBase::MpTcpSocketBase () :
-  TcpSocketBase(),
-  m_server(true),
-  m_peerKey(0),
-  m_peerToken(0),
-  m_doChecksum(false),
-  m_receivedDSS(false)
-
-  // TODO careful not to use these typeids in the constructor
-  // as they are not setup yet, it should take into account the attributes
-//  m_subflowTypeId(MpTcpSubflow::GetTypeId ()),
-//  m_schedulerTypeId(MpTcpSchedulerRoundRobin::GetTypeId())
-{
-  NS_LOG_FUNCTION(this);
-
-  //not considered as an Object
-  m_remoteIdManager = Create<MpTcpPathIdManagerImpl>();
-  m_localIdManager = Create<MpTcpPathIdManagerImpl>();
-
-  // Should be safe to remove
-//  m_tcb->m_socket = this;
-  
-
-
-
-  m_subflowConnectionSucceeded  = MakeNullCallback<void, Ptr<MpTcpSubflow> >();
-  m_subflowConnectionFailure    = MakeNullCallback<void, Ptr<MpTcpSubflow> >();
-}
-
-
-MpTcpSocketBase::~MpTcpSocketBase(void)
-{
-  NS_LOG_FUNCTION(this);
-  m_node = 0;
-
-  if( m_scheduler )
-  {
-
-  }
-  /*
-   * Upon Bind, an Ipv4Endpoint is allocated and set to m_endPoint, and
-   * DestroyCallback is set to TcpSocketBase::Destroy. If we called
-   * m_tcp->DeAllocate, it will destroy its Ipv4EndpointDemux::DeAllocate,
-   * which in turn destroys my m_endPoint, and in turn invokes
-   * TcpSocketBase::Destroy to nullify m_node, m_endPoint, and m_tcp.
-   */
-//  if (m_endPoint != 0)
-//    {
-//      NS_ASSERT(m_tcp != 0);
-//      m_tcp->DeAllocate(m_endPoint);
-//      NS_ASSERT(m_endPoint == 0);
-//    }
-//  m_tcp = 0;
-//  CancelAllSubflowTimers();
-//  NS_LOG_INFO(Simulator::Now().GetSeconds() << " ["<< this << "] ~MpTcpSocketBase ->" << m_tcp );
-
-  m_subflowConnectionSucceeded = MakeNullCallback<void, Ptr<MpTcpSubflow> >();
-  m_subflowCreated = MakeNullCallback<void, Ptr<MpTcpSubflow> >();
-  m_subflowConnectionSucceeded = MakeNullCallback<void, Ptr<MpTcpSubflow> >();
-}
-
-
-bool
-MpTcpSocketBase::AddLocalId (uint8_t *addrId, const Address& address)
-{
-  NS_LOG_FUNCTION (address);
-  return m_localIdManager->AddLocalId (addrId, address);
-}
-
-bool
-MpTcpSocketBase::AddRemoteId (uint8_t addrId, const Address& address)
-{
-  NS_LOG_FUNCTION (address);
-  return m_remoteIdManager->AddId (addrId, address);
-}
-
-
-void
-MpTcpSocketBase::CreateScheduler (
-//TypeId schedulerTypeId
-)
-{
-  TypeId schedulerTypeId = m_schedulerTypeId;
-  NS_LOG_FUNCTION(this << schedulerTypeId);
-  NS_LOG_WARN("Overriding scheduler choice to RoundRobin");
-  ObjectFactory schedulerFactory;
-//  schedulerTypeId = MpTcpSchedulerFastestRTT;
-
-//  schedulerTypeId = MpTcpSchedulerRoundRobin::GetTypeId();
-  schedulerFactory.SetTypeId(schedulerTypeId);
-  m_scheduler = schedulerFactory.Create<MpTcpScheduler>();
-  m_scheduler->SetMeta (this);
-}
-
-int
-MpTcpSocketBase::ConnectNewSubflow (const Address &local, const Address &remote)
-{
-  NS_ASSERT_MSG(InetSocketAddress::IsMatchingType(local) && InetSocketAddress::IsMatchingType(remote), "only support ipv4");
-
-  //!
-  NS_LOG_LOGIC("Trying to add a new subflow " << InetSocketAddress::ConvertFrom(local).GetIpv4()
-                << "->" << InetSocketAddress::ConvertFrom(remote).GetIpv4());
-
-
-
-  // TODO remove next line (but will cause a bug, likely because m_subflowTypeId is
-  // not constructed properly since MpTcpSocketBase creation is hackish
-  // and does not call CompleteConstruct
-  // TODO pb c'est la, les 2 ss flots se partagent le mm congestion control !!
-//  m_subflowTypeId = MpTcpSubflow::GetTypeId();
-//  Ptr<Socket> socket = m_tcp->CreateSocket( m_congestionControl->Fork(), m_subflowTypeId);
-  Ptr<Socket> socket = m_tcp->CreateSocket ( m_congestionControl->Fork(), m_subflowTypeId);
-  NS_ASSERT(socket);
-  Ptr<MpTcpSubflow> sf = DynamicCast<MpTcpSubflow>(socket);
-  NS_ASSERT (sf);
-  AddSubflow (sf);
-
-  // TODO account for this error as well ?
-  bool res = (sf->Bind(local) == 0);
-  NS_ASSERT (res);
-  int ret = sf->Connect(remote);
-
-  return ret;
-}
-
-uint64_t
-MpTcpSocketBase::GetLocalKey() const
-{
-  return m_mptcpLocalKey;
-}
-
-uint32_t
-MpTcpSocketBase::GetLocalToken() const
-{
-  return m_mptcpLocalToken;
-}
-
-uint32_t
-MpTcpSocketBase::GetPeerToken() const
-{
-  return m_peerToken;
-}
-
-uint64_t
-MpTcpSocketBase::GetPeerKey() const
-{
-  return m_peerKey;
-}
-
-
-//MpTcpAddressInfo info
-// Address info
-void
-MpTcpSocketBase::NotifyRemoteAddAddr (Address address)
-{
-
-  if (!m_onRemoteAddAddr.IsNull())
-  {
-    // TODO user should not have to deal with MpTcpAddressInfo , info.second
-    m_onRemoteAddAddr (this, address, 0);
-  }
-}
-
-
-bool
-MpTcpSocketBase::DoChecksum() const
-{
-  return false;
-}
-
-
-
-MpTcpSocketBase::SubflowList::size_type
-MpTcpSocketBase::GetNActiveSubflows () const
-{
-  return m_subflows[Established].size();
-}
-
-  //std::vector<MpTcpSubflow>::size_ uint8
-Ptr<MpTcpSubflow>
-MpTcpSocketBase::GetSubflow (uint8_t id) const
-{
-  NS_ASSERT_MSG(id < m_subflows[Established].size(), "Trying to get an unexisting subflow");
-  return m_subflows[Established][id];
-}
-
-// FROM remote AddrId or localAddrId
-Ptr<MpTcpSubflow>
-MpTcpSocketBase::GetSubflowFromAddressId (uint8_t addrId) const
-{
-  //!
-//  NS_FATAL_ERROR ("not implemented");
-  for(int i = 0; i < Maximum; ++i)
-  {
-//    Established
-//    NS_LOG_INFO("Closing all subflows in state [" << containerNames [i] << "]");
-    for( SubflowList::const_iterator it = m_subflows[i].begin(); it != m_subflows[i].end(); it++ )
-    {
-//      if ( it->GetMptcpId() == addrId) {
-//        return *id;
-//      }
-    }
-  }
-  return 0;
-}
-
-void
-MpTcpSocketBase::SetLocalKey (uint64_t localKey)
-{
-    NS_LOG_FUNCTION (this << localKey);
-//    uint32_t localToken;
-    uint64_t idsn;
-    m_mptcpLocalKey = localKey;
-     
-    GenerateTokenForKey ( HMAC_SHA1, m_mptcpLocalKey, &m_mptcpLocalToken, &idsn );
-    SequenceNumber32 sidsn ( (uint32_t) idsn);
-    
-
-    NS_LOG_DEBUG ("Server meta ISN = " << idsn << " from key " << localKey);
-    InitLocalISN (sidsn);
-}
-
-void
-MpTcpSocketBase::SetPeerKey (uint64_t remoteKey)
-{
-  NS_LOG_FUNCTION (this << remoteKey);
-//  NS_ASSERT( m_peerKey == 0);
-//  NS_ASSERT( m_state != CLOSED);
-  uint64_t idsn = 0;
-  m_peerKey = remoteKey;
-
-  // not  sure yet. Wait to see if SYN/ACK is acked
-//  NS_LOG_DEBUG("Peer key set to " << );
-
-// TODO use the one  from mptcp-crypo.h
-  GenerateTokenForKey (HMAC_SHA1, m_peerKey, &m_peerToken, &idsn);
-
-  NS_LOG_DEBUG ("Peer key/token set to " << m_peerKey << "/" << m_peerToken);
-
-//  SetTxHead(m_nextTxSequence);
-//  m_firstTxUnack = m_nextTxSequence;
-//  m_highTxMark = m_nextTxSequence;
-
-  // + 1 ?
-  NS_LOG_DEBUG("Setting idsn=" << idsn << " (thus RxNext=idsn + 1)");
-  InitPeerISN (SequenceNumber32( (uint32_t)idsn ));
-//  m_rxBuffer->SetNextRxSequence(SequenceNumber32( (uint32_t)idsn ) + SequenceNumber32(1));
-}
-
-
-
-// TODO this should get reestablished and process the option depending on the state ?
-//int
-//MpTcpSocketBase::ProcessOptionMpTcp(const Ptr<const TcpOption> opt)
-//{
-//   NS_FATAL_ERROR("disabled .");
-//}
-
-
-
-void
-MpTcpSocketBase::InitLocalISN (const SequenceNumber32& seq)
-{
-    //!
-    TcpSocketBase::InitLocalISN (seq);
-
-    /*
-    The SYN with MP_CAPABLE occupies the first octet of data sequence
-   space, although this does not need to be acknowledged at the
-   connection level until the first data is sent (see Section 3.3).*/
-    m_nextTxSequence++;
-    m_firstTxUnack = m_nextTxSequence;
-    m_highTxMark = m_nextTxSequence;
-    m_txBuffer->SetHeadSequence (m_nextTxSequence);
-}
-
-void
-MpTcpSocketBase::ProcessListen (Ptr<Packet> packet, const TcpHeader& mptcpHeader, const Address& fromAddress, const Address& toAddress)
-{
-  // TODO removed
-  NS_FATAL_ERROR("disabled");
-}
-
-
-/**
-TODO if without option create a NewReno
-TODO remove
-**/
-void
-MpTcpSocketBase::CompleteFork(
-  Ptr<const Packet> p,
-  const TcpHeader& mptcpHeader,
-  const Address& fromAddress,
-  const Address& toAddress
-)
-{
-  NS_LOG_FUNCTION(this);
-  NS_FATAL_ERROR("Disabled");
-  #if 0
-  #endif
-}
-
-
- // in fact it just calls SendPendingData()
-int
-MpTcpSocketBase::Send(Ptr<Packet> p, uint32_t flags)
-{
-  NS_LOG_FUNCTION(this);
-
-  //! This will check for established state
-  return TcpSocketBase::Send (p,flags);
-}
-
-
-// Receipt of new packet, put into Rx buffer
-// TODO should be called from subflows only
-void
-MpTcpSocketBase::ReceivedData(Ptr<Packet> p, const TcpHeader& mptcpHeader)
-{
-  // Just override parent's
-  // Does nothing
-  NS_FATAL_ERROR("Disabled");
-}
-
-//bool
-//MpTcpSocketBase::UpdateWindowSize (const TcpHeader& header)
-//{
-//  //!
-//  NS_LOG_FUNCTION(this);
-//  m_rWnd = header.GetWindowSize();
-//  NS_LOG_DEBUG("Meta Receiver window=" << m_rWnd);
-//  return true;
-//}
-
-
-/*
-A receiver MUST NOT shrink the right edge of the receive window (i.e.,
-DATA_ACK + receive window)
-   */
-//void
-//MpTcpSocketBase::SetRemoteWindow(uint32_t win_size)
-//{
-//  //No checks are done here
-//  NS_LOG_FUNCTION(" Updating remote window. New m_rWnd=" << win_size );
-//  m_rWnd = win_size;
-//
-//  // Go through all containers
-//  for(int i = 0; i < Maximum; ++i) {
-//
-////    Established
-////    NS_LOG_INFO("Closing all subflows in state [" << containerNames [i] << "]");
-//    for( SubflowList::const_iterator it = m_subflows[i].begin(); it != m_subflows[i].end(); it++ )
-//    {
-//      (*it)->m_rWnd = m_rWnd;
-//    }
-//
-//  }
-//
-//}
-
-//void
-//MpTcpSocketBase::DupAck( SequenceNumber32 dack,Ptr<MpTcpSubflow> sf, uint32_t count)
-//{
-//  //!
-//  NS_LOG_ERROR("TODO Duplicate ACK " << dack);
-//
-////  NS_LOG_WARN("TODO DupAck " << count);
-//  /*
-//  As discussed earlier, however, an MPTCP
-//   implementation MUST NOT treat duplicate ACKs with any MPTCP option,
-//   with the exception of the DSS option, as indications of congestion
-//
-//  and an MPTCP implementation SHOULD NOT send more than two
-//   duplicate ACKs
-//   */
-//}
-
-
-void
-MpTcpSocketBase::ReceivedAck(Ptr<Packet> packet, const TcpHeader& mptcpHeader)
-{
-  NS_FATAL_ERROR("Disabled");
-}
-
-/* this is called by TcpSocketBase::ReceivedAck when 3 out of order arrived for instance
-For now do nothing
-*/
-
-uint32_t
-MpTcpSocketBase::SendDataPacket(SequenceNumber32 seq, uint32_t maxSize, bool withAck)
-{
-//  NS_LOG_FUNCTION (this << "Should do nothing" << maxSize << withAck);
-//  NS_FATAL_ERROR("Disabled");
-    NS_LOG_WARN("Does nothing");
-  // Disabled
-  return 0;
-}
-
-
-
-
-/** Cut cwnd and enter fast recovery mode upon triple dupack TODO ?*/
-//void
-//MpTcpSocketBase::DupAck(const TcpHeader& t, uint32_t count)
-//{
-//  NS_ASSERT_MSG(false,"Should never be called. Use overloeaded dupack instead");
-//
-////  NS_LOG_LOGIC("DupAck " << count);
-////  NS_LOG_WARN("TODO DupAck " << count);
-////  if( count > 3)
-////  GetMeta()->OnSubflowDupAck(this);
-//
-//  //! Regerenate mappings for that
-//  //! Reset the m_nextTxSequence to the dupacked value
-//
-//
-////  NS_LOG_FUNCTION (this << "t " << count);
-////  if (count == m_retxThresh && !m_inFastRec)
-////    { // triple duplicate ack triggers fast retransmit (RFC2581, sec.3.2)
-////      m_ssThresh = std::max (2 * m_segmentSize, BytesInFlight () / 2);
-////      m_cWnd = m_ssThresh + 3 * m_segmentSize;
-////      m_inFastRec = true;
-////      NS_LOG_INFO ("Triple dupack. Entering fast recovery. Reset cwnd to " << m_cWnd << ", ssthresh to " << m_ssThresh);
-////      DoRetransmit ();
-////    }
-////  else if (m_inFastRec)
-////    { // In fast recovery, inc cwnd for every additional dupack (RFC2581, sec.3.2)
-////      m_cWnd += m_segmentSize;
-////      NS_LOG_INFO ("In fast recovery. Increased cwnd to " << m_cWnd);
-////      SendPendingData (m_connected);
-////    };
-//}
-////...........................................................................................
-//
-
-/** Inherit from Socket class: Get the max number of bytes an app can read */
-uint32_t
-MpTcpSocketBase::GetRxAvailable(void) const
-{
-  NS_LOG_FUNCTION (this);
-  return m_rxBuffer->Available();
-}
-
-
-//void
-//MpTcpSocketBase::OnSubflowReset( Ptr<MpTcpSubflow> sf)
-//{
-//
-//}
-
-void
-MpTcpSocketBase::OnSubflowClosed(Ptr<MpTcpSubflow> subflow, bool reset)
-{
-  NS_LOG_LOGIC("Subflow " << subflow  << " definitely closed");
-  //! TODO it should remove itself from the list of subflows and when 0 are active
-  // it should call CloseAndNotify ?
-  if(reset)
-  {
-    NS_FATAL_ERROR("Case not handled yet.");
-  }
-
-//  SubflowList::iterator it = std::find(m_subflows[Closing].begin(), m_subflows[Closing].end(), subflow);
-// m_containers[Closing].erase(it);
-//NS_ASSERT(it != m_subflows[Closing].end());
-  SubflowList::iterator it = std::remove(m_subflows[Closing].begin(), m_subflows[Closing].end(), subflow);
-}
-
-void
-MpTcpSocketBase::DumpRxBuffers(Ptr<MpTcpSubflow> sf) const
-{
-  NS_LOG_INFO("=> Dumping meta RxBuffer ");
-  m_rxBuffer->Dump();
-
-  // TODO parcourir les sous flots
-
-  for(int i = 0; i < (int)GetNActiveSubflows(); ++i)
-  {
-    Ptr<MpTcpSubflow> sf = GetSubflow(i);
-    NS_LOG_INFO("=> Rx Buffer of subflow=" << sf);
-    sf->m_rxBuffer->Dump();
-  }
-}
-
-//Ptr<Socket> sock
-//SequenceNumber32 dataSeq,
-/**
-TODO the decision to ack is unclear with this structure.
-May return a bool to let subflow know if it should return a ack ?
-it would leave the possibility for meta to send ack on another subflow
-
-We have to extract data from subflows on a per mapping basis because mappings
-may not necessarily be contiguous
-**/
-void
-MpTcpSocketBase::OnSubflowRecv(Ptr<MpTcpSubflow> sf)
-{
-  NS_LOG_FUNCTION(this << "Received data from subflow=" << sf);
-  NS_LOG_INFO("=> Dumping meta RxBuffer before extraction");
-  DumpRxBuffers(sf);
-
-//  NS_ASSERT(IsConnected());
-
-  SequenceNumber32 expectedDSN = m_rxBuffer->NextRxSequence();
-
-  /* Extract one by one mappings from subflow */
-  while (true)
-  {
-
-    Ptr<Packet> p;
-    SequenceNumber64 dsn;
-    uint32_t canRead = m_rxBuffer->MaxBufferSize() - m_rxBuffer->Size();
-
-    if(canRead <= 0)
-    {
-      NS_LOG_LOGIC("No free space in meta Rx Buffer");
-      break;
-    }
-
-    /* Todo tell if we stop to extract only between mapping boundaries or if
-    Extract
-    */
-    p = sf->ExtractAtMostOneMapping(canRead, true, &dsn);
-
-    if (p->GetSize() == 0)
-    {
-      NS_LOG_DEBUG ("packet extracted empty.");
-      break;
-    }
-
-    // THIS MUST WORK. else we removed the data from subflow buffer so it would be lost
-    // Pb here, htis will be extracted but will not be saved into the main buffer
-    // TODO use an assert instead
-//    NS_LOG_INFO( "Meta  << "next Rx" << m_rxBuffer->NextRxSequence() );
-    // Notify app to receive if necessary
-    NS_LOG_DEBUG( "Before adding dsn " << dsn << " to metaRx: RxBufferHead=" << m_rxBuffer->HeadSequence() << " NextRxSequence=" << m_rxBuffer->NextRxSequence());
-
-    if(!m_rxBuffer->Add(p, SEQ64TO32(dsn)))
-    {
-
-      NS_FATAL_ERROR("Data might have been lost");
-    }
-
-//    NS_ASSERT_MSG(m_rxBuffer->Add(p, dsn), "Data got LOST");
-//    NS_ASSERT_MSG(m_rxBuffer->Add(p, dsn), "Data got LOST");
-    NS_LOG_DEBUG( "After adding to metaRx: RxBufferHead=" << m_rxBuffer->HeadSequence() << " NextRxSequence=" << m_rxBuffer->NextRxSequence());
-  } // end of the while
-
-  // TODO should restablish delayed acks ?
-  NS_LOG_UNCOND("=> Dumping RxBuffers after extraction");
-
-
-//  NS_LOG_INFO("=> After extraction Dumping Rx Buffer of subflow " << sf);
-  DumpRxBuffers(sf);
-//  sf->m_rxBuffer->Dump();
-
-  if (expectedDSN < m_rxBuffer->NextRxSequence())
-    {
-      NS_LOG_LOGIC("The Rxbuffer advanced");
-
-      // NextRxSeq advanced, we have something to send to the app
-      if (!m_shutdownRecv)
-        {
-          //<< m_receivedData
-          NS_LOG_LOGIC("Notify data Rcvd" );
-          NotifyDataRecv();
-
-        }
-      // Handle exceptions
-      if (m_closeNotified)
-        {
-          NS_LOG_WARN ("Why TCP " << this << " got data after close notification?");
-        }
-      // If we received FIN before and now completed all "holes" in rx buffer,
-      // invoke peer close procedure
-      // TODO this should be handled cautiously. TO reenable later with the correct
-      // MPTCP syntax
-//      if (m_rxBuffer->Finished() && (tcpHeader.GetFlags() & TcpHeader::FIN) == 0)
-//        {
-//          DoPeerClose();
-//        }
-    }
-
-}
-
-/**
-TODO check that it autodisconnects when we destroy the object ?
-**/
-void
-MpTcpSocketBase::OnSubflowNewCwnd(std::string context, uint32_t oldCwnd, uint32_t newCwnd)
-{
-  NS_LOG_LOGIC("Subflow updated window from " << oldCwnd << " to " << newCwnd
-//        << " (context=" << context << ")"
-        );
-
-  // maybe ComputeTotalCWND should be left
-  m_tcb->m_cWnd = ComputeTotalCWND ();
-}
-
-
-/**
-TODO add a MakeBoundCallback that accepts a member function as first input
-**/
-static void
-onSubflowNewState(
-//  std::string context,
-  Ptr<MpTcpSocketBase> meta,
-  Ptr<MpTcpSubflow> sf,
-  TcpSocket::TcpStates_t  oldState,
-  TcpSocket::TcpStates_t newState
-  )
-{
-  NS_LOG_UNCOND ("onSubflowNewState wrapper");
-  NS_LOG_UNCOND (" meta " << meta);
-  
-    meta->OnSubflowNewState(
-      "context", sf, oldState, newState);
-}
-
-/**
-TODO use it to Notify user of
-We need a MakeBoundCallback
-*/
-void
-MpTcpSocketBase::OnSubflowNewState(std::string context,
-  Ptr<MpTcpSubflow> sf,
-  TcpSocket::TcpStates_t  oldState,
-  TcpSocket::TcpStates_t newState
-)
-{
-  NS_LOG_LOGIC("subflow " << sf << " state changed from " << TcpStateName[oldState] << " to " << TcpStateName[newState]);
-  NS_LOG_LOGIC("Current rWnd=" << m_rWnd);
-
-  ComputeTotalCWND ();
-
-  if(sf->IsMaster() && newState == SYN_RCVD)
-  {
-      //!
-      NS_LOG_LOGIC("moving meta to SYN_RCVD");
-      m_server = true;
-      m_state = SYN_RCVD;
-      m_rWnd = sf->m_rWnd;
-  }
-
-  // Only react when it gets established
-  if(newState == ESTABLISHED)
-  {
-    //!
-    if (sf->IsMaster())
-    {
-      m_rWnd = sf->m_rWnd;
-      NS_LOG_LOGIC("Updated rWnd=" << m_rWnd);
-    }
-    MoveSubflow(sf, Others, Established);
-
-    // subflow did SYN_RCVD -> ESTABLISHED
-    if(oldState == SYN_RCVD)
-    {
-      NS_LOG_LOGIC("Subflow created");
-//      Simulator::ScheduleNow(&MpTcpSocketBase::OnSubflowEstablished, this, sf);
-      // TODO schedule it else it sends nothing ?
-      OnSubflowEstablished (sf);
-    }
-    // subflow did SYN_SENT -> ESTABLISHED
-    else if(oldState == SYN_SENT)
-    {
-      // TODO schedule it else it sends nothing ?
-//      Simulator::ScheduleNow(&MpTcpSocketBase::OnSubflowEstablishment, this, sf);
-      OnSubflowEstablishment(sf);
-    }
-    else
-    {
-      NS_FATAL_ERROR("Unhandled case");
-    }
-  }
-
-}
-
-
-/*
-TODO it should block subflow creation until it received a DSS on a new subflow
-TODO rename ? CreateAndAdd? Add ? Start ? Initiate
-TODO do it so that it does not return the subflow. Should make for fewer mistakes
-
-C'est l√† qu'il faut activer le socket tracing
-
-================================
-TODO REMOVE utilis√© nul part
-===============================
-Rename into CreateSubflowMaster .?
-*/
-Ptr<MpTcpSubflow>
-MpTcpSocketBase::CreateSubflow(
-                               bool masterSocket
-                               )
-{
-  NS_LOG_FUNCTION (this << m_subflowTypeId.GetName());
-  
-  Ptr<Socket> socket = m_tcp->CreateSocket( this->m_congestionControl, m_subflowTypeId);
-  
-  NS_LOG_FUNCTION (this);
-  //ns3::MpTcpSubflow::GetTypeId()
-  Ptr<MpTcpSubflow> master = DynamicCast<MpTcpSubflow>(
-    socket
-  );
-
-  return master;
-// Ptr<MpTcpSubflow> master = DynamicCast <MpTcpSubflow>(CompleteConstruct ( (TcpSocketBase*)subflow) );
-// TODO reestablish 
-  #if 0
-
-  // TODO could replaced that by the number of established subflows
-  // rename getSubflow by
-  if( IsConnected() )
-  {
-
-    //! Before allowing more subflows, we need to check if we already received a DSS ! (cf standard)
-//    if(!IsMpTcpEnabled())
-//    {
-//      NS_LOG_ERROR("Remote host does not seem MPTCP compliant so impossible to create additionnal subflows");
-////      return -ERROR_INVAL;
-//      return 0;
-//    }
-  }
-  //else if( GetNActiveSubflows() > 0 )
-  else if( m_state == SYN_SENT || m_state == SYN_RCVD)
-  {
-    // throw an assert here instead ?
-    NS_LOG_ERROR("Already attempting to establish a connection");
-    return 0;
-  }
-  // TODO remove CLOSEWAIT right ?
-  else if(m_state == TIME_WAIT || m_state == CLOSE_WAIT || m_state == CLOSING)
-  {
-    NS_LOG_ERROR("Not allowed to  create new subflow ");
-    return 0;
-  }
-
-// Subflow got no endpoint yet
-  // TODO pass CC
-//  m_congestionControl->GetInstanceTypeId()
-//GetMpTcpSubflowTypeId
-  Ptr<Socket> sock = m_tcp->CreateSocket ();
-
-  Ptr<MpTcpSubflow> sFlow = DynamicCast<MpTcpSubflow>(sock);
-  // So that we know when the connection gets established
-  //sFlow->SetConnectCallback( MakeCallback (&MpTcpSocketBase::OnSubflowEstablishment, Ptr<MpTcpSocketBase>(this) ) );
-  sFlow->SetMeta(this);
-
-  // TODO Maybe useless, master could be recognized based on endpoint  or mptcp state
-  sFlow->m_masterSocket = masterSocket;
-
-//  InetSocketAddress addr (m_endPoint->)
-//  if(masterSocket) {
-//    GetMeta ()->AddId (0, );
-//  }
-//  else {
-//    GetMeta ()->AddId (0, );
-//  }
-
-  /**
-  We need to update MPTCP level cwin every time a subflow window is updated,
-  thus we resort to the tracing system to track subflows cwin
-  **/
-  NS_ASSERT_MSG ( sFlow, "Contact ns3 team");
-  m_subflows[Others].push_back( sFlow );
-  NS_LOG_INFO ( "subflow " << sFlow << " associated with node " << sFlow->m_node);
-
-  return sFlow;
-    #endif
-}
-
-
-void
-MpTcpSocketBase::OnSubflowCreated (Ptr<Socket> socket, const Address &from)
-{
-    NS_LOG_LOGIC(this);
-    Ptr<MpTcpSubflow> sf = DynamicCast<MpTcpSubflow>(socket);
-
-    NotifySubflowCreated(sf);
-}
-
-void
-MpTcpSocketBase::OnSubflowConnectionSuccess (Ptr<Socket> socket)
-{
-
-    NS_LOG_LOGIC(this);
-    Ptr<MpTcpSubflow> sf = DynamicCast<MpTcpSubflow>(socket);
-    NotifySubflowConnected(sf);
-}
-
-void
-MpTcpSocketBase::OnSubflowConnectionFailure (Ptr<Socket> socket)
-{
-    NS_LOG_LOGIC(this);
-    Ptr<MpTcpSubflow> sf = DynamicCast<MpTcpSubflow>(socket);
-    if(sf->IsMaster())
-    {
-        TcpSocketBase::NotifyConnectionFailed();
-    }
-    else
-    {
-        // use a specific callback
-        NS_FATAL_ERROR("TODO");
-    }
-}
-
-
-void
-MpTcpSocketBase::AddSubflow (Ptr<MpTcpSubflow> sflow)
-{
-  NS_LOG_FUNCTION(sflow);
-//  Ptr<MpTcpSubflow> sf = DynamicCast<MpTcpSubflow>(sflow);
-  Ptr<MpTcpSubflow> sf = sflow;
-  bool ok;
-  ok = sf->TraceConnect ("CongestionWindow", "CongestionWindow", MakeCallback(&MpTcpSocketBase::OnSubflowNewCwnd, this));
-  NS_ASSERT_MSG(ok, "Tracing mandatory to update the MPTCP global congestion window");
-
-  //! We need to act on certain subflow state transitions according to doc "There is not a version with bound arguments."
-    //  NS_ASSERT(sFlow->TraceConnect ("State", "State", MakeCallback(&MpTcpSocketBase::OnSubflowNewState, this)) );
-  ok = sf->TraceConnectWithoutContext ("State", MakeBoundCallback(&onSubflowNewState, this, sf));
-  NS_ASSERT_MSG(ok, "Tracing mandatory to update the MPTCP socket state");
-
-
-
-  sf->SetMeta(this);
-
-  /* We override here callbacks so that subflows
-  don't communicate with the applications directly. The meta socket will
-  */
-//  sf->SetSendCallback ( MakeCallback);
-  sf->SetConnectCallback (
-    MakeCallback (&MpTcpSocketBase::OnSubflowConnectionSuccess, this),
-    MakeCallback (&MpTcpSocketBase::OnSubflowConnectionFailure, this)
-  );
-  sf->SetAcceptCallback (
-     MakeNullCallback<bool, Ptr<Socket>, const Address &>(),
-    // MakeCallback (&MpTcpSocketBase::NotifyConnectionRequest,this)
-     MakeCallback (&MpTcpSocketBase::OnSubflowCreated,this)
-  );
-  // Il y a aussi les!
-//  sf->SetCloseCallbacks
-//  sf->SetDataSentCallback (  );
-//  sf->RecvCallback (cbRcv);
-
-  sf->SetCongestionControlAlgorithm(this->m_congestionControl);
-
-  // TODO WIP if subflow has no id yet, then we should give one to it
-//  if (sf->GetMpTcpId () == -1) {
-//    NS_LOG_ERROR ("TODO");
-//  }
-
-
-  m_subflows[Others].push_back( sf );
-}
-
-
-
-/**
-I ended up duplicating this code to update the meta r_Wnd,
-which would have been hackish otherwise
-
-**/
-//void
-//MpTcpSocketBase::DoForwardUp(Ptr<Packet> packet, Ipv4Header header, uint16_t port, Ptr<Ipv4Interface> incomingInterface)
-//{
-//  NS_LOG_FUNCTION(this);
-//  TcpSocketBase::DoForwardUp(packet,header,port,incomingInterface);
-//
-//}
-void
-MpTcpSocketBase::ForwardUp (Ptr<Packet> packet, Ipv4Header header, uint16_t port, Ptr<Ipv4Interface> incomingInterface)
-{
-    NS_LOG_DEBUG(this << " called with endpoint " << m_endPoint);
-    NS_FATAL_ERROR("This socket should never receive any packet");
-//    TcpSocketBase::ForwardUp(packet, header, port, incomingInterface);
-}
-
-//uint32_t
-//MpTcpSocketBase::GetToken() const
-//{
-////  NS_ASSERT(m_state != SYN);
-//  return m_localToken;
-//}
-
-
-bool
-MpTcpSocketBase::NotifyJoinRequest (const Address &from, const Address & toAddress)
-{
-  NS_LOG_FUNCTION (this << &from);
-  if (!m_joinRequest.IsNull ())
-    {
-      return m_joinRequest (this, from, toAddress);
-    }
-  else
-    {
-      // accept all incoming connections by default.
-      // this way people writing code don't have to do anything
-      // special like register a callback that returns true
-      // just to get incoming connections
-      return true;
-    }
-}
-
-
-bool
-MpTcpSocketBase::OwnIP(const Address& address) const
-{
-    NS_LOG_FUNCTION(this);
-    NS_ASSERT_MSG(Ipv4Address::IsMatchingType(address), "only ipv4 supported for now");
-
-    Ipv4Address ip = Ipv4Address::ConvertFrom(address);
-
-//  < GetNDevices()
-  Ptr<Node> node = GetNode();
-  Ptr<Ipv4L3Protocol> ipv4 = node->GetObject<Ipv4L3Protocol>();
-  return (ipv4->GetInterfaceForAddress(ip) >= 0);
-  #if 0
-//  for (Ipv4InterfaceList::const_iterator it = m_interfaces.begin(); it != m_interfaces.end(); it++)
-  for (uint32_t i(0); i < node->GetNDevices(); i++)
-  {
-      //Ptr<NetDevice> device = m_node->GetDevice(i);
-      // Pourrait y avoir plusieurs IPs sur l'interface
-      Ptr<NetDevice> device = node->GetDevice(i);
-      // Cette fonction est mauvaise:
-      if (device->GetAddress() == address)
-      {
-        return true;
-      }
-
-//      }
-  }
-    #endif
-  return false;
-}
-
-
-/*
-Create in SYN/RCVD mode
-*/
-//  CompleteFork(Ptr<Packet> p, const TcpHeader& h, const Address& fromAddress, const Address& toAddress);
-// TODO remove
-#if 0
-Ptr<MpTcpSubflow>
-MpTcpSocketBase::CreateSubflowAndCompleteFork(
-  bool masterSocket,
-//  Ptr<Packet> p,
- const TcpHeader& mptcpHeader, const Address& fromAddress, const Address& toAddress
-)
-{
-  NS_LOG_FUNCTION(this);
-
-  Ptr<MpTcpSubflow> sFlow = CreateSubflow(masterSocket);
-
-  Ptr<Packet> p = Create<Packet>();
-
-
-  sFlow->CompleteFork(p, mptcpHeader, fromAddress,toAddress);
-//  SetupSubflowTracing(sFlow);
-
- return sFlow;
-}
-#endif
-
-Ipv4EndPoint*
-MpTcpSocketBase::NewSubflowRequest (
-Ptr<const Packet> p,
-const TcpHeader & tcpHeader,
-const Address & fromAddress,
-const Address & toAddress,
-Ptr<const TcpOptionMpTcpJoin> join
-)
-{
-  NS_LOG_LOGIC("Received request for a new subflow while in state " << TcpStateName[m_state]);
-  NS_ASSERT_MSG(InetSocketAddress::IsMatchingType(fromAddress) && InetSocketAddress::IsMatchingType(toAddress),
-                "Source and destination addresses should be of the same type");
-  //join->GetState() == TcpOptionMpTcpJoin::Syn &&
-  NS_ASSERT(join);
-  NS_ASSERT(join->GetPeerToken() == GetLocalToken());
-
-  // TODO check toAddress belongs to this node
-
-
-//  check we can accept the creation of a new subflow (did we receive a DSS already ?)
-  if( !FullyEstablished() )
-  {
-    NS_LOG_WARN("Received an MP_JOIN while meta not fully established yet.");
-    return 0;
-  }
-
-
-
-  //! TODO here we should trigger a callback to say if we accept the connection or not
-  // (and create a helper that acts as a path manager)
-  Ipv4Address ip = InetSocketAddress::ConvertFrom(toAddress).GetIpv4();
-  if(!OwnIP(ip))
-  {
-    NS_LOG_WARN("This host does not own the ip " << ip);
-    return 0;
-  }
-
-  // Similar to NotifyConnectionRequest
-  bool accept_connection = NotifyJoinRequest(fromAddress, toAddress);
-  if(!accept_connection)
-  {
-    NS_LOG_LOGIC("Refusing establishement of a new subflow");
-    return 0;
-  }
-
-  Ptr<MpTcpSubflow> subflow ;
-
-  // TODO remove next line
-  m_subflowTypeId = MpTcpSubflow::GetTypeId ();
-  Ptr<Socket> sock = m_tcp->CreateSocket(m_congestionControl, m_subflowTypeId);
-
-  subflow = DynamicCast<MpTcpSubflow>(sock);
-  AddSubflow (subflow);
-
-  // Call it now so that endpoint gets allocated
-  subflow->CompleteFork(p, tcpHeader, fromAddress, toAddress);
-
-  return subflow->m_endPoint;
-}
-
-
-/**
-Need to override parent's otherwise it allocates an endpoint to the meta socket
-and upon connection , the tcp subflow can't allocate
-TODO remove
-*/
-int
-MpTcpSocketBase::Connect(const Address & toAddress)
-{
-  NS_LOG_FUNCTION(this);
-
-  // TODO may have to set m_server to false here
-  NS_FATAL_ERROR("TODO remove");
-  return -1;
-}
-
-/** This function closes the endpoint completely. Called upon RST_TX action. */
-void
-MpTcpSocketBase::SendRST(void)
-{
-  NS_FATAL_ERROR("TO REMOVE, use SendFastClose instead");
-}
-
-void
-MpTcpSocketBase::SendFastClose(Ptr<MpTcpSubflow> sf)
-{
-  NS_LOG_LOGIC ("Sending MP_FASTCLOSE");
-//  NS_FATAL_ERROR("TODO");
-  // TODO: send an MPTCP_fail
-   TcpHeader header;
-//   Ptr<MpTcpSubflow> sf = GetSubflow(0);
-  sf->GenerateEmptyPacketHeader(header, TcpHeader::RST);
-  Ptr<TcpOptionMpTcpFastClose> opt = Create<TcpOptionMpTcpFastClose>();
-
-  opt->SetPeerKey( GetPeerKey() );
-
-  sf->SendEmptyPacket(header);
-
-  //! Enter TimeWait ?
-//  NotifyErrorClose();
-  TimeWait();
-//  DeallocateEndPoint();
-}
-
-
-int
-MpTcpSocketBase::DoConnect(void)
-{
-  NS_LOG_FUNCTION (this << "Disabled");
-//DeAllocate
-//  if(IsConnected()) {
-//    NS_LOG_WARN(this << " is already connected");
-//    return -1;
-//  }
-  return 0;
-}
-
-void
-MpTcpSocketBase::ConnectionSucceeded(void)
-{
-  NS_LOG_FUNCTION(this);
-   m_connected = true;
-   TcpSocketBase::ConnectionSucceeded();
-}
-
-// TODO move to TcpSocketBase
-bool
-MpTcpSocketBase::IsConnected() const
-{
-  return m_connected;
-}
-
-
-
-/** Inherited from Socket class: Bind socket to an end-point in MpTcpL4Protocol
-TODO convert to noop/remove
-*/
-int
-MpTcpSocketBase::Bind()
-{
-  NS_LOG_FUNCTION (this);
-  NS_FATAL_ERROR("TO remove");
-  m_server = true;
-  m_endPoint = m_tcp->Allocate();  // Create endPoint with ephemeralPort
-  if (0 == m_endPoint)
-    {
-      m_errno = ERROR_ADDRNOTAVAIL;
-      return -1;
-    }
-  //m_tcp->m_sockets.push_back(this); // We don't need it for now
-  return SetupCallback();
-}
-
-/** Clean up after Bind operation. Set up callback function in the end-point */
-int
-MpTcpSocketBase::SetupCallback()
-{
-  NS_LOG_FUNCTION(this);
-  return TcpSocketBase::SetupCallback();
-}
-
-/** Inherit from socket class: Bind socket (with specific address) to an end-point in TcpL4Protocol
-cconvert to noop
-*/
-int
-MpTcpSocketBase::Bind(const Address &address)
-{
-  NS_LOG_FUNCTION (this<<address);
-  NS_FATAL_ERROR("TO remove");
-
-  return TcpSocketBase::Bind(address);
-}
-
-
-/*
-Notably, it is only DATA_ACKed once all
-data has been successfully received at the connection level.  Note,
-therefore, that a DATA_FIN is decoupled from a subflow FIN.  It is
-only permissible to combine these signals on one subflow if there is
-no data outstanding on other subflows.
-*/
-void
-MpTcpSocketBase::PeerClose ( SequenceNumber32 dsn, Ptr<MpTcpSubflow> sf)
-{
-  NS_LOG_LOGIC ("Datafin with seq=" << dsn);
-
-
-//  SequenceNumber32 dsn = SequenceNumber32 (dss->GetDataFinDSN() );
-  // TODO the range check should be generalized somewhere else
-//  dsn 2922409388 out of expected range [ 2922409389 - 2922409388
-  if( dsn < m_rxBuffer->NextRxSequence() || m_rxBuffer->MaxRxSequence() < dsn)
-  {
-//    m_rxBuffer->Dump();
-//    NS_LOG_INFO("dsn " << dsn << " out of expected range [ " << m_rxBuffer->NextRxSequence()  << " - " << m_rxBuffer->MaxRxSequence() << " ]" );
-    return ;
-  }
-
-
-  // For any case, remember the FIN position in rx buffer first
-  //! +1 because the datafin doesn't count as payload
-  // TODO rename mapping into GetDataMapping
-//  NS_LOG_LOGIC("Setting FIN sequence to " << dss->GetMapping().TailDSN());
-  m_rxBuffer->SetFinSequence (dsn);
-  NS_LOG_LOGIC ("Accepted MPTCP DFIN=" << dsn);
-
-  // Return if FIN is out of sequence, otherwise move to CLOSE_WAIT state by DoPeerClose
-  if (!m_rxBuffer->Finished())
-  {
-    NS_LOG_WARN ("Not finished yet, NextRxSequence=" << m_rxBuffer->NextRxSequence());
-    m_rxBuffer->Dump();
-    return;
-  }
-
-//  NS_LOG_LOGIC ("Accepted DATA FIN at seq " << tcpHeader.GetSequenceNumber () + SequenceNumber32 (p->GetSize ()));
-
-  // Simultaneous close: Application invoked Close() when we are processing this FIN packet
-  TcpStates_t old_state = m_state;
-  switch(m_state)
-  {
-    case FIN_WAIT_1:
-      m_state = CLOSING; 
-      break;
-
-    case FIN_WAIT_2:
-      // will go into timewait later
-      TimeWait ();
-      break;
-
-    case ESTABLISHED:
-      m_state = CLOSE_WAIT;
-      break;
-
-    default:
-      NS_FATAL_ERROR("Should not reach this");
-      break;
-  };
-
-  NS_LOG_INFO (TcpStateName[old_state] << " -> " << TcpStateName[m_state]);
-
-
-//  if (m_state == FIN_WAIT_1 || m_state == FIN_WAIT_2 || m_state == ESTABLISHED)
-//    {
-//      NS_LOG_INFO ("FIN_WAIT_1 -> CLOSING");
-//      m_state = CLOSING;
-
-      // TODO should send dataACK
-      TcpHeader header;
-      sf->GenerateEmptyPacketHeader (header,TcpHeader::ACK);
-      sf->AppendDSSAck();
-      sf->SendEmptyPacket(header);
-//      return;
-//    }
-
-
-//   DoPeerClose();
-}
-
-void
-MpTcpSocketBase::OnInfiniteMapping(Ptr<TcpOptionMpTcpDSS> dss, Ptr<MpTcpSubflow> sf)
-{
-  NS_FATAL_ERROR("Infinite mapping not implemented");
-}
-
-
-
-/**
-this function supposes that
-TODO is  never called apparently
-**/
-void
-MpTcpSocketBase::OnSubflowNewAck(Ptr<MpTcpSubflow> subflow)
-{
-  NS_LOG_LOGIC("new subflow ack " );
-//  // Si le new ack 
-//  if (m_)
-//  SyncTxBuffers(subflow);
-  SyncTxBuffers ();
-}
-
-
-void
-MpTcpSocketBase::SyncTxBuffers()
-{
-  NS_LOG_LOGIC("Syncing Tx buffer with all subflows");
-  for(int i = 0; i < Maximum; ++i) {
-
-//    Established
-//    NS_LOG_INFO("Closing all subflows in state [" << containerNames [i] << "]");
-    for( SubflowList::const_iterator it = m_subflows[i].begin(); it != m_subflows[i].end(); it++ )
-    {
-
-//      SubflowList::iterator it = std::find(m_subflows[i].begin(), m_subflows[i].end(), subflow);
-//      NS_ASSERT(it != m_subflows[from].end() ); //! the subflow must exist
-//      if(it != m_subflows[i].end()) {
-      SyncTxBuffers (*it);
-    }
-  }
-
-
-  ComputeTotalCWND();
-
-
-  // TODO remove it maybe (check) ?
-  // TODO I should go through all
-  // TODO that should be triggered !!! it should ask the meta for data rather !
-  if (GetTxAvailable() > 0)
-    {
-      NS_LOG_INFO("Tx available" << GetTxAvailable());
-      NotifySend(GetTxAvailable());
-    }
-
-
-
-  // if no more data and socket closing
-  if (m_txBuffer->Size() == 0 && m_state != FIN_WAIT_1 && m_state != CLOSING)
-    { // No retransmit timer if no data to retransmit
-      NS_LOG_WARN (this << " Cancelled ReTxTimeout event which was set to expire at " <<
-          (Simulator::Now () + Simulator::GetDelayLeft (m_retxEvent)).GetSeconds ());
-      m_retxEvent.Cancel();
-      return;
-    }
-
-  // Partie que j'ai ajout√©e to help closing the connection
-  // maybe remove some of it
-  if (m_txBuffer->Size() == 0)
-    {
-      // In case we m_RxBuffer m_rxBuffer->Finished()
-      // m_highTxMark + SequenceNumber32(1)
-      // TODO maybe
-//      if(m_state == FIN_WAIT_1 && m_txBuffer->Size() == 0 &&  (dsn == m_txBuffer->HeadSequence() + SequenceNumber32(1) ) ) {
-      if(m_state == FIN_WAIT_1 && m_txBuffer->Size() == 0
-      &&  (FirstUnackedSeq() ==  m_txBuffer->HeadSequence() + SequenceNumber32(1) ) ) {
-
-        NS_LOG_LOGIC("FIN_WAIT_1 -> FIN_WAIT_2 ");
-        m_state=FIN_WAIT_2;
-        TcpHeader header;
-
-        Ptr<MpTcpSubflow> sf = GetSubflow(0);
-        sf->GenerateEmptyPacketHeader(header, TcpHeader::ACK);
-        sf->AppendDSSAck();
-        sf->SendEmptyPacket(header);
-        //!
-
-      }
-//      else if (m_state == FIN_WAIT_2) {
-////        Send DACK for DFIN
-//        NS_LOG_INFO("FIN_WAIT_2 test");
-//        CloseAllSubflows();
-//      }
-//      else if (m_state == FIN_WAIT_1) {
-//        //!
-//      }
-
-
-      return;
-    }
-  // in case it freed some space in cwnd, try to send more data
-  SendPendingData(m_connected);
-}
-
-
-// TODO maybe add a bool to ask for
-//SequenceNumber32 const& ack,
-void
-MpTcpSocketBase::SyncTxBuffers(Ptr<MpTcpSubflow> subflow)
-{
-
-  NS_LOG_LOGIC("Syncing TxBuffer between meta " << this << " and subflow " << subflow);
-
-  while(true)
-  {
-//    SequenceNumber32 dack = 0;
-    MpTcpMapping mapping;
-
-    if(!subflow->DiscardAtMostOneTxMapping( SEQ32TO64(FirstUnackedSeq()), mapping ))
-    {
-      NS_LOG_DEBUG("Nothing discarded");
-      break;
-    }
-
-    /**
-    returned mapping discarded because we don't support NR sack right now
-    **/
-    NS_LOG_DEBUG("subflow Tx mapping " << mapping << " discarded");
-
-    /*
-    DiscardUpTo  Discard data up to but not including this sequence number.
-    */
-    m_txBuffer->DiscardUpTo( SEQ64TO32(mapping.TailDSN()) + SequenceNumber32(1));
-  }
-}
-
-
-/**
-TODO call 64bits  version ?
-It should know from which subflow it comes from
-TODO update the r_Wnd here
-
-
-This is not really possible until we change the buffer system:
-"The sender MUST keep data in its send buffer as long as the data has
-not been acknowledged at both connection level and on all subflows on
-which it has been sent."
-
-TODO:
-
-
-**/
-
-void
-MpTcpSocketBase::UpdateTxBuffer()
-{
-    NS_LOG_LOGIC("Synchronizing buffers");
-
-    SyncTxBuffers();
-}
-
-
-/*
-This should take care of ReTxTimeout
-*/
-void
-MpTcpSocketBase::NewAck(SequenceNumber32 const& dsn)
-{
-  NS_LOG_FUNCTION(this << " new dataack=[" <<  dsn << "]");
-
-  if(m_state == SYN_SENT) {
-
-
-  }
-  TcpSocketBase::NewAck(dsn);
-
-  #if 0
-
-  // update tx buffer
-  // TODO if I call this, it crashes because on the MpTcpBase client, there is no endpoint configured
-  // so it tries to connect to IPv6 node
-//  TcpSocketBase::NewAck( seq  );
-
-  // Retrieve the highest m_txBuffer
-
-  // Is done at subflow lvl alread
-  // should be done from here for all subflows since
-  // a same mapping could have been attributed to for allo
-  // BUT can't be discarded if not acklowdged at subflow level so...
-//  sf->DiscardTxMappingsUpToDSN( m_txBuffer->HeadSequence() );
-//    in that fct
-//  discard
-
-//  NS_LOG_FUNCTION (this << dsn);
-
-// TODO reestablish
-  if (m_state != SYN_RCVD)
-    { // Set RTO unless the ACK is received in SYN_RCVD state
-      NS_LOG_LOGIC (this << " Cancelled ReTxTimeout event which was set to expire at " <<
-          (Simulator::Now () + Simulator::GetDelayLeft (m_retxEvent)).GetSeconds ());
-      m_retxEvent.Cancel();
-      // On recieving a "New" ack we restart retransmission timer .. RFC 2988
-      m_rto = ComputeRTO();
-      NS_LOG_LOGIC (this << " Schedule ReTxTimeout at time " <<
-          Simulator::Now ().GetSeconds () << " to expire at time " <<
-          (Simulator::Now () + m_rto.Get ()).GetSeconds ());
-      m_retxEvent = Simulator::Schedule(m_rto, &MpTcpSocketBase::ReTxTimeout, this);
-    }
-
-  // TODO update m_rWnd
-  if (m_rWnd.Get() == 0 && m_persistEvent.IsExpired())
-    { // Zero window: Enter persist state to send 1 byte to probe
-      NS_LOG_LOGIC (this << "Enter zerowindow persist state");NS_LOG_LOGIC (this << "Cancelled ReTxTimeout event which was set to expire at " <<
-          (Simulator::Now () + Simulator::GetDelayLeft (m_retxEvent)).GetSeconds ());
-      m_retxEvent.Cancel();
-      NS_LOG_LOGIC ("Schedule persist timeout at time " <<
-          Simulator::Now ().GetSeconds () << " to expire at time " <<
-          (Simulator::Now () + m_persistTimeout).GetSeconds ());
-      m_persistEvent = Simulator::Schedule(m_persistTimeout, &MpTcpSocketBase::PersistTimeout, this);
-      NS_ASSERT(m_persistTimeout == Simulator::GetDelayLeft (m_persistEvent));
-    }
-//    #endif
-  // Note the highest ACK and tell app to send more
-  NS_LOG_LOGIC ("TCP " << this << " NewAck " << dsn <<
-      " nbAckedBytes " << (dsn - FirstUnackedSeq())); // Number bytes ack'ed
-
-
-  /**
-  This is possible because packets were copied int osubflows buffers, and that there is no intent to
-  reinject them on other paths
-//  m_txBuffer->DiscardUpTo(dsn);
-  TODO here I should
-  **/
-  m_firstTxUnack = std::min(dsn, m_txBuffer->TailSequence());;
-
-
-
-  // TODO wrong. what happens with NR-SACK ?
-  if (m_firstTxUnack > m_nextTxSequence)
-    {
-      m_nextTxSequence = m_firstTxUnack; // If advanced
-    }
-
-
-
-  #endif
-}
-
-bool
-MpTcpSocketBase::IsInfiniteMappingEnabled() const
-{
-    return false;
-}
-
-// Send 1-byte data to probe for the window size at the receiver when
-// the local knowledge tells that the receiver has zero window size
-// C.f.: RFC793 p.42, RFC1112 sec.4.2.2.17
-void
-MpTcpSocketBase::PersistTimeout()
-{
-  NS_LOG_LOGIC ("PersistTimeout expired at " << Simulator::Now ().GetSeconds ());
-  NS_FATAL_ERROR("TODO");
-}
-
-
-void
-MpTcpSocketBase::BecomeFullyEstablished ()
-{
-    NS_LOG_FUNCTION (this);
-    m_receivedDSS = true;
-
-    // same as in ProcessSynSent upon SYN/ACK reception
-//    m_nextTxSequence++;
-//    m_firstTxUnack = m_nextTxSequence;
-//    m_highTxMark = m_nextTxSequence;
-//    m_txBuffer->SetHeadSequence (m_nextTxSequence);
-    // should be called only on client side
-    ConnectionSucceeded();
-}
-
-bool
-MpTcpSocketBase::FullyEstablished() const
-{
-    NS_LOG_FUNCTION_NOARGS();
-    return m_receivedDSS;
-}
-
-
-
-
-//void
-//MpTcpSocketBase::SetupSubflowTracing(Ptr<MpTcpSubflow> sf)
-//{
-//  NS_ASSERT_MSG(m_tracePrefix.length() != 0, "please call SetupMetaTracing before." );
-//  NS_LOG_LOGIC("Meta=" << this << " Setup tracing for sf " << sf << " with prefix [" << m_tracePrefix << "]");
-////  f.open(filename, std::ofstream::out | std::ofstream::trunc);
-//
-//  // For now, there is no subflow deletion so this should be good enough, else it will crash
-//  std::stringstream os;
-//  //! we start at 1 because it's nicer
-//
-////  os << m_tracePrefix << "subflow" <<  m_prefixCounter++;
-//
-//  SetupSocketTracing(sf, os.str().c_str());
-//}
-
-/*****************************
-END TRACING system
-*****************************/
-
-
-/**
- * Sending data via subflows with available window size.
- * Todo somehow rename to dispatch
- * we should not care about IsInfiniteMapping()
- */
-bool
-MpTcpSocketBase::SendPendingData(bool withAck)
-{
-  NS_LOG_FUNCTION(this << "Sending data" << TcpStateName[m_state]);
-
-//  MappingList mappings;
-  if (m_txBuffer->Size () == 0)
-    {
-      NS_LOG_DEBUG("Nothing to send");
-      return false;                           // Nothing to send
-    }
-  //start/size
-  int nbMappingsDispatched = 0; // mimic nbPackets in TcpSocketBase::SendPendingData
-
-  //// Generate DSS mappings
-  //// This could go into a specific function
-  /////////////////////////////////////////////
-//  MappingVector mappings;
-  SequenceNumber64 dsnHead;
-  SequenceNumber32 ssn;
-  int subflowArrayId;
-  uint16_t length;
-
-  //mappings.reserve( GetNActiveSubflows() );
-  // the MapToSsn will be done,
-  // dsn, size, and path instead of a unmapped mapping
-  // GenerateMapping( sf, );
-  // Pb: infinite loop because of
-  while(m_scheduler->GenerateMapping (subflowArrayId, dsnHead, length))
-  {
-      NS_LOG_DEBUG("Generated mapping for sf=" << subflowArrayId << " dsn=" << dsnHead
-                    << " of len=" << length);
-
-      Ptr<MpTcpSubflow> subflow = GetSubflow(subflowArrayId);
-
-      // For now we limit the mapping to a per packet basis
-      bool ok = subflow->AddLooseMapping(dsnHead, length);
-
-      NS_ASSERT(ok);
-
-
-      ////
-      //// see next #if 0 to see how it should be
-      SequenceNumber32 dsnTail = SEQ64TO32(dsnHead) + length;
-
-      // temp
-      Ptr<Packet> p = m_txBuffer->CopyFromSequence(length, dsnHead);
-
-
-      NS_ASSERT(p->GetSize() <= length);
-
-      int ret = subflow->Send(p, 0);
-      // Flush to update cwnd and stuff
-//      subflow->SendPendingData();
-      NS_LOG_DEBUG("Send result=" << ret);
-
-      /*
-      Ideally we should be able to send data out of order so that it arrives in order at the
-      receiver but to do that we need SACK support (IMO). Once SACK is implemented it should
-      be reasonably easy to add
-      */
-      NS_ASSERT(dsnHead == m_nextTxSequence);
-      //TODO update m_nextTx / txmark
-      //  // TODO here update the m_nextTxSequence only if it is in order
-      //      // Maybe the max is unneeded; I put it here
-      SequenceNumber64 nextTxSeq = SEQ32TO64(m_nextTxSequence);
-      if( dsnHead <= nextTxSeq
-          && (dsnTail) >= nextTxSeq )
-      {
-        m_nextTxSequence = dsnTail;
-      }
-
-      m_highTxMark = std::max( m_highTxMark.Get(), dsnTail);
-      NS_LOG_LOGIC("m_nextTxSequence=" << m_nextTxSequence << " m_highTxMark=" << m_highTxMark);
-  }
-
-
-    // disabled for now since not advancing txmark was creating an infinite loop
-    // but once TCP sack is implemented we should reenable it
-    #if 0
-    NS_LOG_DEBUG("Looping through  subflows to dispatch meta Tx data");
-
-  // Then we loop through subflows to see if the dsn was mapped to the subflow
-  // this allows to send the same data over different subflows
-    for(int i = 0; i < (int)GetNActiveSubflows() ; i++ )
-    {
-        Ptr<MpTcpSubflow> sf = GetSubflow(i);
-
-
-        //! retrieve the DSN ranges that this subflow has mappings for.
-        std::set<MpTcpMapping> temp;
-        sf->GetMappedButMissingData(temp);
-
-        // go through the unsent meta Tx buffer
-        // and check if any part of the Tx Data is mapped in a subflow but not yet in the
-        // subflow tx
-        for(std::set<MpTcpMapping>::iterator it = temp.begin(); it != temp.end(); ++it)
-        {
-            // Extract the mapped part
-            MpTcpMapping mapping = *it;
-            NS_LOG_DEBUG("Subflow expect mapping " << mapping);
-
-            // temp
-            Ptr<Packet> p = m_txBuffer->CopyFromSequence(mapping.GetLength(), SEQ64TO32(mapping.HeadDSN()));
-
-
-            NS_ASSERT(p->GetSize() <= mapping.GetLength());
-
-            int ret = sf->Send(p, 0);
-            NS_LOG_DEBUG("Send result=" << ret);
-
-            /*
-            Ideally we should be able to send data out of order so that it arrives in order at the
-            receiver but to do that we need SACK support (IMO). Once SACK is implemented it should
-            be reasonably easy to add
-            */
-            NS_ASSERT(mapping.HeadDSN() == m_nextTxSequence);
-            //TODO update m_nextTx / txmark
-//  // TODO here update the m_nextTxSequence only if it is in order
-//      // Maybe the max is unneeded; I put it here
-            SequenceNumber64 nextTxSeq = SEQ32TO64(m_nextTxSequence);
-            if( mapping.HeadDSN() <= nextTxSeq
-                && mapping.TailDSN() >= nextTxSeq )
-            {
-              m_nextTxSequence = SEQ64TO32(mapping.TailDSN()) + 1;
-            }
-
-            m_highTxMark = std::max( m_highTxMark.Get(), SEQ64TO32(mapping.TailDSN()));
-            NS_LOG_LOGIC("m_nextTxSequence=" << m_nextTxSequence << " m_highTxMark=" << m_highTxMark);
-        }
-
-    }
-    #endif
-
-
-  // Just dump the generated mappings
-//  NS_LOG_UNCOND("=================\nGenerated " << mappings.size() << " mappings for node=" << (int)GetNode()->GetId());
-//  for(MappingVector::iterator it(mappings.begin()); it  != mappings.end(); it++ )
-//  {
-//    MpTcpMapping& mapping = it->second;
-//    NS_LOG_UNCOND("Send " << it->second << " on sf id=" << (int)it->first);
-//  }
-//  NS_LOG_UNCOND("=================");
-//
-////  NS_ASSERT_MSG( mappings.size() == GetNActiveSubflows(), "The number of mappings should be equal to the nb of already established subflows" );
-//
-//  NS_LOG_DEBUG("generated [" << mappings.size() << "] mappings");
-//  // TODO dump mappings ?
-//  // Loop through mappings and send Data
-////  for(int i = 0; i < (int)GetNActiveSubflows() ; i++ )
-//  for(MappingVector::iterator it(mappings.begin()); it  != mappings.end(); it++ )
-//  {
-//
-//
-//    Ptr<MpTcpSubflow> sf = GetSubflow(it->first);
-//    MpTcpMapping& mapping = it->second;
-////    Retrieve data  Rename SendMappedData
-//    //SequenceNumber32 dataSeq = mappings[i].first;
-//    //uint16_t mappingSize = mappings[i].second;
-//
-//    NS_LOG_DEBUG("Sending mapping "<< mapping << " on subflow #" << (int)it->first);
-//
-//    //sf->AddMapping();
-//    Ptr<Packet> p = m_txBuffer->CopyFromSequence(mapping.GetLength(), SEQ64TO32(mapping.HeadDSN()));
-//    NS_ASSERT(p->GetSize() == mapping.GetLength());
-//
-//    /// Recently replaced by the following
-////    int ret = sf->SendMapping(p, mapping);
-//    /// here the mapping should be already mapped set
-//    int ret = sf->AddMapping(mapping);
-//
-//
-//    if( ret < 0)
-//    {
-//      // TODO dump the mappings ?
-//      NS_FATAL_ERROR("Could not send mapping. The generated mappings");
-//    }
-//
-//
-//
-//
-//
-//    // if successfully sent,
-//    nbMappingsDispatched++;
-//
-////    bool sentPacket =
-//    sf->SendPendingData();
-////    NS_LOG_DEBUG("Packet sent ? boolean=s" << sentPacket );
-//
-//  // TODO here update the m_nextTxSequence only if it is in order
-//      // Maybe the max is unneeded; I put it here
-//    if( SEQ64TO32(mapping.HeadDSN()) <= m_nextTxSequence && SEQ64TO32(mapping.TailDSN()) >= m_nextTxSequence)
-//    {
-//      m_nextTxSequence = SEQ64TO32(mapping.TailDSN()) + 1;
-//    }
-//
-//    m_highTxMark = std::max( m_highTxMark.Get(), SEQ64TO32(mapping.TailDSN()));
-////      m_nextTxSequence = std::max(m_nextTxSequence.Get(), mapping.TailDSN() + 1);
-//    NS_LOG_LOGIC("m_nextTxSequence=" << m_nextTxSequence << " m_highTxMark=" << m_highTxMark);
-//  }
-
-
-
-  // TODO here send for all
-
-
-
-  uint32_t remainingData = m_txBuffer->SizeFromSequence(m_nextTxSequence );
-
-  if (m_closeOnEmpty && (remainingData == 0))
-    {
-      TcpHeader header;
-
-      ClosingOnEmpty(header);
-
-    }
-
-//  NS_LOG_LOGIC ("Dispatched " << nPacketsSent << " mappings");
-  return nbMappingsDispatched > 0;
-}
-
-#if 0
-bool
-MpTcpSocketBase::SendPendingData(bool withAck)
-{
-  NS_LOG_FUNCTION(this << "Sending data" << TcpStateName[m_state]);
-
-//  MappingList mappings;
-  if (m_txBuffer->Size () == 0)
-    {
-      NS_LOG_DEBUG("Nothing to send");
-      return false;                           // Nothing to send
-    }
-  //start/size
-  int nbMappingsDispatched = 0; // mimic nbPackets in TcpSocketBase::SendPendingData
-
-  MappingVector mappings;
-  //mappings.reserve( GetNActiveSubflows() );
-  // the MapToSsn will be done,
-  // dsn, size, and path instead of a unmapped mapping
-  // GenerateMapping( sf, );
-  m_scheduler->GenerateMappings(mappings);
-
-
-  // Just dump the generated mappings
-  NS_LOG_UNCOND("=================\nGenerated " << mappings.size() << " mappings for node=" << (int)GetNode()->GetId());
-  for(MappingVector::iterator it(mappings.begin()); it  != mappings.end(); it++ )
-  {
-    MpTcpMapping& mapping = it->second;
-    NS_LOG_UNCOND("Send " << it->second << " on sf id=" << (int)it->first);
-  }
-  NS_LOG_UNCOND("=================");
-
-//  NS_ASSERT_MSG( mappings.size() == GetNActiveSubflows(), "The number of mappings should be equal to the nb of already established subflows" );
-
-  NS_LOG_DEBUG("generated [" << mappings.size() << "] mappings");
-  // TODO dump mappings ?
-  // Loop through mappings and send Data
-//  for(int i = 0; i < (int)GetNActiveSubflows() ; i++ )
-  for(MappingVector::iterator it(mappings.begin()); it  != mappings.end(); it++ )
-  {
-
-
-    Ptr<MpTcpSubflow> sf = GetSubflow(it->first);
-    MpTcpMapping& mapping = it->second;
-//    Retrieve data  Rename SendMappedData
-    //SequenceNumber32 dataSeq = mappings[i].first;
-    //uint16_t mappingSize = mappings[i].second;
-
-    NS_LOG_DEBUG("Sending mapping "<< mapping << " on subflow #" << (int)it->first);
-
-    //sf->AddMapping();
-    Ptr<Packet> p = m_txBuffer->CopyFromSequence(mapping.GetLength(), SEQ64TO32(mapping.HeadDSN()));
-    NS_ASSERT(p->GetSize() == mapping.GetLength());
-
-    /// Recently replaced by the following
-//    int ret = sf->SendMapping(p, mapping);
-    /// here the mapping should be already mapped set
-    int ret = sf->AddMapping(mapping);
-
-
-    if( ret < 0)
-    {
-      // TODO dump the mappings ?
-      NS_FATAL_ERROR("Could not send mapping. The generated mappings");
-    }
-
-
-
-
-
-    // if successfully sent,
-    nbMappingsDispatched++;
-
-//    bool sentPacket =
-    sf->SendPendingData();
-//    NS_LOG_DEBUG("Packet sent ? boolean=s" << sentPacket );
-
-  // TODO here update the m_nextTxSequence only if it is in order
-      // Maybe the max is unneeded; I put it here
-    if( SEQ64TO32(mapping.HeadDSN()) <= m_nextTxSequence && SEQ64TO32(mapping.TailDSN()) >= m_nextTxSequence)
-    {
-      m_nextTxSequence = SEQ64TO32(mapping.TailDSN()) + 1;
-    }
-
-    m_highTxMark = std::max( m_highTxMark.Get(), SEQ64TO32(mapping.TailDSN()));
-//      m_nextTxSequence = std::max(m_nextTxSequence.Get(), mapping.TailDSN() + 1);
-    NS_LOG_LOGIC("m_nextTxSequence=" << m_nextTxSequence << " m_highTxMark=" << m_highTxMark);
-  }
-
-
-
-  // TODO here send for all
-
-
-
-  uint32_t remainingData = m_txBuffer->SizeFromSequence(m_nextTxSequence );
-
-  if (m_closeOnEmpty && (remainingData == 0))
-    {
-      TcpHeader header;
-
-      ClosingOnEmpty(header);
-
-    }
-
-//  NS_LOG_LOGIC ("Dispatched " << nPacketsSent << " mappings");
-  return nbMappingsDispatched > 0;
-}
-#endif
-
-int
-MpTcpSocketBase::Listen (void)
-{
-  NS_LOG_FUNCTION (this);
-  NS_FATAL_ERROR("Disabled");
-  return 0;
-
-}
-
-
-void
-MpTcpSocketBase::OnSubflowDupAck(Ptr<MpTcpSubflow> sf)
-{
-  NS_LOG_DEBUG("Dup ack signaled by subflow " << sf );
-
-}
-
-
-// TODO move that away a t'on besoin de passer le mapping ?
-// OnRetransmit()
-// OnLoss
-#if 0
-void
-MpTcpSocketBase::ReduceCWND(uint8_t sFlowIdx)
-{
-
-
-  switch (m_algoCC)
-    {
-  case Uncoupled_TCPs:
-    sFlow->SetSSThresh( std::max(2 * m_segmentSize, BytesInFlight(sFlowIdx) / 2) );
-    sFlow->cwnd = sFlow->GetSSThresh() + 3 * m_segmentSize;
-    break;
-  case Linked_Increases:
-    sFlow->SetSSThresh( std::max(2 * m_segmentSize, BytesInFlight(sFlowIdx) / 2) );
-    sFlow->cwnd = sFlow->GetSSThresh() + 3 * m_segmentSize;
-    break;
-  case RTT_Compensator:
-    sFlow->SetSSThresh( std::max(2 * m_segmentSize, BytesInFlight(sFlowIdx) / 2) );
-    sFlow->cwnd = sFlow->GetSSThresh() + 3 * m_segmentSize;
-    break;
-  case Fully_Coupled:
-    cwnd_tmp = sFlow->cwnd - m_totalCwnd / 2;
-    if (cwnd_tmp < 0)
-      cwnd_tmp = 0;
-    sFlow->SetSSThresh( std::max((uint32_t) cwnd_tmp, 2 * m_segmentSize) );
-    sFlow->cwnd = sFlow->GetSSThresh() + 3 * m_segmentSize;
-    break;
-  default:
-    NS_ASSERT(3!=3);
-    break;
-    }
-
-}
-  #endif
-
-/**
-Retransmit timeout
-
-This function should be very interesting because one may
-adopt different strategies here, like reinjecting on other subflows etc...
-Maybe allow for a callback to be set here.
-*/
-void
-MpTcpSocketBase::Retransmit()
-{
-  NS_LOG_LOGIC(this);
-//  NS_FATAL_ERROR("TODO reestablish retransmit ?");
-//  NS_LOG_ERROR("TODO")
-  std::ostringstream oss;
-  Dump (oss);
-  NS_LOG_ERROR ( "Sthg fishy might have happened, it should not happen in our usual tests");
-  NS_LOG_DEBUG (oss.str());
-
-  m_nextTxSequence = FirstUnackedSeq(); // Start from highest Ack
-//  m_rtt->IncreaseMultiplier(); // Double the timeout value for next retx timer
-  m_dupAckCount = 0;
-  DoRetransmit(); // Retransmit the packet
-//  TcpSocketBase::Retransmit();
-}
-
-
-
-void
-MpTcpSocketBase::DoRetransmit()
-{
-  NS_LOG_FUNCTION (this);
-
-
-  // Retransmit SYN packet
-  if (m_state == SYN_SENT)
-    {
-      if (m_cnCount > 0)
-        {
-          // TODO
-          NS_FATAL_ERROR("TODO, first syn didn't reach it should be resent. Maybe this shoudl be let to the subflow");
-//          SendEmptyPacket(TcpHeader::SYN);
-        }
-      else
-        {
-          NotifyConnectionFailed ();
-        }
-      return;
-    }
-
-  // Retransmit non-data packet: Only if in FIN_WAIT_1 or CLOSING state
-  if (m_txBuffer->Size() == 0)
-    {
-      if (m_state == FIN_WAIT_1 || m_state == CLOSING)
-        {
-          // Must have lost FIN, re-send
-//          SendEmptyPacket(TcpHeader::FIN);
-          TcpHeader header;
-          SendFin();
-        }
-      return;
-    }
-  // Retransmit a data packet: Call SendDataPacket
-  NS_LOG_LOGIC ("TcpSocketBase " << this << " retxing seq " << FirstUnackedSeq ());
-
-//  m_rxBuffer->Dump();
-
-  DumpRxBuffers (0);
-
-//  SendDataPacket();
-
-//  NS_FATAL_ERROR ("TODO later, but for the tests only, it should not be necesssary ?! Check for anything suspicious");
-//  NS_LOG_ERROR ("TODO later, but for the tests only, it should not be necesssary ?! Check for anything suspicious");
-
-//
-//  m_nextTxSequence = FirstUnackedSeq();
-//  SendPendingData(true);
-//
-
-  // normally here m_nextTxSequence has been set to firstUna
-//  uint32_t sz = SendDataPacket(, m_segmentSize, true);
-//  // In case of RTO, advance m_nextTxSequence
-//  m_nextTxSequence = std::max(m_nextTxSequence.Get(), FirstUnackedSeq() + sz);
-  //reTxTrack.push_back(std::make_pair(Simulator::Now().GetSeconds(), ns3::TcpNewReno::cWnd));
-}
-
-void
-MpTcpSocketBase::SendFin ()
-{
-    Ptr<MpTcpSubflow> subflow = GetSubflow(0);
-//          m_state = FIN_WAIT_1;
-//          subflow->GenerateEmptyPacketHeader(header,);
-//      SendEmptyPacket(header);
-    subflow->AppendDSSFin();
-    subflow->SendEmptyPacket(TcpHeader::ACK);
-}
-
-void
-MpTcpSocketBase::ReTxTimeout()
-{
-  NS_LOG_FUNCTION(this);
-  return TcpSocketBase::ReTxTimeout();
-}
-
-
-
-void
-MpTcpSocketBase::GetAllAdvertisedDestinations (std::vector<InetSocketAddress>& cont)
-{
-  NS_ASSERT (m_remoteIdManager);
-  NS_FATAL_ERROR("Disabled");
-//  m_remoteIdManager->GetAllAdvertisedDestinations(cont);
-}
-
-
-void
-MpTcpSocketBase::SetNewAddrCallback (Callback<bool, Ptr<Socket>, Address, uint8_t> remoteAddAddrCb,
-                          Callback<void, uint8_t> remoteRemAddrCb)
-
-{
-  //
-  m_onRemoteAddAddr = remoteAddAddrCb;
-  m_onAddrDeletion = remoteRemAddrCb;
-}
-
-
-void
-MpTcpSocketBase::AddProbingRequest (uint8_t cookie,  Ptr<MpTcpSubflow> sf)
-{
-    NS_LOG_LOGIC (cookie << sf);
-#if 0
-    auto it = std::find(m_probingRequests.begin(), m_probingRequests.end(), cookie);
-    if(it == m_probingRequests.end())
-    {
-        //!
-        NS_LOG_DEBUG ("A request was pending");
-        m_probingRequests.insert ()
-    }
-    else
-    {
-    }
-#endif
-}
-
-void
-MpTcpSocketBase::AddCoupling (uint8_t localId0)
-{
-  NS_LOG_LOGIC ("Add coupling(s) for localId=" << localId0);
-#if 0
-  /* generate */
-  for ( auto it = m_subflows[Established].begin(); it != m_subflows[Established].end(); ++it)
-  {
-    // Create one coupling
-    Ptr<MpTcpSubflow> sf = (*it);
-    uint8_t localId1 = sf->GetLocalId ();
-
-    // Generate a pair <lowestId, highestId>
-    std::pair<uint8_t, uint8_t> key = std::make_pair (
-        std::min(localId0, localId1),
-        std::max(localId0, localId1)
-    );
-    Ptr<SubflowPair> couple = CreateObject<SubflowPair> ();
-//    SubflowPair temp;
-    // TODO we should arm the timer ?
-//    std::map<std::pair<uint8_t, uint8_t>, Ptr<SubflowPair> >::iterator
-    auto res = m_couplings.insert( std::make_pair(key, couple));
-    NS_ASSERT (res.second == false);
-  }
-  #endif
-}
-
-void
-MpTcpSocketBase::RemoveCoupling ( uint8_t localId)
-{
-  NS_LOG_LOGIC ("Remove coupling for localId " << (int)localId);
-  #if 0
-  for ( auto it = m_couplings.cbegin(); it != m_couplings.cend(); )
-  {
-    //! if either of the id in the key belongs to this subflow, then kill it !
-    if(it->first.first == localId || it->first.second == localId )
-    {
-      NS_LOG_DEBUG ("key is composed of localId " << (int)localId);
-      m_couplings.erase(it++);
-//      std::remove (m_couplings.begin(), m_couplings.end(), it->first.first);
-    }
-    else {
-        ++it;
-    }
-
-  }
-  #endif
-}
-
-void
-MpTcpSocketBase::MoveSubflow (Ptr<MpTcpSubflow> subflow, mptcp_container_t from, mptcp_container_t to)
-{
-
-  NS_LOG_DEBUG("Moving subflow " << subflow << " from " << containerNames[from] << " to " << containerNames[to]);
-  NS_ASSERT(from != to);
-  SubflowList::iterator it = std::find(m_subflows[from].begin(), m_subflows[from].end(), subflow);
-
-  if(it == m_subflows[from].end())
-  {
-    NS_LOG_ERROR("Could not find subflow in *from* container. It may have already been moved by another callback ");
-    DumpSubflows (std::cout);
-    return;
-  }
-
-  m_subflows[to].push_back(*it);
-//  m_scheduler->NotifyOfMove (to, subflow);
-#if 0
-  if (to == Established)
-  {
-    AddCoupling (subflow->GetLocalId());
-  }
-  else if (to == Closing)
-  {
-    RemoveCoupling (subflow->GetLocalId());
-  }
-#endif 
-  m_subflows[from].erase(it);
-}
-
-
-void
-MpTcpSocketBase::DumpSubflows (std::ostream &os) const
-{
-//  NS_LOG_FUNCTION(this << "\n");
-  for(int i = 0; i < Maximum; ++i)
-  {
-
-    os << "===== container [" << containerNames[i] << "]";
-//    Established
-//    NS_LOG_INFO("Closing all subflows in state [" << containerNames [i] << "]");
-    for( SubflowList::const_iterator it = m_subflows[i].begin(); it != m_subflows[i].end(); it++ )
-    {
-      os << "- subflow [" << *it  << "]";
-
-    }
-
-  }
-}
-/*
-We shouldn't need the from container, it could be found
-*/
-void
-MpTcpSocketBase::MoveSubflow(Ptr<MpTcpSubflow> subflow, mptcp_container_t to)
-{
-  NS_LOG_DEBUG("Moving subflow " << subflow << " to " << containerNames[to]);
-
-  for(int i = 0; i < Maximum; ++i)
-  {
-
-      SubflowList::iterator it = std::find(m_subflows[i].begin(), m_subflows[i].end(), subflow);
-      if(it != m_subflows[i].end())
-      {
-          NS_LOG_DEBUG("Found sf in container [" << containerNames[i] << "]");
-          MoveSubflow (subflow, static_cast<mptcp_container_t>(i), to);
-          return;
-      }
-
-  }
-
-  NS_FATAL_ERROR("Subflow not found in any container");
-
-  //! TODO it should call the meta
-  //! SetSendCallback (Callback<void, Ptr<Socket>, uint32_t> sendCb)
-//  subflow->SetSendCallback();
-
-
-}
-
-
-/*
-TODO rename into subflow created
-*/
-void
-MpTcpSocketBase::OnSubflowEstablished(Ptr<MpTcpSubflow> subflow)
-{
-
-
-  //! TODO We should try to steal the endpoint
-  if(subflow->IsMaster())
-  {
-    NS_LOG_LOGIC("Master subflow created, copying its endpoint");
-    m_endPoint = subflow->m_endPoint;
-    SetTcp (subflow->m_tcp);
-    SetNode (subflow->GetNode());
-
-    if(m_state == SYN_SENT || m_state == SYN_RCVD)
-    {
-      NS_LOG_LOGIC("Meta " << TcpStateName[m_state] << " -> ESTABLISHED");
-      m_state = ESTABLISHED;
-    }
-    else
-    {
-      NS_FATAL_ERROR("Unhandled case where subflow got established while meta in " << TcpStateName[m_state] );
-    }
-  // from
-    InetSocketAddress addr(subflow->m_endPoint->GetPeerAddress(), subflow->m_endPoint->GetPeerPort());
-//    NotifyNewConnectionCreated(subflow, addr);
-    NotifyNewConnectionCreated(this, addr);
-  }
-//  else
-//  {
-  ComputeTotalCWND();
-//  Simulator::ScheduleNow(&MpTcpSocketBase::NotifySubflowCreated, this, subflow );
-//  }
-}
-
-// TODO this could be done when tracking the subflow m_state
-void
-MpTcpSocketBase::OnSubflowEstablishment(Ptr<MpTcpSubflow> subflow)
-{
-  NS_LOG_LOGIC(this << " (=meta) New subflow " << subflow << " established");
-  //Ptr<MpTcpSubflow> subflow = DynamicCast<MpTcpSubflow>(sock);
-
-  NS_ASSERT_MSG(subflow, "Contact ns3 team");
-
-  ComputeTotalCWND();
-
-  if(subflow->IsMaster())
-  {
-    NS_LOG_LOGIC("Master subflow established, moving meta(server:" << m_server << ") from " << TcpStateName[m_state] << " to ESTABLISHED state");
-    if(m_state == SYN_SENT || m_state == SYN_RCVD)
-    {
-      NS_LOG_LOGIC("Meta " << TcpStateName[m_state] << " -> ESTABLISHED");
-      m_state = ESTABLISHED;
-    }
-    else
-    {
-      NS_LOG_WARN("Unhandled case where subflow got established while meta in " << TcpStateName[m_state] );
-    }
-
-    Simulator::ScheduleNow(&MpTcpSocketBase::ConnectionSucceeded, this);
-  }
-
-//  Simulator::ScheduleNow(&MpTcpSocketBase::NotifySubflowConnected, this, subflow);
-}
-
-
-void
-MpTcpSocketBase::NotifySubflowCreated(Ptr<MpTcpSubflow> sf)
-{
-  NS_LOG_FUNCTION(this << sf);
-  if (!m_subflowCreated.IsNull ())
-  {
-      m_subflowCreated (sf);
-  }
-}
-
-void
-MpTcpSocketBase::NotifySubflowConnected (Ptr<MpTcpSubflow> sf)
-{
-  NS_LOG_FUNCTION(this << sf);
-  if (!m_subflowConnectionSucceeded.IsNull ())
-    {
-      m_subflowConnectionSucceeded (sf);
-    }
-}
-
-
-
-//
-void
-MpTcpSocketBase::SetSubflowAcceptCallback(
-//  Callback<void, Ptr<MpTcpSubflow> > connectionRequest,
-  Callback<bool, Ptr<MpTcpSocketBase>, const Address &, const Address & > joinRequest,
-  Callback<void, Ptr<MpTcpSubflow> > connectionCreated
-)
-{
-  NS_LOG_FUNCTION(this << &joinRequest << " " << &connectionCreated);
-//  NS_LOG_WARN("TODO not implemented yet");
-//  m_subflowConnectionSucceeded = connectionCreated;
-  m_joinRequest = joinRequest;
-  m_subflowCreated = connectionCreated;
-}
-
-void
-MpTcpSocketBase::SetSubflowConnectCallback(
-  Callback<void, Ptr<MpTcpSubflow> > connectionSucceeded,
-  Callback<void, Ptr<MpTcpSubflow> > connectionFailure
-  )
-{
-  NS_LOG_FUNCTION(this << &connectionSucceeded);
-  m_subflowConnectionSucceeded = connectionSucceeded;
-  m_subflowConnectionFailure = connectionFailure;
-}
-
-//void
-//MpTcpSocketBase::SetJoinCreatedCallback(
-//  Callback<void, Ptr<MpTcpSubflow> > connectionCreated)
-//{
-//  NS_LOG_FUNCTION(this << &connectionCreated);
-//  m_subflowCreated = connectionCreated;
-//}
-
-
-
-TypeId
-MpTcpSocketBase::GetInstanceTypeId(void) const
-{
-  return MpTcpSocketBase::GetTypeId();
-}
-
-
-
-void
-MpTcpSocketBase::OnSubflowClosing(Ptr<MpTcpSubflow> sf)
-{
-  NS_LOG_LOGIC ("Subflow has gone into state ["
-//               << TcpStateName[sf->m_state]
-               );
-
-//
-//  /* if this is the last active subflow
-//
-//  */
-//  //FIN_WAIT_1
-//  switch( sf->m_state)
-//  {
-//    case FIN_WAIT_1:
-//    case CLOSE_WAIT:
-//    case LAST_ACK:
-//    default:
-//      break;
-//  };
-
-
-  MoveSubflow (sf, Established, Closing);
-  //      #TODO I need to Ack the DataFin in (DoPeerCLose)
-}
-
-
-void
-MpTcpSocketBase::OnSubflowDupack(Ptr<MpTcpSubflow> sf, MpTcpMapping mapping)
-{
-  NS_LOG_LOGIC("Subflow Dupack TODO.Nothing done by meta");
-}
-
-void
-MpTcpSocketBase::OnSubflowRetransmit(Ptr<MpTcpSubflow> sf)
-{
-  NS_LOG_INFO("Subflow retransmit. Nothing done by meta");
-}
-
-
-// renvoie m_highTxMark.Get() - m_txBuffer->HeadSequence(); should be ok even
-// if bytes may not really be in flight but rather in subflows buffer
-uint32_t
-MpTcpSocketBase::BytesInFlight ()
-{
-  NS_LOG_FUNCTION(this);
-  return TcpSocketBase::BytesInFlight();
-
-  #if 0
-  // can be removed I guess
-  uint32_t total = 0;
-
-  for( SubflowList::const_iterator it = m_subflows[Established].begin(); it != m_subflows[Established].end(); it++ )
-  {
-    total += (*it)->BytesInFlight();
-  }
-  #endif
-}
-
-//uint32_t
-//TcpSocketBase::UnAckDataCount()
-// TODO buggy ?
-//uint16_t
-//TcpSocketBase::AdvertisedWindowSize ()
-//{
-//  uint32_t w = m_rxBuffer->MaxBufferSize () - m_rxBuffer->Size ();
-//
-//  w >>= m_sndScaleFactor;
-//
-//  if (w > m_maxWinSize)
-//    {
-//      NS_LOG_WARN ("There is a loss in the adv win size, wrt buffer size");
-//      w = m_maxWinSize;
-//    }
-//
-//  return (uint16_t) w;
-//}
-uint16_t
-MpTcpSocketBase::AdvertisedWindowSize()
-{
-  NS_LOG_FUNCTION(this);
-  
-  uint32_t usedBufferSize = m_rxBuffer->Size ();
-
-  for (uint32_t i = 0; i < Maximum; i++)
-  {
-    for( SubflowList::const_iterator it = m_subflows[i].begin(); it != m_subflows[i].end(); it++ )
-    {
-        Ptr<MpTcpSubflow> sf = *it;
-       usedBufferSize += m_rxBuffer->Size ();
-    }
-  }
-
-  uint32_t w = m_rxBuffer->MaxBufferSize () - usedBufferSize;
-  
-  w >>= m_sndScaleFactor;
-
-  if (w > m_maxWinSize)
-    {
-      NS_LOG_WARN ("There is a loss in the adv win size, wrt buffer size");
-      w = m_maxWinSize;
-    }
-
-  return (uint16_t) w;
-//  return TcpSocketBase::AdvertisedWindowSize();
-//  NS_LOG_DEBUG("Advertised Window size of " << value );
-//  return value;
-}
-
-/* of if cwnd updated properly */
-uint32_t
-MpTcpSocketBase::Window()
-{
-  NS_LOG_FUNCTION (this);
-  return TcpSocketBase::Window();
-}
-
-
-uint32_t
-MpTcpSocketBase::AvailableWindow()
-{
-  NS_LOG_FUNCTION (this);
-  uint32_t unack = UnAckDataCount(); // Number of outstanding bytes
-  uint32_t win = Window(); // Number of bytes allowed to be outstanding
-  NS_LOG_LOGIC ("UnAckCount=" << unack << ", Win=" << win);
-  return (win < unack) ? 0 : (win - unack);
-}
-
-
-/**
-This does not change much for now
-**/
-//Time
-//MpTcpSocketBase::ComputeReTxTimeoutForSubflow( Ptr<MpTcpSubflow> sf)
-//{
-//  NS_ASSERT(sf);
-//    //ReTxTimeout
-//  return sf->
-////  m_rtt->RetransmitTimeout();
-//}
-
-
-
-
-
-void
-MpTcpSocketBase::ClosingOnEmpty(TcpHeader& header)
-{
-  /* TODO the question is: is that ever called ?
-  */
-  NS_LOG_INFO("closing on empty called");
-  //      GenerateEmptyPacketHeader(header);
-// sets the datafin
-//    header.SetFlags( header.GetFlags() | TcpHeader::FIN);
-//    // flags |= TcpHeader::FIN;
-//    if (m_state == ESTABLISHED)
-//    { // On active close: I am the first one to send FIN
-//      NS_LOG_INFO ("ESTABLISHED -> FIN_WAIT_1");
-//      m_state = FIN_WAIT_1;
-//      // TODO get DSS, if none
-//      Ptr<TcpOptionMpTcpDSS> dss;
-//
-//      //! TODO add GetOrCreate member
-//      if(!GetMpTcpOption(header, dss))
-//      {
-//        // !
-//        dss = Create<TcpOptionMpTcpDSS>();
-//
-//      }
-//      dss->SetDataFin(true);
-//      header.AppendOption(dss);
-//
-//    }
-//    else if (m_state == CLOSE_WAIT)
-//    { // On passive close: Peer sent me FIN already
-//      NS_LOG_INFO ("CLOSE_WAIT -> LAST_ACK");
-//      m_state = LAST_ACK;
-//    }
-}
-
-
-/** Inherit from Socket class: Kill this socket and signal the peer (if any) */
-int
-MpTcpSocketBase::Close (void)
-{
-  NS_LOG_FUNCTION (this);
-  return TcpSocketBase::Close();
-  #if 0
-  // First we check to see if there is any unread rx data
-  // Bug number 426 claims we should send reset in this case.
-// TODO reestablish ?
-//  if (m_rxBuffer->Size() != 0)
-  if (GetRxAvailable() != 0)
-  {
-    NS_FATAL_ERROR("TODO rxbuffer != 0");
-      SendRST();
-      return 0;
-  }
-
-  uint32_t remainingData = m_txBuffer->SizeFromSequence(m_nextTxSequence);
-//  uint32_t remainingData = GetTxAvailable();
-
-
-  NS_LOG_UNCOND("Call to close: data =" << remainingData );
-
-  if (remainingData > 0)
-  {
-
-    // App close with pending data must wait until all data transmitted
-    if (m_closeOnEmpty == false)
-    {
-      m_closeOnEmpty = true;
-      NS_LOG_INFO ("Socket " << this << " deferring close, state " << TcpStateName[m_state]);
-    }
-    return 0;
-  }
-
-  //!
-  return DoClose();
-  #endif
-}
-
-void
-MpTcpSocketBase::CloseAllSubflows()
-{
-  NS_LOG_FUNCTION(this << "Closing all subflows");
-  NS_ASSERT( m_state == FIN_WAIT_2 || m_state == CLOSING || m_state == CLOSE_WAIT || m_state == LAST_ACK);
-
-  for(int i = 0; i < Closing; ++i)
-  {
-//    Established
-    NS_LOG_INFO("Closing all subflows in state [" << containerNames [i] << "]");
-//    std::for_each( );
-    for( SubflowList::const_iterator it = m_subflows[i].begin(); it != m_subflows[i].end(); it++ )
-    {
-        Ptr<MpTcpSubflow> sf = *it;
-        //   TODO trigger events in path manager
-          NS_LOG_LOGIC("Closing sf " << sf);
-
-          int ret = sf->Close();
-//        }
-        NS_ASSERT_MSG(ret == 0, "Can't close subflow");
-    }
-
-    m_subflows[Closing].insert( m_subflows[Closing].end(), m_subflows[i].begin(), m_subflows[i].end());
-    m_subflows[i].clear();
-    //! Once subflow of current container were closed, we move everything to
-    //!
-//    MoveSubflow(sf, Closing);
-  }
-}
-
-
-
-void
-MpTcpSocketBase::ReceivedAck(
-  SequenceNumber32 dack
-  , Ptr<MpTcpSubflow> sf
-  , bool count_dupacks
-  )
-{
-//    NS_FATAL_ERROR("Received DACK " << dack << "from subflow" << sf << "(Enable dupacks:" << count_dupacks << " )");
-  NS_LOG_FUNCTION("Received DACK " << dack << "from subflow" << sf << "(Enable dupacks:" << count_dupacks << " )");
-//  NS_ASSERT( dss->GetFlags() & TcpOptionMpTcpDSS::DataAckPresent);
-
-//  SequenceNumber32 dack = SequenceNumber32(dss->GetDataAck());
-
-//  TcpSocketBase::ReceivedAck(dack);
-//#if 0
-  if (dack < FirstUnackedSeq())
-    { // Case 1: Old ACK, ignored.
-      NS_LOG_LOGIC ("Old ack Ignored " << dack  );
-    }
-  else if (dack  == FirstUnackedSeq())
-    { 
-      // If in closing state, should trigger timewait
-      if(m_state == CLOSING) 
-      {
-        NS_LOG_WARN ("MAYBE SHOULD ENTER TIMEWAIT here");
-        TimeWait();
-        return;
-      }
-      
-      // Case 2: Potentially a duplicated ACK
-      if (dack  < m_nextTxSequence && count_dupacks)
-        {
-        /* TODO dupackcount shall only be increased if there is only a DSS option ! */
-//          NS_LOG_WARN ("TODO Dupack of " << dack << " not handled yet." );
-          // TODO add new prototpye ?
-
-//            DupAck(dack, sf, ++m_dupAckCount);
-        }
-      // otherwise, the ACK is precisely equal to the nextTxSequence
-      NS_ASSERT( dack  <= m_nextTxSequence);
-    }
-  else if (dack  > FirstUnackedSeq())
-    { // Case 3: New ACK, reset m_dupAckCount and update m_txBuffer
-      NS_LOG_LOGIC ("New DataAck [" << dack  << "]");
-
-      NewAck( dack );
-      m_dupAckCount = 0;
-    }
-
-//#endif
-}
-
-
-
-
-
-
-/** Received a packet upon CLOSE_WAIT, FIN_WAIT_1, or FIN_WAIT_2 states */
-//void
-//MpTcpSocketBase::ProcessWait(Ptr<Packet> packet, const TcpHeader& tcpHeader)
-//{
-//  NS_LOG_FUNCTION (this << tcpHeader);
-//
-//  NS_FATAL_ERROR("TO remove");
-//
-//}
-
-
-/** Peacefully close the socket by notifying the upper layer and deallocate end point */
-//void
-//MpTcpSocketBase::CloseAndNotify(void)
-//{
-//  NS_LOG_FUNCTION (this);
-//
-//  if (!m_closeNotified)
-//    {
-//      NotifyNormalClose();
-//    }
-//  if (m_state != TIME_WAIT)
-//    {
-//      DeallocateEndPoint();
-//    }
-//  m_closeNotified = true;
-//  NS_LOG_INFO (TcpStateName[m_state] << " -> CLOSED");
-//  CancelAllTimers();
-//  m_state = CLOSED;
-//
-//}
-
-/** Move TCP to Time_Wait state and schedule a transition to Closed state */
-void
-MpTcpSocketBase::TimeWait()
-{
-  NS_LOG_FUNCTION (this);
-  Time timewait_duration = Seconds(2 * m_msl);
-  NS_LOG_INFO (TcpStateName[m_state] << " -> TIME_WAIT "
-              << "with duration of " << timewait_duration
-              << "; m_msl=" << m_msl);
-//  TcpSocketBase::TimeWait();
-  CloseAllSubflows ();
-  m_state = TIME_WAIT;
-  CancelAllTimers ();
-//  // Move from TIME_WAIT to CLOSED after 2*MSL. Max segment lifetime is 2 min
-//  // according to RFC793, p.28
-  m_timewaitEvent = Simulator::Schedule(timewait_duration, &MpTcpSocketBase::OnTimeWaitTimeOut, this);
-}
-
-void
-MpTcpSocketBase::OnTimeWaitTimeOut(void)
-{
-  // Would normally call CloseAndNotify
-  NS_LOG_LOGIC ("Timewait timeout expired");
-  NS_LOG_UNCOND ("after timewait timeout, there are still " << m_subflows[Closing].size() << " subflows pending");
-  // TODO send RST and destory these subflows ?
-  CloseAndNotify ();
-}
-
-/** Peacefully close the socket by notifying the upper layer and deallocate end point */
-void
-MpTcpSocketBase::CloseAndNotify(void)
-{
-  NS_LOG_FUNCTION (this);
-
-  // TODO check the number of open subflows
-  if (!m_closeNotified)
-    {
-      NotifyNormalClose();
-    }
-  if (m_state != TIME_WAIT)
-    {
-      DeallocateEndPoint();
-    }
-  m_closeNotified = true;
-  NS_LOG_INFO (TcpStateName[m_state] << " -> CLOSED");
-  CancelAllTimers();
-  m_state = CLOSED;
-
-}
-
-/* Peer sent me a DATA FIN. Remember its sequence in rx buffer.
-It means there won't be any mapping above that dataseq
-*/
-
-void
-MpTcpSocketBase::PeerClose(Ptr<Packet> p, const TcpHeader& tcpHeader)
-{
-  NS_LOG_FUNCTION(this << " PEER CLOSE CALLED !" << tcpHeader);
-
-  NS_FATAL_ERROR("TO REMOVE. Function overriden by PeerClose(subflow)");
-
-//  Ptr<TcpOptionMpTcpDSS> dss;
-//  NS_ASSERT_MSG( GetMpTcpOption(tcpHeader,dss), "If this function was called, it must be because a dss had been found" );
-//  NS_ASSERT( dss->GetFlags() & TcpOptionMpTcpDSS::DataFin);
-//
-//  /* */
-//  SequenceNumber32 dsn = SequenceNumber32 (dss->GetDataFinDSN() );
-//  if( dsn < m_rxBuffer->NextRxSequence() || m_rxBuffer->MaxRxSequence() < dsn) {
-//      //!
-//    NS_LOG_INFO("dsn " << dsn << " out of expected range [ " << m_rxBuffer->NextRxSequence()  << " - " << m_rxBuffer->MaxRxSequence() << " ]" );
-//    return ;
-//  }
-
-}
-
-/** Received a in-sequence FIN. Close down this socket. */
-// FIN is in sequence, notify app and respond with a FIN
-// TODO remove DoPeerClose ?
-void
-MpTcpSocketBase::DoPeerClose (void)
-{
-  NS_FATAL_ERROR("To remove");
-//  NS_ASSERT(m_state == ESTABLISHED || m_state == SYN_RCVD);
-
-  // Move the state to CLOSE_WAIT
-  NS_LOG_INFO (TcpStateName[m_state] << " -> CLOSE_WAIT");
-  m_state = CLOSE_WAIT;
-
-  if (!m_closeNotified)
-    {
-      // The normal behaviour for an application is that, when the peer sent a in-sequence
-      // FIN, the app should prepare to close. The app has two choices at this point: either
-      // respond with ShutdownSend() call to declare that it has nothing more to send and
-      // the socket can be closed immediately; or remember the peer's close request, wait
-      // until all its existing data are pushed into the TCP socket, then call Close()
-      // explicitly.
-      NS_LOG_LOGIC ("TCP " << this << " calling NotifyNormalClose");
-      NotifyNormalClose ();
-      m_closeNotified = true;
-    }
-  if (m_shutdownSend)
-    { // The application declares that it would not sent any more, close this socket
-      Close();
-    }
-    else
-    { // Need to ack, the application will close later
-//    #error TODO send Dataack
-      TcpHeader header;
-      NS_LOG_WARN ("Likely to crash ?");
-      GenerateEmptyPacketHeader(header, TcpHeader::ACK);
-      //!
-      Ptr<MpTcpSubflow> sf = GetSubflow(0);
-      sf->AppendDSSAck();
-      sf->SendEmptyPacket(header);
-    }
-
-  if (m_state == LAST_ACK)
-  {
-      NS_LOG_LOGIC ("TcpSocketBase " << this << " scheduling Last Ack timeout 01 (LATO1)");
-      NS_FATAL_ERROR("TODO");
-//      m_lastAckEvent = Simulator::Schedule(m_rtt->RetransmitTimeout(), &TcpSocketBase::LastAckTimeout, this);
-    }
-}
-
-
-// TODO this could be reimplemented via choosing
-void
-MpTcpSocketBase::SendEmptyPacket(TcpHeader& header)
-{
-  NS_FATAL_ERROR("Disabled. Should call subflow member");
-}
-
-
-/** Do the action to close the socket. Usually send a packet with appropriate
- flags depended on the current m_state.
-
- TODO use a closeAndNotify in more situations
- */
-int
-MpTcpSocketBase::DoClose()
-{
-  NS_LOG_FUNCTION(this << " in state " << TcpStateName[m_state]);
-
-  // TODO close all subflows
-  // TODO send a data fin
-  // TODO ideally we should be able to work without any subflows and
-  // retransmit as soon as we get a subflow up !
-  // TODO we should ask the scheduler on what subflow to send the messages
-  TcpHeader header;
-
-
-
-
-  switch (m_state)
-  {
-  case SYN_RCVD:
-  case ESTABLISHED:
-// send FIN to close the peer
-      {
-      NS_LOG_INFO ("ESTABLISHED -> FIN_WAIT_1");
-
-
-      m_state = FIN_WAIT_1;
-      Ptr<MpTcpSubflow> subflow = GetSubflow(0);
-      subflow->GenerateEmptyPacketHeader(header,TcpHeader::ACK);
-//      SendEmptyPacket(header);
-      subflow->AppendDSSFin();
-      subflow->SendEmptyPacket(header);
-      }
-      break;
-
-  case CLOSE_WAIT:
-      {
-// send ACK to close the peer
-      NS_LOG_INFO ("CLOSE_WAIT -> LAST_ACK");
-      Ptr<MpTcpSubflow> subflow = GetSubflow(0);
-      m_state = LAST_ACK;
-
-      subflow->GenerateEmptyPacketHeader(header, TcpHeader::ACK);
-      subflow->AppendDSSAck();
-      subflow->SendEmptyPacket(header);
-//      SendEmptyPacket(TcpHeader::FIN | TcpHeader::ACK);
-      }
-
-      break;
-
-  case SYN_SENT:
-//      SendRST();
-//      CloseAndNotify();
-
-  case CLOSING:
-// Send RST if application closes in SYN_SENT and CLOSING
-// TODO deallocate all childrne
-      NS_LOG_WARN ("trying to close while closing..");
-//      NS_LOG_INFO ("CLOSING -> LAST_ACK");
-//      m_state = TIME_WAIT;
-//        NotifyErrorClose();
-//      DeallocateEndPoint();
-
-      break;
-  case LISTEN:
-      CloseAndNotify();
-      break;
-  case LAST_ACK:
-      TimeWait();
-      break;
-  case CLOSED:
-  case FIN_WAIT_1:
-  case FIN_WAIT_2:
-    break;
-  case TIME_WAIT:
-//      CloseAndNotify();
-      break;
-
-  default: /* mute compiler */
-// Do nothing in these four states
-      break;
-  }
-  return 0;
-}
-
-
-
-
-
-Ptr<Packet>
-MpTcpSocketBase::Recv(uint32_t maxSize, uint32_t flags)
-{
-  NS_LOG_FUNCTION(this);
-  return TcpSocketBase::Recv(maxSize,flags);
-  // TODO here I could choose to discard mappings
-}
-
-
-
-uint32_t
-MpTcpSocketBase::GetTxAvailable(void) const
-{
-  NS_LOG_FUNCTION (this);
-  uint32_t value = m_txBuffer->Available();
-  NS_LOG_DEBUG("Tx available " << value);
-  return value;
-}
-
-//this would not accomodate with google option that proposes to add payload in
-// syn packets MPTCP
-/**
-cf RFC:
-
-   To compute cwnd_total, it is an easy mistake to sum up cwnd_i across
-   all subflows: when a flow is in fast retransmit, its cwnd is
-   typically inflated and no longer represents the real congestion
-   window.  The correct behavior is to use the ssthresh (slow start
-   threshold) value for flows in fast retransmit when computing
-   cwnd_total.  To cater to connections that are app limited, the
-   computation should consider the minimum between flight_size_i and
-   cwnd_i, and flight_size_i and ssthresh_i, where appropriate.
-
-TODO fix this to handle fast recovery
-**/
-uint32_t
-MpTcpSocketBase::ComputeTotalCWND ()
-{
-  NS_LOG_DEBUG("Cwnd before update=" << Window()
-//               m_tcb->m_cWnd.Get()
-               );
-
-  uint32_t totalCwnd = 0;
-
-  for (uint32_t i = 0; i < Maximum; i++)
-  {
-    for( SubflowList::const_iterator it = m_subflows[i].begin(); it != m_subflows[i].end(); it++ )
-    {
-        Ptr<MpTcpSubflow> sf = *it;
-
-        // when in fast recovery, use SS threshold instead of cwnd
-        if(sf->m_tcb->m_ackState == TcpSocketState::RECOVERY)
-        {
-          NS_LOG_DEBUG("Is in Fast recovery");
-          totalCwnd += sf->m_tcb->m_ssThresh;
-        }
-        else
-        {
-//          NS_LOG_WARN("Don't consider Fast recovery yet");
-
-          uint32_t inc = sf->m_tcb->m_cWnd.Get();
-            NS_LOG_DEBUG("Adding " << inc << " to total window");
-          totalCwnd += inc;
-        }
-    }
-  }
-  m_tcb->m_cWnd = totalCwnd;
-  NS_LOG_DEBUG ("Cwnd after computation=" << m_tcb->m_cWnd.Get());
-  return totalCwnd;
-}
-
-
-
-
-
-
-/** Kill this socket. This is a callback function configured to m_endpoint in
- SetupCallback(), invoked when the endpoint is destroyed. */
-void
-MpTcpSocketBase::Destroy(void)
-{
-  NS_LOG_FUNCTION(this);
-  NS_LOG_INFO("Enter Destroy(" << this << ") m_sockets: )");
-
-  NS_LOG_ERROR ("Before unsetting endpoint, check it's not used by subflow ?");
-  m_endPoint = 0;
-  // TODO loop through subflows and Destroy them too ?
-//  if (m_tcp != 0)
-//    {
-//      std::vector<Ptr<TcpSocketBase> >::iterator it = std::find(m_tcp->m_sockets.begin(), m_tcp->m_sockets.end(), this);
-//      if (it != m_tcp->m_sockets.end())
-//        {
-//          m_tcp->m_sockets.erase(it);
-//        }
-//    }
-//  CancelAllSubflowTimers();
-//  NS_LOG_INFO("Leave Destroy(" << this << ") m_sockets:  " << m_tcp->m_sockets.size()<< ")");
-}
-
-
-
-
-}  //namespace ns3
diff --git a/src/internet/model/mptcp-socket-base.h b/src/internet/model/mptcp-socket-base.h
deleted file mode 100644
index 50840a7..0000000
--- a/src/internet/model/mptcp-socket-base.h
+++ /dev/null
@@ -1,924 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#ifndef MPTCP_SOCKET_BASE_H
-#define MPTCP_SOCKET_BASE_H
-
-#include "ns3/callback.h"
-#include "ns3/mptcp-mapping.h"
-#include "ns3/tcp-socket-base.h"
-//#include "mp-tcp-subflow.h"
-
-//#include "ns3/mp-tcp-cc.h"
-#include "ns3/inet-socket-address.h"
-#include "ns3/mptcp-id-manager.h"
-#include "ns3/mptcp-scheduler.h"
-//#include "ns3/mptcp-scheduler-round-robin.h"
-
-//using namespace std;
-
-namespace ns3
-{
-class Ipv4EndPoint;
-class Node;
-class Packet;
-class TcpL4Protocol;
-class MpTcpPathIdManager;
-class MpTcpSubflow;
-//class MpTcpSchedulerRoundRobin;
-//class MpTcpCongestionControl;
-class SubflowPair;
-class TcpOptionMpTcpDSS;
-class TcpOptionMpTcpJoin;
-class MpTcpScheduler;
-class OutputStreamWrapper;
-
-
-/**
-TODO move all the supplementary stuff to MpTcpSocketState
-remove the bind, in fact this socket should not care about m_endPoint
-so it could be removed as well
-*/
-//class MpTcpSocketState : TcpSocketState
-//{
-//
-//public:
-//    MpTcpSocketState();
-//    ~MpTcpSocketState();
-//
-//};
-
-/**
- * \class MpTcpSocketBase
-
-This is the MPTCP meta socket the application talks with
-this socket. New subflows, as well as the first one (the master
-socket) are linked to this meta socket.
-
-Every data transfer happens on a subflow.
-Following the linux kernel from UCL (http://multipath-tcp.org) convention,
-the first established subflow is called the "master" subflow.
-
-This inherits TcpSocketBase so that it can be  used as any other TCP variant:
-this is the backward compability feature that is required in RFC.
-Also doing so allows to run TCP tests with MPTCP via for instance the command
-Config::SetDefault ("ns3::TcpL4Protocol::SocketType", "ns3::MpTcpOlia");
-
-But to make sure some inherited functions are not improperly used, we need to redefine them so that they
-launch an assert. You can notice those via the comments "//! Disabled"
-
-As such many inherited (protected) functions are overriden & left empty.
-
-
-As in linux, the meta should return the m_endPoint information of the master,
-even if that subflow got closed during the MpTcpConnection.
-
-
-
-
-ConnectionSucceeded may be called twice; once when it goes to established
-and the second time when it sees
- Simulator::ScheduleNow(&MpTcpSocketBase::ConnectionSucceeded, this);
-
-TODO:
--rename in MetaSocket ?
--Ideally it could & should inherit from TcpSocket rather TcpSocketBase
--should use 64 bits based buffer / sq nb
-
-**/
-class MpTcpSocketBase :
-    public TcpSocketBase
-// public TcpSocket
-
-{
-public:
-  /** public methods
-  TODO this could be done differently
-  **/
-  typedef std::vector< Ptr<MpTcpSubflow> > SubflowList;
-
-  static TypeId GetTypeId(void);
-
-  virtual TypeId GetInstanceTypeId (void) const;
-
-  MpTcpSocketBase();
-private:
-  MpTcpSocketBase(const MpTcpSocketBase&);
-
-public:
-//  MpTcpSocketBase(const TcpSocketBase&);
-
-  virtual ~MpTcpSocketBase();
-
-  /**
-   * Should be called only by subflows when they update their receiver window
-   */
-//  virtual bool UpdateWindowSize(const TcpHeader& header);
-
-protected:
-   ////////////////////////////////////////////
-   /// List of overriden callbacks
-   ////////////////////////////////////////////
-  /**
-   * This is callback called by subflow NotifyNewConnectionCreated. If
-   * the calling subflow is the master, then the call is forwarded through meta's
-   * NotifyNewConnectionCreated, else it is forward to the JoinCreatedCallback
-   *
-   * \see Socket::NotifyNewConnectionCreated
-   */
-  virtual void OnSubflowCreated (Ptr<Socket> socket, const Address &from);
-  virtual void OnSubflowConnectionFailure (Ptr<Socket> socket);
-  virtual void OnSubflowConnectionSuccess (Ptr<Socket> socket);
-
-public:
-  /**
-  these callbacks will be passed on to
-   * \see Socket::Set
-   * what about failures ?
-   */
-  virtual void
-  SetSubflowAcceptCallback(Callback<bool, Ptr<MpTcpSocketBase>, const Address &, const Address & > connectionRequest,
-                           Callback<void, Ptr<MpTcpSubflow> > connectionCreated
-                           );
-
-  virtual void
-  SetSubflowConnectCallback(Callback<void, Ptr<MpTcpSubflow> > connectionSucceeded,
-                           Callback<void, Ptr<MpTcpSubflow> > connectionFailure
-                            );
-
-//  virtual void
-//  SetJoinCreatedCallback(Callback<void, Ptr<MpTcpSubflow> >);
-
-  /**
-   * Triggers callback registered by SetSubflowAcceptCallback
-   */
-  void
-  NotifySubflowCreated(Ptr<MpTcpSubflow> sf);
-
-  /**
-   * Triggers callback registered by SetSubflowConnectCallback
-   */
-  void
-  NotifySubflowConnected(Ptr<MpTcpSubflow> sf);
-
-  /**
-   * Called when a subflow TCP state is updated.
-   * It detects such events by tracing its subflow m_state.
-   *
-   */
-  virtual void
-  OnSubflowNewCwnd(std::string context, uint32_t oldCwnd, uint32_t newCwnd);
-
-  /**
-   * Initiates a new subflow with MP_JOIN
-   *
-   * Wrapper that just creates a subflow, bind it to a specific address
-   * and then establishes the connection
-   */
-  virtual int
-  ConnectNewSubflow(const Address &local, const Address &remote);
-
-  virtual void
-  DoRetransmit();
-
-  /**
-   * Called when a subflow TCP state is updated.
-   * It detects such events by tracing its subflow m_state.
-   *
-   * \param context
-   * \param sf Subflow that changed state
-   * \param oldState previous TCP state of the subflow
-   * \param newState new TCP state of the subflow
-   */
-  virtual void
-  OnSubflowNewState(
-    std::string context,
-    Ptr<MpTcpSubflow> sf,
-    TcpStates_t  oldState,
-    TcpStates_t newState
-    );
-
-  // Window Management
-  virtual uint32_t
-  BytesInFlight();  // Return total bytes in flight of a subflow
-
-  void
-  DumpRxBuffers(Ptr<MpTcpSubflow> sf) const;
-
-//  void
-//  ProcessWait(Ptr<Packet> packet, const TcpHeader& tcpHeader);
-
-//  static void
-//  GenerateTokenForKey( mptcp_crypto_t alg, uint64_t key, uint32_t& token, uint64_t& idsn);
-
-  /* Sum congestio nwindows across subflows to compute global cwin
-  WARNING: it does not take flows that are closing yet so that may be a weakness depending on the scenario
-  to update
-   Should it be done rather in CC ?
-   according to RFC:
-   To compute cwnd_total, it is an easy mistake to sum up cwnd_i across
-   all subflows: when a flow is in fast retransmit, its cwnd is
-   typically inflated and no longer represents the real congestion
-   window.  The correct behavior is to use the ssthresh (slow start
-   threshold) value for flows in fast retransmit when computing
-   cwnd_total.  To cater to connections that are app limited, the
-   computation should consider the minimum between flight_size_i and
-   cwnd_i, and flight_size_i and ssthresh_i, where appropriate.
-  */
-  virtual uint32_t
-  ComputeTotalCWND ();
-
-  /**
-   * I suppose it would be best to have TcpRxBuffer memory shared between all subflows
-   * and retrieve occupied size from there but it's hard with the current infrastructure
-   * For now loop over subflows and retrieve their buffer usage
-   */
-  virtual uint16_t
-  AdvertisedWindowSize();
-
-  // TODO remove
-  virtual uint32_t
-  AvailableWindow();
-  /**
-  \warn This function should be called once a connection is established else
-  **/
-//  virtual bool IsMpTcpEnabled() const;
-
-
-  virtual void CloseAndNotify(void);
-
-  /** Limit the size of in-flight data by cwnd and receiver's rxwin */
-  virtual uint32_t
-  Window (void);
-
-  virtual void
-  PersistTimeout();
-
-  /* equivalent to PeerClose
-  \param finalDsn
-  OnDataFin
-  */
-  virtual void
-  PeerClose( SequenceNumber32 fin_seq, Ptr<MpTcpSubflow> sf);
-
-  virtual void
-  OnInfiniteMapping(Ptr<TcpOptionMpTcpDSS> dss, Ptr<MpTcpSubflow> sf);
-
-  /* equivalent to TCP Rst */
-  virtual void
-  SendFastClose(Ptr<MpTcpSubflow> sf);
-
-  /**
-  \brief Generates random key, setups isdn and token
-  **/
-//  virtual uint64_t GenerateKey();
-
-  virtual void InitLocalISN(const SequenceNumber32& seq);
-
-  /**
-  * TODO when is it considered
-  * move to TcpSocketBase ?
-  * \return
-  */
-  bool IsConnected() const;
-
-  // Public interface for MPTCP
-  // Disabled
-  virtual int Bind();
-  virtual int Bind(const Address &address);
-  virtual int Connect(const Address &address);
-
-  // TODO to remove there is no equivalent in parent's class
-//  virtual int Connect(Ipv4Address servAddr, uint16_t servPort);
-
-  //! Disabled
-  virtual int Listen(void);
-
-  /**
-   * \brief Same as MpTcpSocketBase::Close
-   *
-   * The default behavior is to do nothing until all the data is transmitted.
-   * Only then are
-  RFC 6824:
-   - When an application calls close() on a socket, this indicates that it
-   has no more data to send; for regular TCP, this would result in a FIN
-   on the connection.  For MPTCP, an equivalent mechanism is needed, and
-   this is referred to as the DATA_FIN.
-
-   - A DATA_FIN has the semantics and behavior as a regular TCP FIN, but
-   at the connection level.  Notably, it is only DATA_ACKed once all
-   data has been successfully received at the connection level
-  */
-  // socket function member
-  virtual int Close(void);
-
-  /**
-  RFC 6824
-  - If all subflows have
-   been closed with a FIN exchange, but no DATA_FIN has been received
-   and acknowledged, the MPTCP connection is treated as closed only
-   after a timeout.  This implies that an implementation will have
-   TIME_WAIT states at both the subflow and connection levels (see
-   Appendix C).  This permits "break-before-make" scenarios where
-   connectivity is lost on all subflows before a new one can be re-
-   established.
-  */
-//  virtual void
-//  PeerClose(Ptr<Packet>, const TcpHeader&); // Received a FIN from peer, notify rx buffer
-
-  /* called by subflow when it sees a DSS with the DATAFIN flag
-  Params are ignored
-  \param packet Ignored
-  */
-  virtual void
-  PeerClose(Ptr<Packet> packet, const TcpHeader&); // Received a FIN from peer, notify rx buffer
-  virtual void
-  DoPeerClose(void); // FIN is in sequence, notify app and respond with a FIN
-
-  virtual int DoClose(void);
-//  virtual void
-//  CloseAndNotify(void); // To CLOSED state, notify upper layer, and deallocate end point
-
-  virtual uint32_t GetTxAvailable() const;
-  virtual uint32_t GetRxAvailable(void) const;
-
-  // TODO maybe this could be removed ?
-//  void DoForwardUp(Ptr<Packet> packet, Ipv4Header header, uint16_t port, Ptr<Ipv4Interface> incomingInterface);
-  virtual void ForwardUp (Ptr<Packet> packet, Ipv4Header header, uint16_t port, Ptr<Ipv4Interface> incomingInterface);
-
-  /**
-  \return Number of connected subflows (that is that ran the 3whs)
-  */
-  SubflowList::size_type GetNActiveSubflows() const;
-
-
-  /**
-   *
-   * \return an established subflow
-   */
-  virtual Ptr<MpTcpSubflow> GetSubflow(uint8_t pos) const;
-
-  /**
-   * \param addrId Address id as registered in path manager
-   * \assert if could not find subflow
-   */
-  virtual Ptr<MpTcpSubflow> GetSubflowFromAddressId (uint8_t addrId) const;
-
-  // can Potentially be removed ?
-  virtual void ClosingOnEmpty(TcpHeader& header);
-
-  /**
-   * \brief Send a fast close
-   *
-   * Sends RST on all subflows
-   * and MP_FASTCLOSE on one of the subflows
-   */
-  virtual void SendRST(void);
-
-  /**
-   * The connection is considered fully established
-   * when it can create new subflows, i.e., when it received
-   * a first dss ack
-   */
-  virtual bool FullyEstablished() const;
-
-  /**
-   * This retriggers Connection success callback
-   * You have to check in the callback if it fully estalbished or not
-   */
-  virtual void BecomeFullyEstablished();
-
-  /** TODO superseed into TcpSocketBase
-  Here it sends MP_FIN
-   */
-  virtual void SendFin();
-
-  /**
-  public equivalent ?
-  * \brief
-  * \param srcAddr Address to bind to. In theory Can be an InetSocketAddress or an Inet6SocketAddress
-  * for now just InetSocketAddress
-  */
-  Ptr<MpTcpSubflow> CreateSubflow(bool masterSocket);
-
-  /**
-   * Initiate
-   * - establish link between subflow and meta
-   * - Setup subflow callbacks
-   * - assign congestion control
-   * - adds the
-   *
-   * TODO should we use the aggregate mechanism instead ? could we even ?
-   * TODO rename into SetupSubflow ?
-   * WARN does not add Subflow into TcpL4Protocol
-   */
-  virtual void AddSubflow (Ptr<MpTcpSubflow> sf);
-
-
-  // Path management related functions
-
-//  virtual int GenerateToken(uint32_t& token ) const;
-
-  virtual void Destroy(void);
-  /**
-  \return 0 In case of success
-  TODO bool ?
-  **/
-  //int GetPeerKey(uint64_t& remoteKey) const;
-  uint64_t GetPeerKey() const;
-
-  /**
-  \brief Generated during the initial 3 WHS
-  */
-  uint64_t GetLocalKey() const;
-
-  /**
-   * \return Hash of the local key
-   */
-  uint32_t GetLocalToken() const;
-
-  /**
-   * \return Hash of the peer key
-   */
-  uint32_t GetPeerToken() const;
-
-    /**
-  For now it looks there is no way to know that an ip interface went up so we will assume until
-  further notice that IPs of the client don't change.
-  -1st callback called on receiving an ADD_ADDR
-  -2nd callback called on receiving REM_ADDR
-  (TODO this class should automatically register)
-  **/
-  void SetNewAddrCallback(Callback<bool, Ptr<Socket>, Address, uint8_t> remoteAddAddrCb,
-                          Callback<void, uint8_t> remoteRemAddrCb);
-
-  /**
-   *
-   */
-  void GetAllAdvertisedDestinations(std::vector<InetSocketAddress>& );
-
-public: // public variables
-  typedef enum {
-    Established = 0, /* contains ESTABLISHED/CLOSE_WAIT */
-    // TODO rename to restart
-    Others = 1,     /**< Composed of SYN_RCVD, SYN_SENT*/
-    Closing,        /**< CLOSE_WAIT, FIN_WAIT */
-    Maximum         /**< keep it last, used to decalre array */
-  } mptcp_container_t;
-  // TODO move back to protected/private later on
-
-  /**
-   * Local token generated from this connection key
-   *
-   * \return
-   */
-//  virtual uint32_t GetToken() const;
-
-  MpTcpSocketBase& operator =(const TcpSocketBase& s);
-  
-  // TODO can be removed
-  virtual void
-  CompleteFork(Ptr<const Packet> p, const TcpHeader& h, const Address& fromAddress, const Address& toAddress);
-
-  /*
-   *
-   * \return addrId the assigned addrId
-   * \return bool
-   */
-  virtual bool
-  AddLocalId (uint8_t *addrId, const Address& address);
-
-  /*
-   *
-   */
-  virtual bool
-  AddRemoteId (uint8_t addrId, const Address& address);
-  
-  /**
-  \bug convert to uint64_t ?
-  \note Setting a remote key has the sideeffect of enabling MPTCP on the socket
-  */
-  void SetPeerKey (uint64_t );
-
-  /**
-    TODO should check the key is unique
-   */
-  void SetLocalKey (uint64_t localKey);  
-protected: // protected methods
-
-  friend class Tcp;
-  friend class MpTcpSubflow;
-
-
-
-
-
-  /**
-   * Expects InetXSocketAddress
-   * if no callback set then returns true
-   */
-  virtual bool NotifyJoinRequest (const Address &from, const Address & toAddress);
-
-  /**
-   * Expects Ipv4 (6 not supported yet)
-   */
-  bool OwnIP(const Address& address) const;
-  /**
-    * Should be called after having sent a dataFIN
-    * Should send a RST on all subflows in state Other
-    * and a FIN for Established subflows
-    */
-  virtual void CloseAllSubflows();
-
-  // MPTCP connection and subflow set up
-
-  virtual int SetupCallback(void);  // Setup SetRxCallback & SetRxCallback call back for a host
-  // Same as parent's
-//  virtual int  SetupEndpoint (void); // Configure local address for given remote address in a host - it query a routing protocol to find a source
-
-  /*
-  Remove subflow from containers
-  TODO should also erase its id from the path id manager
-  \sf
-  \param reset True if closing due to reset
-  */
-  void
-  OnSubflowClosed(Ptr<MpTcpSubflow> sf, bool reset);
-
-  void
-  OnSubflowDupAck(Ptr<MpTcpSubflow> sf);
-
-  /**
-  \param dataSeq Used to reconstruct the mapping
-  Currently used as callback for subflows
-  */
-  virtual void
-  OnSubflowRecv(
-                Ptr<MpTcpSubflow> sf
-//                SequenceNumber32 dataSeq, Ptr<Socket> sock
-                );
-
-
-
-  /* close all subflows
-  */
-  virtual void
-  TimeWait();
-
-  /**
-   * \brief Creates a DSS option if does not exist and configures it to have a dataack
-   * TODO what happens if existing datack already set ?
-   */
-//  virtual void
-//  AppendDataAck(TcpHeader& hdr) const;
-//  virtual void AppendDataFin(TcpHeader& header) const;
-
-  /**
-  Called when a subflow that initiated the connection
-  gets established
-
-  TODO rename into ConnectionSucceeded
-  Notify ?
-  **/
-  virtual void OnSubflowEstablishment(Ptr<MpTcpSubflow>);
-
-  /**
-  Called when a subflow that received a connection
-  request gets established
-
-  TODO I don't like the name,rename later
-  */
-  virtual void OnSubflowEstablished(Ptr<MpTcpSubflow> subflow);
-
-  /**
-  Should be called when subflows enters FIN_WAIT or LAST_ACK
-  */
-  virtual void OnSubflowClosing(Ptr<MpTcpSubflow>);
-
-
-  /**
-  Fails if
-  **/
-//  bool AddLocalAddress(uint8_t&, Port);
-// Should generate an Id
-
-//  void SetAddrEventCallback(Callback<bool, Ptr<Socket>, Address, uint8_t> remoteAddAddrCb,
-//                          Callback<void, uint8_t> remoteRemAddrCb);
-  //virtual RemoteAddAddr
-  void NotifyRemoteAddAddr(Address address);
-  void NotifyRemoteRemAddr(uint8_t addrId);
-
-
-
-  virtual void
-  ConnectionSucceeded (void); // Schedule-friendly wrapper for Socket::NotifyConnectionSucceeded()
-
-
-  //! disabled
-  virtual int DoConnect(void);
-
-  // Transfer operations
-//  void ForwardUp(Ptr<Packet> p, Ipv4Header header, uint16_t port, Ptr<Ipv4Interface> interface);
-
-  /** Inherit from Socket class: Return data to upper-layer application. Parameter flags
-   is not used. Data is returned as a packet of size no larger than maxSize */
-  virtual Ptr<Packet> Recv(uint32_t maxSize, uint32_t flags);
-  virtual int Send(Ptr<Packet> p, uint32_t flags);
-
-  /**
-   * Sending data via subflows with available window size. It sends data only to ESTABLISHED subflows.
-   * It sends data by calling SendDataPacket() function.
-   * This one is really different from parent class
-
-   *
-   * Called by functions: ReceveidAck, NewAck
-   * send as  much as possible
-   * \return true if it send mappings
-   */
-  virtual bool SendPendingData(bool withAck = false);
-
-
-  /** disabled
-  */
-  virtual uint32_t
-  SendDataPacket(SequenceNumber32 seq, uint32_t maxSize, bool withAck);
-
-  //! Disabled
-  virtual void ProcessListen  (Ptr<Packet>, const TcpHeader&, const Address&, const Address&);
-
-  // Manage data Tx/Rx
-//  virtual Ptr<TcpSocketBase> Fork(void);
-
-
-  virtual void ReTxTimeout();
-
-
-  virtual void Retransmit();
-  // TODO see if we can remove/override parents
-
-  //! Disabled
-  virtual void ReceivedAck ( Ptr<Packet>, const TcpHeader&); // Received an ACK packet
-
-  // MPTCP specfic version
-  virtual void ReceivedAck (
-    SequenceNumber32 dack
-  , Ptr<MpTcpSubflow> sf
-  , bool count_dupacks
-  );
-
-  //! Disabled
-  virtual void ReceivedData ( Ptr<Packet>, const TcpHeader&); // Recv of a data, put into buffer, call L7 to get it if necessary
-
-//  virtual void ProcessDSS( const TcpHeader& tcpHeader, Ptr<TcpOptionMpTcpDSS> dss, Ptr<MpTcpSubflow> sf);
-//  virtual void ProcessDSSClosing( Ptr<TcpOptionMpTcpDSS> dss, Ptr<MpTcpSubflow> sf);
-//  virtual void ProcessDSSWait( Ptr<TcpOptionMpTcpDSS> dss, Ptr<MpTcpSubflow> sf);
-//  virtual void ProcessDSSEstablished( const TcpHeader& tcpHeader, Ptr<TcpOptionMpTcpDSS> dss, Ptr<MpTcpSubflow> sf);
-
-
-  /** Does nothing */
-//  virtual void EstimateRtt (const TcpHeader&);
-
-
-//  Time ComputeReTxTimeoutForSubflow( Ptr<MpTcpSubflow> );
-
-  /**
-   * Part of the logic was implemented but this is non-working.
-   * \return Always false
-   */
-  virtual bool IsInfiniteMappingEnabled() const;
-  virtual bool DoChecksum() const;
-
-  //////////////////////////////////////////////////////////////////
-  ////  Here follows a list of MPTCP specific *callbacks* triggered by subflows
-  ////  on certain events
-
-  /**
-   * @param
-   * @param mapping
-   add count param ?
-  */
-  virtual void
-  OnSubflowDupack(Ptr<MpTcpSubflow> sf, MpTcpMapping mapping);
-
-  virtual void
-  OnSubflowRetransmit(Ptr<MpTcpSubflow> sf) ;
-
-//  void LastAckTimeout(uint8_t sFlowIdx);
-
-  virtual void
-  OnSubflowNewAck(
-//    SequenceNumber32 const& ack,
-      Ptr<MpTcpSubflow> sf);
-
-
-  /**
-   * Free space as much as possible
-   * Goes through all subflows
-   */
-  virtual void SyncTxBuffers();
-
-  /**
-   * Free space as much as possible
-   * TODO rename or move to MpTcpSubflow
-   */
-  virtual void SyncTxBuffers(Ptr<MpTcpSubflow> sf);
-
-  /**
-   *  inherited from parent: update buffers
-   * @brief Called from subflows when they receive DATA-ACK. For now calls parent fct
-   */
-  virtual void NewAck(SequenceNumber32 const& dataLevelSeq);
-
-  //! disabled
-  virtual void SendEmptyPacket(TcpHeader& header);
-
-  // Not implemented yet
-//  virtual void
-//  NewAck(SequenceNumber64 const& dataLevelSeq);
-
-
-  /**
-   *
-   */
-//  virtual void ProcessMpTcpOptions(TcpHeader h, Ptr<MpTcpSubflow> sf);
-
-
-  virtual void OnTimeWaitTimeOut();
-
-
-protected: // protected variables
-
-  virtual void UpdateTxBuffer();
-
-  friend class TcpL4Protocol;
-  // TODO make it so this is not necessary
-  // like putting m_nextTxSequence in MpTcpScheduler and make it friend ?
-  friend class MpTcpSchedulerRoundRobin;
-  friend class MpTcpSchedulerFastestRTT;
-  friend class MpTcpSchedulerOwd;
-
-
-  /**
-  called by TcpL4protocol when receiving an MP_JOIN taht does not fit
-  to any Ipv4endpoint. Thus twe create one.
-  **/
-  virtual Ipv4EndPoint*
-  NewSubflowRequest(
-    Ptr<const Packet> p,
-    const TcpHeader & header,
-    const Address & fromAddress,
-    const Address & toAddress,
-    Ptr<const TcpOptionMpTcpJoin> join
-  );
-
-  // ?
-//  int CloseSubflow(Ptr<MpTcpSubflow> sf);
-
-
-  /**
-   * TODO should accept a stream
-   * Dump
-   */
-  virtual void DumpSubflows (std::ostream &os) const;
-
-  /**
-   *
-   */
-  SubflowList m_subflows[Maximum];
-
-  Callback<bool, Ptr<Socket>, Address, uint8_t > m_onRemoteAddAddr;  //!< return true to create a subflow
-//  Callback<bool, Ptr<Socket>, Address, uint8_t > m_onNewLocalIp;  //!< return true to create a subflow
-  Callback<void, uint8_t > m_onAddrDeletion;    // return true to create a subflow
-
-//  Callback<void, const MpTcpAddressInfo& > m_onRemAddr;
-
-//  virtual void OnAddAddress(MpTcpAddressInfo);
-//  virtual void OnRemAddress();
-
-public:
-
-  /**
-  ONLY TEMPORARY
-  Used to export a whole range of statistics to csv files (filenames hardcoded).
-  This would likely need a rework before upstream, for instance to allow
-  enabling/disabling
-  **/
-//  virtual void
-//  SetupTracing(std::string prefix);
-  // Returns result based on m_tracePrefix
-  bool
-  IsTracingEnabled() const;
-//  virtual void
-//  SetupSubflowTracing(Ptr<MpTcpSubflow> sf);
-  std::string m_tracePrefix;      //!< help naming csv files, TODO should be removed
-//  int m_prefixCounter;      //!< TODO remove and put in a helper
- /****** END TRACING *****/
-  virtual void CreateScheduler (
-//  TypeId schedulerTypeId
-  );
-protected:
-
-
-  // TODO rename to peerIdManager ?
-  Ptr<MpTcpPathIdManager> m_remoteIdManager;  //!< Keep track of advertised ADDR id advertised by remote endhost
-  Ptr<MpTcpPathIdManager> m_localIdManager;  //!< Keep track of advertised ADDR id advertised by remote endhost
-
-
-  /***
-  TODO the scheduler is so closely
-  Woiuld be nice if could be changed online ?
-  ***/
-  Ptr<MpTcpScheduler> m_scheduler;  //!<
-
-  // TODO make private ? check what it does
-  // should be able to rmeove one
-  bool m_server;  //!< True if this socket is the result of a fork, ie it was originally LISTENing
-
-  /*******************************************/
-  /***   this part is not RFC compliant    ***/
-  /***   it's a custom toy implementation  ***/
-  /*******************************************/
-
-  /** for each key <localIdLow, localIdMax>, we maintain a SubflowPair that
-  * records characteristics to 2 subflows.
-  */
-//  std::map<std::pair<uint8_t, uint8_t>, Ptr<SubflowPair> > m_couplings;
-
-  void AddProbingRequest (uint8_t cookie, Ptr<MpTcpSubflow> sf);
-
-  /** **/
-  void AddCoupling (uint8_t localId0);
-//  void AddCoupling (uint8_t localId0, uint8_t localId1);
-
-  // remove couplings related to subflow with localID
-  void RemoveCoupling (uint8_t localID);
-
-  /*******************************************/
-  /******              END               *****/
-  /*******************************************/
-private:
-  // TODO rename into m_localKey  and move tokens into subflow (maybe not even needed)
-//  uint64_t m_localKey;    //!< Store local host token, generated during the 3-way handshake
-//  uint32_t m_localToken;  //!< Generated from key
-
-  uint64_t m_peerKey; //!< Store remote host token
-  uint32_t m_peerToken;
-
-  bool     m_doChecksum;  //!< Compute the checksum. Negociated during 3WHS. Unused
-
-  bool     m_receivedDSS;  //!< True if we received at least one DSS
-
-  bool     m_generatedIdsn; //!<
-
-
-private:
-
-
-  /* Utility function used when a subflow changes state
-   *  Research of the subflow is done
-   * \warn This function does not check if the destination container is
-   */
-  void MoveSubflow (Ptr<MpTcpSubflow> sf, mptcp_container_t to);
-
-  /**
-   * Asserts if from == to
-   */
-  void MoveSubflow (Ptr<MpTcpSubflow> sf, mptcp_container_t from, mptcp_container_t to);
-
-  Callback<void, Ptr<MpTcpSubflow> > m_subflowConnectionSucceeded;  //!< connection succeeded callback
-  Callback<void, Ptr<MpTcpSubflow> > m_subflowConnectionFailure;     //!< connection failed callback
-//  Callback<void, Ptr<Socket> >                   m_normalClose;          //!< connection closed callback
-//  Callback<void, Ptr<Socket> >                   m_errorClose;           //!< connection closed due to errors callback
-  Callback<bool, Ptr<MpTcpSocketBase>, const Address &, const Address & >       m_joinRequest;    //!< connection request callback
-  Callback<void, Ptr<MpTcpSubflow> >    m_subflowCreated; //!< connection created callback
-
-// , const Address &, bool master
-//  Callback<void, Ptr<MpTcpSubflow> >    m_subflowConnectionSucceeded; //!< connection created callback
-
-
-    //!
-    TypeId m_subflowTypeId;
-    TypeId m_schedulerTypeId;
-};
-
-}   //namespace ns3
-
-#endif /* MP_TCP_SOCKET_BASE_H */
diff --git a/src/internet/model/mptcp-socket.h b/src/internet/model/mptcp-socket.h
deleted file mode 100644
index 9b8fb9d..0000000
--- a/src/internet/model/mptcp-socket.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2006 Georgia Tech Research Corporation
- *               2007 INRIA
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Authors: Matthieu Coudron <matthieu.coudron@lip6.fr>
- *
- */
-
-#ifndef TCP_SOCKET_H
-#define TCP_SOCKET_H
-
-#include "ns3/socket.h"
-#include "ns3/traced-callback.h"
-#include "ns3/callback.h"
-#include "ns3/ptr.h"
-#include "ns3/object.h"
-#include "ns3/nstime.h"
-
-namespace ns3 {
-
-class Node;
-class Packet;
-
-/**
- * \brief Names of the  MPTCP states
- */
-typedef enum {
-  M_CLOSED,       // 0
-  M_LISTEN,       // 1
-  M_SYN_SENT,     // 2
-  M_SYN_RCVD,     // 3
-  M_ESTA_WAIT,  // 4
-  M_ESTA_SP,  // 4
-  M_ESTA_MP,
-  M_CLOSE_WAIT,   // 5
-  M_LAST_ACK,     // 6
-  M_FIN_WAIT_1,   // 7
-  M_FIN_WAIT_2,   // 8
-  M_CLOSING,      // 9
-  TIME_WAIT,   // 10
-  LAST_STATE
-} MpTcpStates_t;
-
-
-} // end of namespace
diff --git a/src/internet/model/mptcp-subflow-owd.cc b/src/internet/model/mptcp-subflow-owd.cc
deleted file mode 100644
index 196bd97..0000000
--- a/src/internet/model/mptcp-subflow-owd.cc
+++ /dev/null
@@ -1,109 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-
-
-#include <iostream>
-#include <cmath>
-#include "ns3/mptcp-mapping.h"
-#include "ns3/simulator.h"
-#include "ns3/log.h"
-#include "ns3/abort.h"
-#include "ns3/mptcp-subflow-owd.h"
-#include "ns3/mptcp-socket-base.h"
-#include "ns3/tcp-l4-protocol.h"
-#include "ns3/ipv4-address.h"
-#include "ns3/ipv4-end-point.h"
-#include "ipv6-end-point.h" // it is not exported in ns3.19
-#include "ns3/node.h"
-#include "ns3/ptr.h"
-#include "ns3/tcp-option-mptcp.h"
-#include "ns3/mptcp-id-manager.h"
-//#include "ns3/ipv4-address.h"
-#include "ns3/trace-helper.h"
-#include <algorithm>
-#include <openssl/sha.h>
-
-
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE("MpTcpSubflowOwd");
-
-NS_OBJECT_ENSURE_REGISTERED(MpTcpSubflowOwd);
-
-
-
-TypeId
-MpTcpSubflowOwd::GetTypeId(void)
-{
-  static TypeId tid = TypeId("ns3::MpTcpSubflowOwd")
-      .SetParent<MpTcpSubflow>()
-      .SetGroupName ("Internet")
-      .AddConstructor<MpTcpSubflowOwd>()
-    ;
-  return tid;
-}
-
-
-
-TypeId
-MpTcpSubflowOwd::GetInstanceTypeId (void) const
-{
-  return MpTcpSubflowOwd::GetTypeId();
-}
-
-MpTcpSubflowOwd::MpTcpSubflowOwd () :
-    MpTcpSubflow ()
-{
-    NS_LOG_FUNCTION_NOARGS();
-}
-
-MpTcpSubflowOwd::~MpTcpSubflowOwd ()
-{
-    NS_LOG_FUNCTION_NOARGS();
-}
-
-int
-MpTcpSubflowOwd::ProcessOptionMpTcp (const Ptr<const TcpOption> option)
-{
-
-  return MpTcpSubflow::ProcessOptionMpTcp (option);
-}
-
-//
-//
-//
-//void
-//MpTcpSubflowOwd::DumpInfo () const
-//{
-//      NS_LOG_LOGIC ("MpTcpSubflow " << this << " SendPendingData" <<
-////          " w " << w <<
-//          " rxwin " << m_rWnd <<
-////          " segsize " << GetSegSize() <<
-//          " nextTxSeq " << m_nextTxSequence <<
-//          " highestRxAck " << FirstUnackedSeq() <<
-////          " pd->Size " << m_txBuffer->Size () <<
-//          " pd->SFS " << m_txBuffer->SizeFromSequence (m_nextTxSequence)
-//          );
-//}
-
-
-} // end of ns3
diff --git a/src/internet/model/mptcp-subflow-owd.h b/src/internet/model/mptcp-subflow-owd.h
deleted file mode 100644
index 8d6df4e..0000000
--- a/src/internet/model/mptcp-subflow-owd.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-#ifndef MPTCP_SUBFLOW_OWD_H
-#define MPTCP_SUBFLOW_OWD_H
-
-#include <stdint.h>
-#include <vector>
-#include <queue>
-#include <list>
-#include <set>
-#include <map>
-#include "ns3/mptcp-subflow.h"
-//#include "ns3/tcp-option-mptcp.h"
-
-using namespace std;
-
-namespace ns3
-{
-
-class MpTcpSocketBase;
-class MpTcpPathIdManager;
-class TcpOptionMpTcpDSS;
-class TcpOptionMpTcp;
-
-/**
- * \class MpTcpSubflow
-*/
-class MpTcpSubflowOwd : public MpTcpSubflow
-{
-public:
-
-  static TypeId
-  GetTypeId(void);
-
-  virtual TypeId GetInstanceTypeId(void) const;
-
-
-  /**
-  the metasocket is the socket the application is talking to.
-  Every subflow is linked to that socket.
-  \param The metasocket it is linked to
-  **/
-  MpTcpSubflowOwd ();
-
-  virtual ~MpTcpSubflowOwd ();
-
-
-
-  virtual int ProcessOptionMpTcp (const Ptr<const TcpOption> option);
-
-};
-
-}
-#endif /* MP_TCP_SUBFLOW */
diff --git a/src/internet/model/mptcp-subflow.cc b/src/internet/model/mptcp-subflow.cc
deleted file mode 100644
index 6e9016b..0000000
--- a/src/internet/model/mptcp-subflow.cc
+++ /dev/null
@@ -1,2391 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-//#undef NS_LOG_APPEND_CONTEXT
-//#define NS_LOG_APPEND_CONTEXT \
-//  if (m_node) { std::clog << Simulator::Now ().GetSeconds () << " [node " << m_node->GetId () << ": sf " << "] "; }
-//<< TcpStateName[m_node->GetTcp()->GetState()] <<
-
-#include <iostream>
-#include <cmath>
-#include "ns3/mptcp-mapping.h"
-#include "ns3/simulator.h"
-#include "ns3/log.h"
-#include "ns3/abort.h"
-#include "ns3/mptcp-subflow.h"
-#include "ns3/mptcp-socket-base.h"
-#include "ns3/tcp-l4-protocol.h"
-#include "ns3/ipv4-address.h"
-#include "ns3/ipv4-end-point.h"
-#include "ipv6-end-point.h" // it is not exported in ns3.19
-#include "ns3/node.h"
-#include "ns3/ptr.h"
-#include "ns3/tcp-option-mptcp.h"
-#include "ns3/mptcp-id-manager.h"
-#include "ns3/mptcp-scheduler-owd.h"    // for subflowpair
-//#include "ns3/ipv4-address.h"
-#include "ns3/trace-helper.h"
-#include <algorithm>
-#include <openssl/sha.h>
-
-
-
-/*
-#define DISABLE_MEMBER(retType,member) retType \
-                                        MpTcpSubflow::member(void) {\
-                                            NS_FATAL_ERROR("This should never be called. The meta will make the subflow pass from LISTEN to ESTABLISHED."); \
-                                        }
-*/
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE("MpTcpSubflow");
-
-NS_OBJECT_ENSURE_REGISTERED(MpTcpSubflow);
-
-
-
-
-static inline
-SequenceNumber32 SEQ64TO32(SequenceNumber64 seq)
-{
-    //!
-    return SequenceNumber32( seq.GetValue());
-}
-
-static inline
-SequenceNumber64 SEQ32TO64(SequenceNumber32 seq)
-{
-    //!
-    return SequenceNumber64( seq.GetValue());
-}
-
-
-
-TypeId
-MpTcpSubflow::GetTypeId(void)
-{
-  static TypeId tid = TypeId("ns3::MpTcpSubflow")
-      .SetParent<TcpSocketBase>()
-      .SetGroupName ("Internet")
-      .AddConstructor<MpTcpSubflow>()
-    ;
-  return tid;
-}
-
-
-
-//! wrapper function
-static inline
-MpTcpMapping
-GetMapping (const Ptr<const TcpOptionMpTcpDSS> dss)
-{
-    MpTcpMapping mapping;
-    uint64_t dsn;
-    uint32_t ssn;
-    uint16_t length;
-
-    dss->GetMapping (dsn, ssn, length);
-    mapping.SetHeadDSN( SequenceNumber64(dsn));
-    mapping.SetMappingSize (length);
-    // TODO convert to
-    mapping.MapToSSN( SequenceNumber32(ssn));
-    return mapping;
-}
-
-
-TypeId
-MpTcpSubflow::GetInstanceTypeId (void) const
-{
-  return MpTcpSubflow::GetTypeId();
-}
-
-
-void
-MpTcpSubflow::SetMeta (Ptr<MpTcpSocketBase> metaSocket)
-{
-  NS_ASSERT(metaSocket);
-  NS_LOG_FUNCTION(this);
-  m_metaSocket = metaSocket;
-}
-
-void
-MpTcpSubflow::DumpInfo () const
-{
-      NS_LOG_LOGIC ("MpTcpSubflow " << this << " SendPendingData" <<
-//          " w " << w <<
-          " rxwin " << GetRwnd() <<
-//          " segsize " << GetSegSize() <<
-          " nextTxSeq " << m_nextTxSequence <<
-          " highestRxAck " << FirstUnackedSeq() <<
-//          " pd->Size " << m_txBuffer->Size () <<
-          " pd->SFS " << m_txBuffer->SizeFromSequence (m_nextTxSequence)
-          );
-}
-
-//Ptr<TcpSocketBase>
-//MpTcpSubflow::Fork(void)
-//{
-//  // Call CopyObject<> to clone me
-////  NS_LOG_ERROR("Not implemented");
-//
-//
-//  return ForkAsSubflow();
-//}
-
-//Ptr<MpTcpSubflow>
-//MpTcpSubflow::ForkAsSubflow(void)
-//{
-//  return CopyObject<MpTcpSubflow> (this);
-//}
-
-/*
-DupAck
-RFC 6824
-"As discussed earlier, however, an MPTCP
-   implementation MUST NOT treat duplicate ACKs with any MPTCP option,
-   with the exception of the DSS option, as indications of congestion
-   [12], and an MPTCP implementation SHOULD NOT send more than two
-   duplicate ACKs in a row for signaling purposes."
-*/
-//void
-//MpTcpSubflow::DupAck(const TcpHeader& t, uint32_t count)
-
-
-// TODO check with parent's
-void
-MpTcpSubflow::CancelAllTimers()
-{
-  NS_LOG_FUNCTION(this);
-  //(int) sFlowIdx
-//  m_retxEvent.Cancel();
-//  m_lastAckEvent.Cancel();
-//  m_timewaitEvent.Cancel();
-  TcpSocketBase::CancelAllTimers ();
-  NS_LOG_LOGIC( "CancelAllTimers");
-}
-
-// TODO remove in favor
-int
-MpTcpSubflow::DoConnect()
-{
-  NS_LOG_FUNCTION (this);
-  return TcpSocketBase::DoConnect();
-
-//  InitializeCwnd ();
-//
-//  // A new connection is allowed only if this socket does not have a connection
-//  if (m_state == CLOSED || m_state == LISTEN || m_state == SYN_SENT || m_state == LAST_ACK || m_state == CLOSE_WAIT)
-//    { // send a SYN packet and change state into SYN_SENT
-//      TcpHeader header;
-//      GenerateEmptyPacketHeader(header,TcpHeader::SYN);
-//
-//      // code moved inside SendEmptyPacket
-//
-//      AddOptionMpTcp3WHS(header);
-//
-//      TcpSocketBase::SendEmptyPacket(header);
-////      NS_ASSERT( header.)
-//      NS_LOG_INFO (TcpStateName[m_state] << " -> SYN_SENT");
-//      m_state = SYN_SENT;
-//    }
-//  else if (m_state != TIME_WAIT)
-//  { // In states SYN_RCVD, ESTABLISHED, FIN_WAIT_1, FIN_WAIT_2, and CLOSING, an connection
-//    // exists. We send RST, tear down everything, and close this socket.
-//    SendRST();
-//    CloseAndNotify();
-//  }
-//  return 0;
-}
-
-
-/** Inherit from Socket class: Kill this socket and signal the peer (if any) */
-int
-MpTcpSubflow::Close(void)
-{
-  NS_LOG_FUNCTION (this);
-  // First we check to see if there is any unread rx data
-  // Bug number 426 claims we should send reset in this case.
-
-//  if (m_rxBuffer->Size() != 0)
-//    {
-//      SendRST();
-//      return 0;
-//    }
-//
-//  //
-////  if( GetMeta()->GetNClosingSubflows() )
-////  {
-////
-////  }
-//
-//
-//  if (m_txBuffer->SizeFromSequence(m_nextTxSequence) > 0)
-//    { // App close with pending data must wait until all data transmitted
-//      if (m_closeOnEmpty == false)
-//        {
-//          m_closeOnEmpty = true;
-//          NS_LOG_INFO ("Socket " << this << " deferring close, state " << TcpStateName[m_state]);
-//        }
-//      return 0;
-//    }
-//  return DoClose();
-
-    return TcpSocketBase::Close();
-}
-
-
-
-/**
- * If copied from a legacy socket, then it's a master socket
- * We assign by default a bad subflowId to make sure it is updated somewhere in the
- * code.
- */
-//MpTcpSubflow::MpTcpSubflow (const TcpSocketBase& sock)
-//    : TcpSocketBase(sock),
-//    m_probeState (TcpOptionMpTcpOwdTimeStamp::PendingSend),
-//    m_subflowId (TcpOptionMpTcpChangePriority::BAD_ADDRID),
-//    m_dssFlags (0),
-//    m_masterSocket(true),
-//    m_localNonce(0)
-//{
-//    NS_LOG_FUNCTION (this << &sock);
-//      NS_LOG_LOGIC ("Copying from TcpSocketBase. endPoint=" << sock.m_endPoint);
-//    // We need to update the endpoint callbnacks so that packets come to this socket
-//    // instead of the abstract meta
-//    // this is necessary for the client socket
-//    NS_LOG_UNCOND("Cb=" << m_sendCb.IsNull () << " endPoint=" << m_endPoint);
-//
-//    m_owd[0] = CreateObject<RttMeanDeviation> ();
-//    m_owd[1] = CreateObject<RttMeanDeviation> ();
-//
-//    m_endPoint = (sock.m_endPoint);
-//    m_endPoint6 = (sock.m_endPoint6);
-//    SetupCallback();
-//}
-
-
-// Does this constructor even make sense ? no ? to remove ?
-MpTcpSubflow::MpTcpSubflow (const MpTcpSubflow& sock)
-  : TcpSocketBase(sock),
-  m_probeState (TcpOptionMpTcpOwdTimeStamp::PendingSend),
-  m_subflowId (TcpOptionMpTcpChangePriority::BAD_ADDRID),
-  m_dssFlags(0),
-  m_masterSocket(false),  //!false
-  m_backupSubflow(sock.m_backupSubflow),
-  m_localNonce(sock.m_localNonce),
-  m_prefixCounter(0)
-{
-  NS_LOG_FUNCTION (this << &sock);
-  NS_LOG_LOGIC ("Invoked the copy constructor");
-  
-  // TODO should never be called, put it protected ?
-//  if (sock.m_owd) {
-//    m_owd = sock.m_owd->Copy ();
-//  }
-}
-
-MpTcpSubflow::MpTcpSubflow(
-//Ptr<MpTcpSocketBase> metaSocket
-) :
-    TcpSocketBase(),
-    m_probeState (TcpOptionMpTcpOwdTimeStamp::PendingSend),
-    m_subflowId (TcpOptionMpTcpChangePriority::BAD_ADDRID),
-    m_metaSocket (0),
-    m_dssFlags (0),
-    m_backupSubflow(false),
-    m_masterSocket(false),
-    m_localNonce(0),
-    m_prefixCounter(0)
-
-{
-  NS_LOG_FUNCTION(this);
-  // m_rtt is created through a factory in TcpL4Protocol::CreateSocket
-    m_owd[0] = CreateObject<RttMeanDeviation> ();
-    m_owd[1] = CreateObject<RttMeanDeviation> ();
-}
-
-MpTcpSubflow::~MpTcpSubflow()
-{
-  NS_LOG_FUNCTION(this);
-}
-
-
-MpTcpSubflow& 
-MpTcpSubflow::operator =(const TcpSocketBase& s)
-{
-  TcpSocketBase::operator=(s);
-  m_masterSocket = true;
-  ResetUserCallbacks();
-  return *this;
-}
-
-/**
-TODO maybe override that not to have the callbacks
-**/
-void
-MpTcpSubflow::CloseAndNotify(void)
-{
-  //TODO
-  NS_LOG_FUNCTION_NOARGS ();
-  TcpSocketBase::CloseAndNotify ();
-  GetMeta()->OnSubflowClosed (this, false);
-}
-
-
-/**
-Mapping should already exist when sending the packet
-**/
-int
-MpTcpSubflow::Send (Ptr<Packet> p, uint32_t flags)
-{
-  // TODO use TcpSocketBase
-//  NS_FATAL_ERROR("Use SendMapping instead");
-  NS_LOG_FUNCTION (this);
-
-  // TO
-  int ret = TcpSocketBase::Send (p, flags);
-
-
-  if(ret > 0)
-  {
-//      // Check that the packet is covered by mapping
-//      // compute ssnHead and tail
-//      SequenceNumber32 ssnTail = m_txBuffer->TailSequence();
-      MpTcpMapping temp;
-      SequenceNumber32 ssnHead = m_txBuffer->TailSequence() - p->GetSize();
-      bool ok = m_TxMappings.GetMappingForSSN(ssnHead, temp);
-      NS_ASSERT(ok);
-//      return ret;
-  }
-
-  return ret;
-}
-
-//, uint32_t maxSize
-// rename globalSeqNb ?
-
-void
-MpTcpSubflow::SendEmptyPacket (uint8_t flags)
-{
-  NS_LOG_FUNCTION_NOARGS();
-  TcpSocketBase::SendEmptyPacket (flags);
-}
-
-
-void
-MpTcpSubflow::SendEmptyPacket(TcpHeader& header)
-{
-  NS_LOG_FUNCTION(this << header);
-
-
-  TcpSocketBase::SendEmptyPacket(header);
-}
-
-//bool
-//MpTcpSubflow::HasMappingForDSNRange(SequenceNumber64 dsn, uint16_t len)
-//{
-//    NS_LOG_FUNCTION(dsn << len);
-//
-//}
-//
-
-// Return the dsn range
-//uint32_t
-//MpTcpSubflow::AddMapping(SequenceNumber32 dsn, uint16_t len)
-//{
-//    NS_LOG_LOGIC("Register mapping");
-//    MpTcpMapping mapping;
-//    mapping.SetHeadDSN();
-//    mapping.SetMappingSize();
-//    mapping.MapToSSN( m_txBuffer->TailSequence() );
-//    NS_LOG_DEBUG("Generated mapping=" << mapping );
-//
-//    bool ok = m_TxMappings.AddMapping( mapping  );
-//    NS_ASSERT_MSG( ok, "Can't add mapping: 2 mappings overlap");
-//}
-
-/**
-//! GetLength()
-this fct asserts when the mapping length is 0 but in fact it can be possible
-when there is an infinite mapping
-
-Probleme ici c si j'essaye
-**/
-#if 0
-int
-MpTcpSubflow::SendMapping(Ptr<Packet> p, MpTcpMapping& mapping)
-{
-  NS_LOG_FUNCTION (this << p << mapping);
-  NS_ASSERT(p);
-
-  NS_ASSERT_MSG(mapping.GetLength() != 0,"Mapping should not be empty" );
-  NS_ASSERT_MSG(mapping.GetLength() == p->GetSize(), "You should fill the mapping" );
-  // backup its value because send will change it
-  //SequenceNumber32 nextTxSeq = m_nextTxSequence;
-
-  // Check m_txBuffer can handle it otherwise it will get refused
-
-    // Everything went fine
-  //if(res >= 0)
-  //{*
-  // TODO in fact there could be an overlap between recorded mappings and the current one
-  // so the following check is not enough. To change later
-
-//  if(m_txBuffer->Available() < mapping.GetLength())
-//  {
-//    NS_LOG_ERROR("Too much data to send");
-//    return -ERROR_MSGSIZE;
-//  }
-//  NS_LOG_FUNCTION (this << p);
-//  NS_ABORT_MSG_IF(flags, "use of flags is not supported in TcpSocketBase::Send()");
-  //! & !m_closeOnEmpty
-  if (m_state == ESTABLISHED || m_state == SYN_SENT || m_state == CLOSE_WAIT)
-    {
-
-      SequenceNumber32 savedTail = m_txBuffer->TailSequence();
-      // Store the packet into Tx buffer
-      if (!m_txBuffer->Add(p))
-        { // TxBuffer overflow, send failed
-          NS_LOG_WARN("TX buffer overflow");
-
-          m_errno = ERROR_MSGSIZE;
-          return -1;
-        }
-
-      //! add succeeded
-      NS_LOG_DEBUG(mapping << "Mapped to SSN=" << savedTail);
-      mapping.MapToSSN( savedTail );
-      NS_ASSERT_MSG(m_TxMappings.AddMapping( mapping  ) == true, "2 mappings overlap");
-
-      // Submit the data to lower layers
-      NS_LOG_LOGIC ("txBufSize=" << m_txBuffer->Size () << " state " << TcpStateName[m_state]);
-      if (m_state == ESTABLISHED || m_state == CLOSE_WAIT)
-        {
-          NS_LOG_DEBUG("m_nextTxSequence [" << m_nextTxSequence << "]");
-          // Try to send the data out
-          SendPendingData(m_connected);
-        }
-      return p->GetSize();
-    }
-  else
-    { // Connection not established yet
-      m_errno = ERROR_NOTCONN;
-      return -1; // Send failure
-    }
-
-    return 0;
-}
-#endif
-
-//uint32_t
-//MpTcpSubflow::SendDataPacket(TcpHeader& header, const SequenceNumber32& ssn, uint32_t maxSize)
-//{
-//
-//}
-
-/* used by Meta socket */
-bool
-MpTcpSubflow::AddLooseMapping (SequenceNumber64 dsnHead, uint16_t length)
-{
-    NS_LOG_LOGIC("Adding mapping with dsn=" << dsnHead << " len=" << length);
-    MpTcpMapping mapping;
-
-    mapping.MapToSSN(FirstUnmappedSSN());
-    mapping.SetMappingSize (length);
-    mapping.SetHeadDSN (dsnHead);
-
-    bool ok = m_TxMappings.AddMapping( mapping  );
-    NS_ASSERT_MSG( ok, "Can't add mapping: 2 mappings overlap");
-    return ok;
-}
-
-SequenceNumber32
-MpTcpSubflow::FirstUnmappedSSN()
-{
-    NS_LOG_FUNCTION(this);
-    SequenceNumber32 ssn;
-    if(!m_TxMappings.FirstUnmappedSSN(ssn))
-    {
-        ssn = m_txBuffer->TailSequence();
-    }
-    return ssn;
-}
-
-// Fills the vector with all the pieces of data it can accept
-// but not in TxBuffer
-//                SequenceNumber64 headDsn,
-//                std::vector< std::pair<SequenceNumber64, uint16_t> >& missing
-void
-MpTcpSubflow::GetMappedButMissingData(
-                std::set< MpTcpMapping >& missing
-                )
-{
-    //!
-    NS_LOG_FUNCTION(this);
-//    missing.clear();
-
-    SequenceNumber32 startingSsn = m_txBuffer->TailSequence();
-
-    m_TxMappings.GetMappingsStartingFromSSN(startingSsn, missing);
-}
-
-#if 0
-bool
-MpTcpSubflow::CheckRangeIsCoveredByMapping(SequenceNumber32 ssnHead, SequenceNumber32 ssnTail)
-{
-  NS_LOG_FUNCTION(this << ssnHead << ssnTail);
-  if(IsInfiniteMappingEnabled())
-    {
-        NS_LOG_DEBUG("Infinite mapping");
-        return true;
-    }
-
-  /**
-  In this loop, we make sure we don't send data for which there is no
-  Tx mapping. A packet may be spanned over
-   Packets may contain data described by several mappings
-  */
-  while(ssnHead < ssnTail)
-  {
-    NS_LOG_DEBUG("Looking for mapping that overlaps with ssn " << ssnHead);
-
-    // TODO je viens de le changer
-//    NS_ASSERT_MSG(m_TxMappings.FindOverlappingMapping(ssnHead, ssnTail - ssnHead, mapping), "Sent data not covered by mappings");
-    NS_ASSERT_MSG( m_TxMappings.GetMappingForSSN(ssnHead, mapping), "Sent data not covered by mappings");
-//    ssnTail =
-//    NS_ASSERT_MSG(mapping.HeadSSN() <= ssnHead, "Mapping can only start");
-
-    ssnHead = mapping.TailSSN() + SequenceNumber32(1);
-    NS_LOG_DEBUG("mapping " << mapping << " covers it");
-
-  }
-}
-#endif
-
-  /* We don't automatically embed mappings since we want the possibility to create mapping spanning over several segments
-//   here, it should already have been put in the packet, we just check
-//  that the
-
-*/
-
-// pass as const ref
-void
-MpTcpSubflow::SendPacket (TcpHeader header, Ptr<Packet> p)
-{
-  NS_LOG_FUNCTION (this << header <<  p);
-  // TODO here we should decide if we call AppendMapping or not and with which value
-
-
-  //! if we send data...
-  if (p->GetSize () && !IsInfiniteMappingEnabled())
-  {
-    //... we must decide to send a mapping or not
-    // For now we always append the mapping but we could have mappings spanning over several packets.
-    // and thus not add the mapping for several packets
-    /// TODO : just moved from SendDataPacket.
-    ///============================
-      SequenceNumber32 ssnHead = header.GetSequenceNumber();
-//      SequenceNumber32 ssnTail = ssnHead + SequenceNumber32(p->GetSize())-1;
-
-      MpTcpMapping mapping;
-      // TODO
-      bool result = m_TxMappings.GetMappingForSSN(ssnHead, mapping);
-      if(!result)
-      {
-        m_TxMappings.Dump();
-        NS_FATAL_ERROR ("Could not find mapping associated to ssn" << ssnHead);
-      }
-      NS_ASSERT_MSG (mapping.TailSSN() >= ssnHead +p->GetSize() -1, "mapping should cover the whole packet" );
-
-      // otherwise sometimes we were sending too  long mappings and the datafin number was way off
-//      mapping.SetMappingSize( std::min( p->GetSize(), (uint32_t)mapping.GetLength()));
-      AppendDSSMapping (mapping);
-    ///============================
-
-  }
-
-
-
-  // we append hte ack everytime
-//  AppendDSSAck();
-  TcpSocketBase::SendPacket(header, p);
-
-  m_dssFlags = 0; // reset for next packet
-}
-
-/**
- *
- */
-uint32_t
-MpTcpSubflow::SendDataPacket(TcpHeader& header, SequenceNumber32 ssnHead, uint32_t maxSize)
-{
-  NS_LOG_FUNCTION(this << "Sending packet starting at SSN [" << ssnHead.GetValue() << "] with maxSize=" << maxSize);
-  //! if we send data...
-      MpTcpMapping mapping;
-      // TODO
-      bool result = m_TxMappings.GetMappingForSSN(ssnHead, mapping);
-      if(!result)
-      {
-        m_TxMappings.Dump();
-        NS_FATAL_ERROR("Could not find mapping associated to ssn");
-      }
-//      NS_ASSERT_MSG(mapping.TailSSN() >= ssnHead +p->GetSize() -1, "mapping should cover the whole packet" );
-
-      AppendDSSMapping(mapping);
-    ///============================
-
-  // Here we set the maxsize to the size of the mapping
-  return TcpSocketBase::SendDataPacket(header, ssnHead, std::min( (int)maxSize,mapping.TailSSN()-ssnHead+1));
-}
-
-
-bool
-MpTcpSubflow::IsInfiniteMappingEnabled() const
-{
-    return GetMeta()->IsInfiniteMappingEnabled();
-}
-
-/*
-behavior should be the same as in TcpSocketBase
-TODO check if m_cWnd is
-
-*/
-void
-MpTcpSubflow::Retransmit(void)
-{
-  NS_LOG_FUNCTION (this);
-  std::ostringstream oss;
-  Dump (oss);
-  NS_LOG_DEBUG ( oss.str() );
-  TcpSocketBase::Retransmit();
-#if 0
-  NS_LOG_LOGIC (this << " ReTxTimeout Expired at time " << Simulator::Now ().GetSeconds ()
-  << "Exiting Fast recovery  (previously set to " << m_inFastRec << ")");
-  m_inFastRec = false;
-
-  // If erroneous timeout in closed/timed-wait state, just return
-  if (m_state == CLOSED || m_state == TIME_WAIT) {
-    NS_LOG_WARN("erroneous timeout");
-    return;
-  }
-  // If all data are received (non-closing socket and nothing to send), just return
-  if (m_state <= ESTABLISHED && m_txBuffer->HeadSequence () >= m_highTxMark) {
-    NS_FATAL_ERROR("May be removed");
-    return;
-  }
-
-  // According to RFC2581 sec.3.1, upon RTO, ssthresh is set to half of flight
-  // size and cwnd is set to 1*MSS, then the lost packet is retransmitted and
-  // TCP back to slow start
-  m_ssThresh = std::max (2 * GetSegSize(), BytesInFlight () / 2);
-  m_cWnd = GetSegSize();
-  m_nextTxSequence = m_txBuffer->HeadSequence (); // Restart from highest Ack
-  NS_LOG_INFO ("RTO. "
-//               << m_rtt->RetransmitTimeout()
-               << " Reset cwnd to " << m_cWnd
-//               ", ssthresh to " << GetSSThresh()
-               << ", restart from seqnum " << m_nextTxSequence
-               );
-
-
-
-// Care
-//  m_rtt->IncreaseMultiplier ();             // Double the next RTO
-  DoRetransmit ();                          // Retransmit the packet
-
-//  TcpSocketBase::Retransmit();
-
-//  NS_FATAL_ERROR("TODO retransmit");
-  // pass on mapping
-#endif
-
-}
-
-
-// TODO this could be replaced
-void
-MpTcpSubflow::DoRetransmit()
-{
-  NS_LOG_FUNCTION(this);
-
-  GetMeta()->OnSubflowRetransmit(this);
-
-  TcpSocketBase::DoRetransmit();
-  #if 0
-//  NS_LOG_FUNCTION (this);
-  // Retransmit SYN packet
-  if (m_state == SYN_SENT)
-    {
-      if (m_cnCount > 0)
-        {
-          NS_FATAL_ERROR("Not implemented yet");
-          SendEmptyPacket(TcpHeader::SYN);
-        }
-      else
-        {
-          NotifyConnectionFailed();
-        }
-      return;
-    }
-  // Retransmit non-data packet: Only if in FIN_WAIT_1 or CLOSING state
-  if (m_txBuffer->Size() == 0)
-    {
-      if (m_state == FIN_WAIT_1 || m_state == CLOSING)
-        {
-          NS_FATAL_ERROR("Not implemented yet");
-          // Must have lost FIN, re-send
-          SendEmptyPacket(TcpHeader::FIN);
-        }
-      return;
-    }
-  // Retransmit a data packet: Call SendDataPacket
-  NS_LOG_LOGIC ("TcpSocketBase " << this << " retxing seq " << FirstUnackedSeq());
-
-
-  /**
-  We want to send mappings only
-  **/
-  MpTcpMapping mapping;
-  if(!m_TxMappings.GetMappingForSSN(FirstUnackedSeq(), mapping))
-//  if(!m_RxMappings.TranslateSSNtoDSN(headSSN, dsn))
-  {
-    NS_LOG_UNCOND("Rx mappings");
-    m_TxMappings.Dump();
-    NS_FATAL_ERROR("Could not associate a mapping to ssn [" << FirstUnackedSeq() << "]. Should be impossible");
-  }
-
-  // TODO maybe we could set an option to tell SendDataPacket to trim the packet
-  // normally here m_nextTxSequence has been set to firstUna
-  uint32_t sz = SendDataPacket(FirstUnackedSeq(), mapping.GetLength(), true);
-  // In case of RTO, advance m_nextTxSequence
-  m_nextTxSequence = std::max(m_nextTxSequence.Get(), FirstUnackedSeq() + sz);
-  //reTxTrack.push_back(std::make_pair(Simulator::Now().GetSeconds(), ns3::TcpNewReno::cWnd));
-  #endif
-}
-
-/**
-Received a packet upon LISTEN state.
-En fait il n'y a pas vraiment de ProcessListen :s si ?
-TODO remove that one, it should never be called ?
-*/
-void
-MpTcpSubflow::ProcessListen(Ptr<Packet> packet, const TcpHeader& tcpHeader, const Address& fromAddress, const Address& toAddress)
-{
-  NS_LOG_FUNCTION (this << tcpHeader);
-
-  NS_FATAL_ERROR("This function should never be called, shoud it ?!");
-
-  // Extract the flags. PSH and URG are not honoured.
-  uint8_t tcpflags = tcpHeader.GetFlags() & ~(TcpHeader::PSH | TcpHeader::URG);
-
-  // Fork a socket if received a SYN. Do nothing otherwise.
-  // C.f.: the LISTEN part in tcp_v4_do_rcv() in tcp_ipv4.c in Linux kernel
-  if (tcpflags != TcpHeader::SYN)
-    {
-      return;
-    }
-
-  // Call socket's notify function to let the server app know we got a SYN
-  // If the server app refuses the connection, do nothing
-  // TODO should be moved to
-  if (!NotifyConnectionRequest(fromAddress))
-    {
-      return;
-    }
-
-  NS_LOG_LOGIC("Updating receive window" << tcpHeader.GetWindowSize());
-//  GetMeta()->SetRemoteWindow(tcpHeader.GetWindowSize());
-
-  // Clone the socket, simulate fork
-//  Ptr<MpTcpSubflow> newSock = Fork();
-  Ptr<MpTcpSubflow> newSock = DynamicCast<MpTcpSubflow>(Fork());
-  NS_LOG_LOGIC ("Cloned a TcpSocketBase " << newSock);
-  // TODO TcpSocketBase::
-  Simulator::ScheduleNow(
-      &MpTcpSubflow::CompleteFork,
-      newSock,
-      packet,
-      tcpHeader,
-      fromAddress,
-      toAddress
-      );
-}
-
-Ptr<MpTcpSocketBase>
-MpTcpSubflow::GetMeta () const
-{
-  NS_ASSERT (m_metaSocket);
-  return m_metaSocket;
-}
-
-/*
-It is also encouraged to
-   reduce the timeouts (Maximum Segment Life) on subflows at end hosts.
-Move TCP to Time_Wait state and schedule a transition to Closed state
-*/
-void
-MpTcpSubflow::TimeWait ()
-{
-  NS_LOG_INFO (TcpStateName[m_state] << " -> TIME_WAIT");
-  m_state = TIME_WAIT;
-  CancelAllTimers();
-  // Move from TIME_WAIT to CLOSED after 2*MSL. Max segment lifetime is 2 min
-  // according to RFC793, p.28
-  m_timewaitEvent = Simulator::Schedule(Seconds( m_msl), &MpTcpSubflow::CloseAndNotify, this);
-}
-
-
-void
-MpTcpSubflow::AddMpTcpOptionDSS (TcpHeader& header)
-{
-  NS_LOG_FUNCTION(this);
-  Ptr<TcpOptionMpTcpDSS> dss = Create<TcpOptionMpTcpDSS>();
-  const bool sendDataFin = m_dssFlags & TcpOptionMpTcpDSS::DataFin;
-  const bool sendDataAck = m_dssFlags & TcpOptionMpTcpDSS::DataAckPresent;
-
-  if (sendDataAck)
-  {
-      // TODO replace with member function to keep isolation
-      uint32_t dack = GetMeta()->GetRxBuffer()->NextRxSequence().GetValue();
-      dss->SetDataAck( dack );
-  }
-
-  // If no mapping set but datafin set , we have to create the mapping from scratch
-  if( sendDataFin && !(m_dssFlags & TcpOptionMpTcpDSS::DSNMappingPresent))
-  {
-
-    // we want to set the final ssn to 0 but m_txBuffer->HeadSequence() is always removed from current SSN
-    // hence we set it here to m_txBuffer->HeadSequence() so that it becomes
-    // (m_txBuffer->HeadSequence() - m_txBuffer->HeadSequence() = 0 later.
-    // TODO rewrite so that it becomes clearer, maybe when we setMapping
-//    m_dssMapping.MapToSSN(m_txBuffer->HeadSequence());
-    m_dssMapping.MapToSSN (SequenceNumber32(0));
-    m_dssMapping.SetHeadDSN (SEQ64TO32(GetMeta()->m_txBuffer->TailSequence()));
-    m_dssMapping.SetMappingSize (0);
-
-    m_dssFlags |= TcpOptionMpTcpDSS::DSNMappingPresent;
-  }
-  else if(m_dssFlags & TcpOptionMpTcpDSS::DSNMappingPresent) 
-  {
-    // TODO explain
-//    + SequenceNumber32(1)
-    // +1 ?
-    m_dssMapping.MapToSSN (
-        SequenceNumber32 (m_dssMapping.HeadSSN().GetValue() - GetLocalIsn().GetValue()
-                         )
-                          );
-    NS_LOG_DEBUG ("Converting to relative SSN " << m_dssMapping.HeadSSN());
-  }
-
-  // if there is a mapping to send
-  if(m_dssFlags & TcpOptionMpTcpDSS::DSNMappingPresent)
-  {
-
-      dss->SetMapping (m_dssMapping.HeadDSN().GetValue(),
-                      /** SSN should be relative **/
-                      m_dssMapping.HeadSSN().GetValue(),
-                      m_dssMapping.GetLength(),
-                      // HACK to fix bug
-//                      std::min(m_dssMapping.GetLength(), header.Get),
-                      sendDataFin);
-   }
-
-  bool res = header.AppendOption (dss);
-  NS_ASSERT (res);
-}
-
-
-void
-MpTcpSubflow::AddMpTcpOptions (TcpHeader& header)
-{
-    NS_LOG_FUNCTION(this);
-    // TODO look for the mapping
-    if((header.GetFlags () & TcpHeader::SYN))
-    {
-
-        AddOptionMpTcp3WHS (header);
-    }
-    // as long as we've not received an ack from the peer we
-    // send an MP_CAPABLE with both keys
-    else if(!GetMeta()->FullyEstablished())
-    {
-        AddOptionMpTcp3WHS (header);
-    }
-
-
-  /// Constructs DSS if necessary
-  /////////////////////////////////////////
-    if(m_dssFlags)
-    {
-        AddMpTcpOptionDSS (header);
-    }
-
-    #if 0
-    // if we should probe
-    if (m_probeState == TcpOptionMpTcpDeltaOWD::PendingSend)
-    {
-        // We should have one configured
-//        NS_ASSERT (m_probeState );
-//        m_probeState == Object
-        Ptr<TcpOptionMpTcpDeltaOWD> delta =  Create<TcpOptionMpTcpDeltaOWD>();
-
-        Time t = Simulator::Now();
-
-        static int cookie_counter = 0;
-//        ;
-        delta->m_cookie = cookie_counter++;
-        delta->m_nanoseconds = t.GetNanoSeconds();
-        delta->m_type = TcpOptionMpTcpDeltaOWD::Request;
-
-        header.AppendOption( delta );
-
-    }
-    #endif
-    
-    #if 0
-    // disabled cause might create a problem with tcp header size
-    if (m_probeState == TcpOptionMpTcpOwdTimeStamp::PendingSend && m_state == ESTABLISHED)
-    {
-        // We should have one configured
-//        NS_ASSERT (m_probeState );
-//        m_probeState == Object
-        NS_LOG_LOGIC ("Crafting a MP_OWDTS probe");
-        Ptr<TcpOptionMpTcpOwdTimeStamp> owd_ts =  Create<TcpOptionMpTcpOwdTimeStamp>();
-
-        Time t = Simulator::Now();
-
-        static int cookie_counter = 0;
-//        ;
-        owd_ts->Setup (TcpOptionMpTcpOwdTimeStamp::Request, cookie_counter++, t.GetNanoSeconds());
-//        owd_ts->m_nanoseconds = ;
-//        owd_ts->m_type = ;
-        
-        header.AppendOption( owd_ts );
-
-        m_probeState = TcpOptionMpTcpOwdTimeStamp::ExpectingAnswer;
-    }
-    
-    // if we need to answer a probe
-    if (m_owdProbeAnswer.first == true) {
-    
-        NS_LOG_LOGIC ("Crafting answer to MP_OWDTS");
-        m_owdProbeAnswer.first = false;
-
-        header.AppendOption( m_owdProbeAnswer.second);
-    }
-    #endif
-}
-
-
-void
-MpTcpSubflow::ProcessClosing (Ptr<Packet> packet, const TcpHeader& tcpHeader)
-{
-  NS_LOG_FUNCTION (this << tcpHeader);
-
-  return TcpSocketBase::ProcessClosing (packet,tcpHeader);
-}
-
-/** Received a packet upon CLOSE_WAIT, FIN_WAIT_1, or FIN_WAIT_2 states */
-void
-MpTcpSubflow::ProcessWait (Ptr<Packet> packet, const TcpHeader& tcpHeader)
-{
-  NS_LOG_FUNCTION (this << tcpHeader);
-
-
-  TcpSocketBase::ProcessWait(packet,tcpHeader);
-}
-
-/** Deallocate the end point and cancel all the timers */
-void
-MpTcpSubflow::DeallocateEndPoint(void)
-{
-    NS_LOG_FUNCTION(this);
-    TcpSocketBase::DeallocateEndPoint();
-}
-
-
-void
-MpTcpSubflow::CompleteFork(
-  Ptr<const Packet> p, const TcpHeader& h,
-  const Address& fromAddress, const Address& toAddress
-)
-{
-  NS_LOG_INFO ( this << " Completing fork of MPTCP subflow");
-
-    // Already done in ForkMeta => TODO remove
-//  GetMeta()->GenerateUniqueMpTcpKey(true);
-    // We need to assign an id before the answer is actually sent
-
-  InetSocketAddress addr = InetSocketAddress::ConvertFrom(fromAddress);
-
-//  InetSocketAddress addr (fromAddress);
-// TODO cela devrait dependre du endpoint
-  uint8_t id = 0;
-  bool ok;
-  ok = GetMeta()->AddLocalId (&id, fromAddress);
-  NS_ASSERT_MSG (ok, "Master subflow has mptcp id " << (int) id);
-  NS_LOG_DEBUG ("Master subflow has mptcp id " << (int) id);
-
-
-  // Get port and address from peer (connecting host)
-  // TODO upstream ns3 should assert that to and from Address are of the same kind
-  TcpSocketBase::CompleteFork (p, h, fromAddress, toAddress);
-
-//   NS_FATAL_ERROR("TODO: endpoint never set. be careful to set it for meta too");
-//   GetMeta()->AddSubflow(this);
-  NS_LOG_INFO( this << " Endpoint="  << m_endPoint);
-    if (IsMaster())
-    {
-       NS_LOG_LOGIC("Setting meta endpoint to " << m_endPoint
-                    << " (old endpoint=" << GetMeta()->m_endPoint << " )"
-                    << " bound to interface " << m_endPoint->GetBoundNetDevice()
-                    );
-//       GetMeta()->m_endPoint = m_endPoint;
-
-
-       /** allows to set*/
-//       m_boundnetdevice = m_endPoint->GetBoundNetDevice();
-    }
-}
-
-//Ptr<MpTcpPathIdManager>
-//MpTcpSubflow::GetIdManager()
-//{
-//  return GetMeta()->m_remotePathIdManager;
-//}
-
-
-//void
-//MpTcpSubflow::InitializeCwnd (void)
-//{
-//  NS_LOG_LOGIC(this << "InitialCWnd:" << m_initialCWnd << " SegmentSize:" << GetSegSize());
-//  /*
-//   * Initialize congestion window, default to 1 MSS (RFC2001, sec.1) and must
-//   * not be larger than 2 MSS (RFC2581, sec.3.1). Both m_initiaCWnd and
-//   * m_segmentSize are set by the attribute system in ns3::TcpSocket.
-//   */
-//  m_cWnd = GetInitialCwnd() * GetSegSize();
-//  NS_LOG_DEBUG("m_cWnd set to " << m_cWnd);
-//}
-
-
-/**
-Apparently this function is never called for now
-**/
-void
-MpTcpSubflow::ConnectionSucceeded(void)
-{
-  NS_LOG_LOGIC(this << "Connection succeeded");
-  m_connected = true;
-//  if(IsMaster())
-//  GetMeta()->ConnectionS
-//  GetMeta()->OnSubflowEstablishment(this);
-//  TcpSocketBase::ConnectionSucceeded();
-}
-
-/** Received a packet upon SYN_SENT */
-void
-MpTcpSubflow::ProcessSynSent (Ptr<Packet> packet, const TcpHeader& tcpHeader)
-{
-  NS_LOG_FUNCTION (this << tcpHeader);
-  NS_ASSERT(m_state == SYN_SENT);
-
-  NS_LOG_DEBUG("endp=" << m_endPoint);
-  TcpSocketBase::ProcessSynSent (packet, tcpHeader);
-}
-
-
-
-/**
- Only checks should be done here since when this is called, the MPTCP connection
- is already established, with metas already created
-*/
-int
-MpTcpSubflow::ProcessOptionMpTcpCapable (const Ptr<const TcpOptionMpTcp> option)
-{
-    NS_LOG_LOGIC (this << option);
-    NS_ASSERT_MSG (IsMaster(), "You can receive MP_CAPABLE only on the master subflow");
-
-    /**
-    * Here is how the MPTCP 3WHS works:
-    *  o  SYN (A->B): A's Key for this connection.
-    *  o  SYN/ACK (B->A): B's Key for this connection.
-    *  o  ACK (A->B): A's Key followed by B's Key.
-    *
-    */
-    // Expect an MP_CAPABLE option
-    Ptr<const TcpOptionMpTcpCapable> mpc = DynamicCast<const TcpOptionMpTcpCapable>(option);
-    NS_ASSERT_MSG ( mpc, "There must be a MP_CAPABLE option");
-
-    NS_ASSERT_MSG ( mpc->HasReceiverKey(), "Only client should receive it" );
-    NS_ASSERT_MSG ( mpc->GetPeerKey () == GetMeta ()->GetLocalKey(), "Peer should have echoed back our key (" << GetMeta ()->GetLocalKey() << " )" );
-
-    // Peer key should aready be set
-//    GetMeta()->SetPeerKey ( mpcRcvd->GetSenderKey () );
-
-    // TODO add it to the manager too
-    return 0;
-}
-
-
-/**
-       |             |   SYN + MP_JOIN(Token-B, R-A)  |
-       |             |------------------------------->|
-       |             |<-------------------------------|
-       |             | SYN/ACK + MP_JOIN(HMAC-B, R-B) |
-       |             |                                |
-       |             |     ACK + MP_JOIN(HMAC-A)      |
-       |             |------------------------------->|
-       |             |<-------------------------------|
-       |             |             ACK                |
-
- HMAC-A = HMAC(Key=(Key-A+Key-B), Msg=(R-A+R-B))
- HMAC-B = HMAC(Key=(Key-B+Key-A), Msg=(R-B+R-A))
-  */
-
-int
-MpTcpSubflow::ProcessOptionMpTcpJoin (const Ptr<const TcpOptionMpTcp> option)
-{
-   NS_LOG_FUNCTION(this << option);
-
-   uint8_t addressId = 0; //!< each mptcp subflow has a uid assigned
-
-    NS_LOG_DEBUG("Expecting MP_JOIN...");
-
-    Ptr<const TcpOptionMpTcpJoin> join = DynamicCast<const TcpOptionMpTcpJoin>(option);
-    // TODO should be less restrictive in case there is a loss
-
-    NS_ASSERT_MSG( join, "There must be an MP_JOIN option in the SYN Packet" );
-    NS_ASSERT_MSG( join && join->GetMode() == TcpOptionMpTcpJoin::SynAck, "the MPTCP join option received is not of the expected 1 out of 3 MP_JOIN types." );
-
-    addressId = join->GetAddressId();
-    // TODO Here we should check the tokens
-//        uint8_t buf[20] =
-//        opt3->GetTruncatedHmac();
-  NS_LOG_DEBUG ("Id manager");
-  InetSocketAddress address ( m_endPoint->GetPeerAddress(), m_endPoint->GetPeerPort() );
-  bool res = GetMeta ()->AddRemoteId (addressId, address);
-  NS_ASSERT_MSG (res, "Address id should have been registered correctly");
-
-  return 0;
-}
-
-void
-MpTcpSubflow::StartOwdProbe ()
-{
-//    NS_ASSERT_MSG (m_probeState == TcpOptionMpTcpDeltaOWD::ExpectingAnswer, "Can't update state while waiting for answer" );
-//    m_probeState = TcpOptionMpTcpDeltaOWD::PendingSend;
-}
-
-//MpTcpSubflow::SetOwdProbing (TcpOptionMpTcpDeltaOWD::State state)
-//{
-//    NS_LOG_DEBUG (state << m_probeState);
-//    NS_ASSERT_MSG (m_probeState == ExpectingAnswer, "Can't update state while waiting for answer" )
-//
-//    if(m_probeState == WaitingAnswer)
-//}
-
-int
-MpTcpSubflow::ProcessOptionMpTcpDeltaOWD (const Ptr<const TcpOptionMpTcpDeltaOWD> option)
-{
-   NS_LOG_FUNCTION(this << option);
-
-#if 0
-   switch (option->GetType ())
-   {
-      case TcpOptionMpTcpDeltaOWD::Answer:
-        NS_ASSERT_MSG (TcpOptionMpTcpDeltaOWD::ExpectingAnswer, "Should receive an answer only in this mode");
-        NS_ASSERT (m_probingStats);
-        // cookie should be ok :
-        // TODO should check the cookie option.m_cookie
-//        NS_ASSERT (cookie == );
-        m_probingStats->FinishRound ( this, option->m_cookie, option->m_nanoseconds);
-        break;
-
-      case TcpOptionMpTcpDeltaOWD::Request:
-        /* TODO look for matching request
-        */
-        break;
-
-      default:
-        NS_FATAL_ERROR ("Unhandled case");
-   };
-   #endif 
-  return 0;
-}
-
-int
-MpTcpSubflow::ProcessOptionMpTcpOwdTimeStamp (const Ptr<const TcpOptionMpTcpOwdTimeStamp> option)
-{
-   NS_LOG_FUNCTION(this << option);
-
-
-   switch (option->GetType())
-   {
-      case TcpOptionMpTcpOwdTimeStamp::Answer:
-        NS_ASSERT_MSG (TcpOptionMpTcpOwdTimeStamp::ExpectingAnswer, "Should receive an answer only in this mode");
-        // cookie should be ok :
-//        NS_ASSERT (cookie == );
-        {
-            Time m = Time(option->m_nanoseconds);
-            m_owd[LocalOwdEstimator]->Measurement(m);
-            NS_LOG_DEBUG ("Owd of this subflow = " << m);
-            m_probeState = TcpOptionMpTcpOwdTimeStamp::PendingSend;
-        }
-        break;
-
-      case TcpOptionMpTcpOwdTimeStamp::Request:
-        {
-            //! Craft packet and send it next.
-            Time now = Simulator::Now ();
-            Time m =  now - Time (option->m_nanoseconds);
-            m_owd[RemoteOwdEstimator]->Measurement(m);
-            NS_LOG_DEBUG ("Owd of the remote subflow = " << m);
-            // TODO MATT prepare an answer 
-            Ptr<TcpOptionMpTcpOwdTimeStamp> owd_ts =  Create<TcpOptionMpTcpOwdTimeStamp>();
-            // TODO remember the cookie and reuse it ?
-            owd_ts->Setup (TcpOptionMpTcpOwdTimeStamp::Answer, option->m_cookie, m.GetNanoSeconds());
-            m_owdProbeAnswer = std::make_pair (true, owd_ts);
-        }
-        
-        break;
-
-      default:
-        NS_FATAL_ERROR ("Unhandled case");
-   };
-  return 0;
-}
-
-
-// TODO passer le header
-int
-MpTcpSubflow::ProcessOptionMpTcp (const Ptr<const TcpOption> option)
-{
-    //! adds the header
-    NS_LOG_FUNCTION (option);
-    // TODO
-    Ptr<const TcpOptionMpTcp> main = DynamicCast<const TcpOptionMpTcp>(option);
-    switch(main->GetSubType())
-    {
-        case TcpOptionMpTcp::MP_CAPABLE:
-            return ProcessOptionMpTcpCapable (main);
-
-        case TcpOptionMpTcp::MP_JOIN:
-            return ProcessOptionMpTcpJoin(main);
-
-        case TcpOptionMpTcp::MP_DSS:
-            {
-                Ptr<const TcpOptionMpTcpDSS> dss = DynamicCast<const TcpOptionMpTcpDSS>(option);
-                NS_ASSERT (dss);
-                // Update later on
-                ProcessOptionMpTcpDSSEstablished (dss);
-            }
-            break;
-
-          #if 0
-          // TODO this option might be the cause of 
-          // mergecap: The capture file iperf-mptcp-0-1.pcap appears to have been cut short in the middle of a packet.
-        case TcpOptionMpTcp::MP_DELTAOWD:
-            {
-                Ptr<const TcpOptionMpTcpDeltaOWD> delta = DynamicCast<const TcpOptionMpTcpDeltaOWD>(option);
-                NS_ASSERT(delta);
-                ProcessOptionMpTcpDeltaOWD (delta);
-            }
-            break;
-
-        case TcpOptionMpTcp::MP_OWDTS:
-            {
-            
-//                Ptr<const TcpOptionMpTcpOwdTimeStamp> owdts= DynamicCast<const TcpOptionMpTcpOwdTimeStamp>(option);
-//                NS_ASSERT (owdts);
-//                ProcessOptionMpTcpOwdTimeStamp (owdts);
-            }
-            break;
-      #endif
-
-        case TcpOptionMpTcp::MP_ADD_ADDR:
-        case TcpOptionMpTcp::MP_REMOVE_ADDR:
-        
-        case TcpOptionMpTcp::MP_FASTCLOSE:
-        case TcpOptionMpTcp::MP_FAIL:
-            
-        default:
-            NS_FATAL_ERROR ("Unrecognized mptcp option in the base class MpTcpSubflow.");
-            break;
-
-
-    };
-
-    return 0;
-}
-
-//TcpOptionMpTcpJoin::State
-// TODO move to meta and adapt meta state
-void
-MpTcpSubflow::AddOptionMpTcp3WHS (TcpHeader& hdr) const
-{
-  //NS_ASSERT(m_state == SYN_SENT || m_state == SYN_RCVD);
-  NS_LOG_FUNCTION(this << hdr << hdr.FlagsToString(hdr.GetFlags()));
-
-  if( IsMaster() )
-  {
-//    if(GetMeta()->GetLocalKey() == 0)
-//    {
-//
-//    }
-
-    //! Use an MP_CAPABLE option
-    Ptr<TcpOptionMpTcpCapable> mpc =  CreateObject<TcpOptionMpTcpCapable>();
-    switch (hdr.GetFlags())
-    {
-      case TcpHeader::SYN:
-      case (TcpHeader::SYN | TcpHeader::ACK):
-        mpc->SetSenderKey( GetMeta()->GetLocalKey() );
-        break;
-      case TcpHeader::ACK:
-        mpc->SetSenderKey( GetMeta()->GetLocalKey() );
-        mpc->SetPeerKey( GetMeta()->GetPeerKey() );
-        break;
-      default:
-        NS_FATAL_ERROR ("Should never happen");
-        break;
-    };
-    NS_LOG_INFO ("Appended option" << mpc);
-    bool res = hdr.AppendOption( mpc );
-    NS_ASSERT (res);
-  }
-  else
-  {
-    Ptr<TcpOptionMpTcpJoin> join =  CreateObject<TcpOptionMpTcpJoin>();
-
-    switch(hdr.GetFlags())
-    {
-      case TcpHeader::SYN:
-        {
-          join->SetMode(TcpOptionMpTcpJoin::Syn);
-//          uint32_t token = 0;
-//          uint64_t idsn = 0;
-//          int result = 0;
-//          result =
-//          MpTcpSocketBase::GenerateTokenForKey( MPTCP_SHA1, GetMeta()->GetRemoteKey(), token, idsn );
-
-          join->SetPeerToken(GetMeta()->GetPeerToken());
-          join->SetNonce(0);
-        }
-        break;
-
-      case TcpHeader::ACK:
-        {
-          uint8_t hmac[20];
-
-          join->SetMode(TcpOptionMpTcpJoin::Ack);
-          join->SetHmac( hmac );
-        }
-        break;
-
-      case (TcpHeader::SYN | TcpHeader::ACK):
-        {
-          join->SetMode(TcpOptionMpTcpJoin::SynAck);
-          //! TODO request from idmanager an id
-          static uint8_t id = 0;
-          // TODO
-          NS_LOG_WARN ("IDs are incremental, there is no real logic behind it yet");
-  //        id = GetIdManager()->GetLocalAddrId( InetSocketAddress(m_endPoint->GetLocalAddress(),m_endPoint->GetLocalPort()) );
-
-          // TODO use GetLocalId
-          join->SetAddressId ( id++ );
-          join->SetTruncatedHmac (424242); // who cares
-          join->SetNonce (4242); //! truly random :)
-        }
-        break;
-
-      default:
-        NS_FATAL_ERROR("Should never happen");
-        break;
-    }
-
-    NS_LOG_INFO("Appended option" << join);
-    bool res = hdr.AppendOption( join );
-    NS_ASSERT (res);
-  }
-
-  //!
-//  if()
-}
-
-
-//DISABLE_MEMBER(int, Listen)
-int
-MpTcpSubflow::Listen(void)
-{
-  NS_FATAL_ERROR("This should never be called. The meta will make the subflow pass from LISTEN to ESTABLISHED.");
-}
-
-void
-MpTcpSubflow::NotifySend (uint32_t spaceAvailable)
-{
-  GetMeta()->NotifySend(spaceAvailable);
-}
-
-
-/*
-if one looks at the linux kernel, tcp_synack_options
-*/
-
-
-void
-MpTcpSubflow::ProcessSynRcvd(Ptr<Packet> packet, const TcpHeader& tcpHeader, const Address& fromAddress,
-    const Address& toAddress)
-{
-  //!
-  NS_LOG_FUNCTION (this << tcpHeader);
-  TcpSocketBase::ProcessSynRcvd(packet, tcpHeader, fromAddress, toAddress);
-}
-
-bool
-MpTcpSubflow::SendPendingData(bool withAck)
-{
-  //!
-  NS_LOG_FUNCTION(this);
-  return TcpSocketBase::SendPendingData(withAck);
-}
-
-
-/**
-TODO m_masterSocket should not be necessary
-*/
-bool
-MpTcpSubflow::IsMaster() const
-{
-//  NS_ASSERT(GetMeta());
-
-  return m_masterSocket;
-  // TODO it will never return true
-//  TcpStates_t metaState = GetMeta()->GetState();
-//  return (metaState == SYN_RCVD
-//      || metaState == SYN_SENT
-//    || m_endPoint == GetMeta()->m_endPoint
-//); // This is master subsock, its endpoint is the same as connection endpoint.
-  // is that enough ?
-//  return (m_metaSocket->m_subflows.size() == 1);
-}
-
-
-bool
-MpTcpSubflow::BackupSubflow() const
-{
-  return m_backupSubflow;
-}
-
-
-/**
-should be able to advertise several in one packet if enough space
-It is possible
-http://tools.ietf.org/html/rfc6824#section-3.4.1
-   A host can send an ADD_ADDR message with an already assigned Address
-   ID, but the Address MUST be the same as previously assigned to this
-   Address ID, and the Port MUST be different from one already in use
-   for this Address ID.  If these conditions are not met, the receiver
-   SHOULD silently ignore the ADD_ADDR.  A host wishing to replace an
-   existing Address ID MUST first remove the existing one
-   (Section 3.4.2).
-
-   A host that receives an ADD_ADDR but finds a connection set up to
-   that IP address and port number is unsuccessful SHOULD NOT perform
-   further connection attempts to this address/port combination for this
-   connection.  A sender that wants to trigger a new incoming connection
-   attempt on a previously advertised address/port combination can
-   therefore refresh ADD_ADDR information by sending the option again.
-
-**/
-void
-MpTcpSubflow::AdvertiseAddress(Ipv4Address addr, uint16_t port)
-{
-  NS_LOG_FUNCTION("Started advertising address");
-//  NS_ASSERT( );
-#if 0
-//      IPv4Address;;ConvertFrom ( addr );
-  Ptr<TcpOptionMpTcpAddAddress> addAddrOption = CreateObject<TcpOptionMpTcpAddAddress>();
-  addAddrOption->SetAddress( InetSocketAddress( m_endPoint->GetLocalAddress(),0), addrId );
-
-
-//      this->SendPacket(pkt, header, m_localAddress, m_remoteAddress, FindOutputNetDevice(m_localAddress) );
-  NS_LOG_INFO("Advertise  Addresses-> "<< header);
-  #endif
-}
-
-
-bool
-MpTcpSubflow::StopAdvertisingAddress(Ipv4Address address)
-{
-  return true;
-}
-
-
-void
-MpTcpSubflow::ReTxTimeout()
-{
-  NS_LOG_LOGIC("MpTcpSubflow ReTxTimeout expired !");
-  TcpSocketBase::ReTxTimeout();
-}
-
-/*
-   The sender MUST keep data in its send buffer as long as the data has
-   not been acknowledged at both connection level and on all subflows on
-   which it has been sent.
-
-For now assume
-Called from NewAck, this
-SequenceNumber32 const& ack,
-*/
-bool
-MpTcpSubflow::DiscardAtMostOneTxMapping(SequenceNumber64 const& firstUnackedMeta, MpTcpMapping& mapping)
-//MpTcpSubflow::DiscardTxMappingsUpTo(SequenceNumber32 const& dack, SequenceNumber32 const& ack)
-{
-  NS_LOG_DEBUG("Removing mappings with DSN <" << firstUnackedMeta
-          << " and SSN <" << FirstUnackedSeq()
-          );
-
-  SequenceNumber32 headSSN = m_txBuffer->HeadSequence();
-
-
-  //  MpTcpMapping mapping;
-  // m_state == FIN_WAIT_1 &&
-  if(headSSN >= FirstUnackedSeq())
-  {
-    NS_LOG_DEBUG("Subflow tx Buffer already empty");
-    return false;
-  }
-  else if(!m_TxMappings.GetMappingForSSN(headSSN, mapping))
-  {
-    m_TxMappings.Dump();
-    NS_LOG_ERROR("Could not associate a tx mapping to ssn [" << headSSN << "]. Should be impossible");
-//    NS_FATAL_ERROR("Could not associate a tx mapping to ssn [" << headSSN << "]. Should be impossible");
-    return false;
-  }
-
-  if(mapping.TailDSN() < firstUnackedMeta && mapping.TailSSN() < FirstUnackedSeq())
-  {
-    NS_LOG_DEBUG("mapping can be discarded");
-    bool ok = m_TxMappings.DiscardMapping(mapping);
-    NS_ASSERT(ok);
-    m_txBuffer->DiscardUpTo(mapping.TailSSN() + SequenceNumber32(1));
-    return true;
-  }
-
-  return false;
-}
-
-/* 
-STUB; hack to trick the TcpSocketBase that relies so much on m_rWnd
-*/
-bool
-MpTcpSubflow::UpdateWindowSize (const TcpHeader& header)
-{
-  // TODO do nothing, 
-//    bool updated = TcpSocketBase::UpdateWindowSize(header);
-//    if (updated)
-//    {
-//        GetMeta()->UpdateWindowSize(header);
-//    }
-//  if(!GetMeta()->FullyEstablished()) {
-    // Hackish
-//  m_rWnd =     GetMeta()->m_rWnd;
-//  m_rWnd = header.GetWindowSize();
-//  }
-  
-//   = GetMeta()->m_rWnd;
-  return true;
-}
-
-uint32_t
-MpTcpSubflow::GetTxAvailable() const
-{
-  //!
-  return TcpSocketBase::GetTxAvailable();
-}
-
-
-void
-MpTcpSubflow::UpdateTxBuffer()
-{
-  NS_LOG_FUNCTION(this);
-  GetMeta()->SyncTxBuffers();
-}
-
-/**
-TODO check with its parent equivalent, may miss a few features
-Receipt of new packet, put into Rx buffer
-
-SlowStart and fast recovery remains untouched in MPTCP.
-The reaction should be different depending on if we handle NR-SACK or not
-*/
-
-void
-MpTcpSubflow::NewAck(SequenceNumber32 const& ack)
-{
-  NS_LOG_FUNCTION (this << ack);
-
-  TcpSocketBase::NewAck(ack);
-#if 0
-  MpTcpMapping mapping;
-
-  // TODO move elsewhere on rece
-//  if(!m_TxMappings.GetMappingForSegment( ack-1, mapping) )
-//  {
-//    NS_LOG_DEBUG("Could not find an adequate Tx mapping for ack " << ack);
-//    return;
-//  }
-
-  NS_LOG_FUNCTION (this << ack);
-  NS_LOG_LOGIC ("Subflow receieved ACK for seq " << ack <<
-                " cwnd " << m_cWnd <<
-                " ssthresh " << m_ssThresh
-              );
-
-
-
-  // Check for exit condition of fast recovery
-  if (m_inFastRec)
-    { // RFC2001, sec.4; RFC2581, sec.3.2
-      // First new ACK after fast recovery: reset cwnd
-      m_cWnd = m_ssThresh;
-      m_inFastRec = false;
-      NS_LOG_INFO ("Exiting fast recovery. Reset cwnd to " << m_cWnd);
-    };
-
-
-  // Increase of cwnd based on current phase (slow start or congestion avoidance)
-  if (m_cWnd < m_ssThresh)
-    { // Slow start mode, add one segSize to cWnd. Default m_ssThresh is 65535. (RFC2001, sec.1)
-      m_cWnd += GetSegSize();
-      NS_LOG_INFO ("In SlowStart, updated to cwnd " << m_cWnd << " ssthresh " << m_ssThresh);
-    }
-  else
-    {
-      /** TODO in the future, there should be a way to easily override this in future releases
-      **/
-
-      // Congestion avoidance mode, increase by (segSize*segSize)/cwnd. (RFC2581, sec.3.1)
-//
-//      OpenCwndInCA(0);
-
-      // To increase cwnd for one segSize per RTT, it should be (ackBytes*segSize)/cwnd
-//      double adder = static_cast<double> (m_segmentSize * m_segmentSize) / m_cWnd.Get ();
-//      adder = std::max (1.0, adder);
-//      m_cWnd += static_cast<uint32_t> (adder);
-      NS_LOG_INFO ("In CongAvoid, updated to cwnd " << m_cWnd << " ssthresh " << m_ssThresh);
-    }
-
-
-
-
-  if (m_state != SYN_RCVD)
-    { // Set RTO unless the ACK is received in SYN_RCVD state
-      NS_LOG_LOGIC (this << " Cancelled ReTxTimeout event which was set to expire at " <<
-          (Simulator::Now () + Simulator::GetDelayLeft (m_retxEvent)).GetSeconds ());
-      m_retxEvent.Cancel();
-      // On recieving a "New" ack we restart retransmission timer .. RFC 2988
-      // TODO
-//      m_rto = m_rtt->RetransmitTimeout();
-//      NS_LOG_LOGIC (this << " Schedule ReTxTimeout at time " <<
-//          Simulator::Now ().GetSeconds () << " to expire at time " <<
-//          (Simulator::Now () + m_rto.Get ()).GetSeconds ());
-//      m_retxEvent = Simulator::Schedule(m_rto, &MpTcpSubflow::ReTxTimeout, this);
-    }
-
-  if (GetRwnd() == 0 && m_persistEvent.IsExpired())
-    { // Zero window: Enter persist state to send 1 byte to probe
-      NS_LOG_LOGIC (this << "Enter zerowindow persist state");NS_LOG_LOGIC (this << "Cancelled ReTxTimeout event which was set to expire at " <<
-          (Simulator::Now () + Simulator::GetDelayLeft (m_retxEvent)).GetSeconds ());
-      m_retxEvent.Cancel();
-      NS_LOG_LOGIC ("Schedule persist timeout at time " <<
-          Simulator::Now ().GetSeconds () << " to expire at time " <<
-          (Simulator::Now () + m_persistTimeout).GetSeconds ());
-      m_persistEvent = Simulator::Schedule(m_persistTimeout, &MpTcpSubflow::PersistTimeout, this);
-      NS_ASSERT(m_persistTimeout == Simulator::GetDelayLeft (m_persistEvent));
-    }
-
-  // Note the highest ACK and tell app to send more
-  NS_LOG_LOGIC ("TCP " << this << " NewAck " << ack <<
-      " numberAck " << (ack - FirstUnackedSeq())); // Number bytes ack'ed
-
-
-  m_firstTxUnack = std::min(ack, m_txBuffer->TailSequence());
-
-  // TODO: get mapping associated with that Ack and
-  // TODO could && m_state != FIN_WAIT_1
-  // TODO I believe we could change that into something else
-  if(!m_TxMappings.GetMappingForSSN( SequenceNumber32(ack-1), mapping) ) {
-
-    NS_LOG_WARN("Late ack ! Mapping likely to have been discared already. Dumping Tx Mappings:");
-    m_TxMappings.Dump();
-  }
-  else {
-    // TODO check if all mappings below that are acked before removing them
-    //    m_txBuffer->DiscardUpTo(ack);
-
-    /** TODO here we have to update the nextTxBuffer
-    but we can discard only if the full mapping was acknowledged
-    la c completement con. A corriger
-    */
-//    if(m_nextTxSequence > mapping.TailSSN()) {
-//
-//      m_txBuffer->DiscardUpTo(m_nextTxSequence);
-//    }
-//      std::distance(s.begin(), s.lower_bound(x))
-    // #error
-
-    /**
-    Before removing data from txbuffer, it must have been acked at both subflow
-    and connection level.
-    Here we go through the list of TxMappings
-    min(ack,dataack
-    **/
-//    m_TxMappings.DiscardMappingsUpToDSN()
-
-
-  }
-
-  // Call it before to free window
-  GetMeta()->OnSubflowNewAck(this);
-// TODO I should call
-
-
-  if (GetTxAvailable() > 0)
-    {
-      // Ok, va appeler la meta
-      NotifySend(GetTxAvailable());
-    }
-
-  if (ack > m_nextTxSequence)
-    {
-//      if(m_state == FIN_WAIT_1 || m_state == CLOSING) {
-//
-//      }
-//      NS_LOG_DEBUG("Advancing m_nextTxSequence from " << m_nextTxSequence  << " to " << ack);
-      m_nextTxSequence = std::min(ack, m_txBuffer->TailSequence()); // If advanced
-    }
-
-  if (m_txBuffer->Size() == 0 && m_state != FIN_WAIT_1 && m_state != CLOSING)
-    {
-      // No retransmit timer if no data to retransmit
-      NS_LOG_WARN (this << "TxBuffer empty. Cancelled ReTxTimeout event which was set to expire at " <<
-          (Simulator::Now () + Simulator::GetDelayLeft (m_retxEvent)).GetSeconds ());
-      m_retxEvent.Cancel();
-      return;
-    }
-
-  if (m_txBuffer->Size() == 0)
-    {
-      NS_LOG_DEBUG("No tx buffer");
-//      throughput = 10000000 * 8 / (Simulator::Now().GetSeconds() - fLowStartTime);
-//      NS_LOG_UNCOND("goodput -> " << throughput / 1000000 << " Mbps {Tx Buffer is now empty}  P-AckHits:" << pAckHit);
-      return;
-    }
-  // Try to send more data
-  SendPendingData(m_connected);
-
-//  TcpSocketBase::NewAck( ack );
-  // WRONG  they can be sparse. This should be done by meta
-  // DiscardTxMappingsUpToDSN( ack );
-  //  Je peux pas le discard tant que
-  //  m_txBuffer->DiscardUpTo( ack );
-  // TODO check the full mapping is reachable
-//  if( m_txBuffer->Available(mapping.HeadDSN(), mapping.MaxSequence()))
-//  {
-//    Packet pkt = m_rxBuffer->Extract(mapping.HeadDSN(), mapping.GetLength() );
-//
-//    //! pass on data
-//    GetMeta()->ReceivedData( pkt, mapping );
-//
-//  }
-#endif
-}
-
-
-
-Ptr<Packet>
-MpTcpSubflow::RecvFrom(uint32_t maxSize, uint32_t flags, Address &fromAddress)
-{
-  NS_FATAL_ERROR("Disabled in MPTCP. Use ");
-  return 0;
-}
-
-Ptr<Packet>
-MpTcpSubflow::Recv(uint32_t maxSize, uint32_t flags)
-{
-  //!
-  NS_FATAL_ERROR("Disabled in MPTCP. Use ");
-  return 0;
-}
-
-Ptr<Packet>
-MpTcpSubflow::Recv(void)
-{
-  //!
-  NS_FATAL_ERROR("Disabled in MPTCP. Use ");
-  return 0;
-}
-
-
-//bool
-//MpTcpSubflow::TranslateSSNtoDSN(SequenceNumber32 ssn,SequenceNumber32 &dsn)
-//{
-//  // first find if a mapping exists
-//  MpTcpMapping mapping;
-//  if(!GetMappingForSegment( m_RxMappings, ssn, mapping) )
-//  {
-//    //!
-//    return false;
-//  }
-//
-//  return mapping.TranslateSSNToDSN(ssn,dsn);
-//}
-
-
-
-/**
-this is private
-**/
-Ptr<Packet>
-MpTcpSubflow::ExtractAtMostOneMapping (uint32_t maxSize, bool only_full_mapping, SequenceNumber64 *headDSN)
-{
-  NS_LOG_DEBUG(this << " maxSize="<< maxSize);
-  MpTcpMapping mapping;
-  Ptr<Packet> p = Create<Packet>();
-
-  uint32_t rxAvailable = GetRxAvailable();
-  if(rxAvailable == 0)
-  {
-    NS_LOG_LOGIC("Nothing to extract");
-    return p;
-  }
-  else
-  {
-    NS_LOG_LOGIC(rxAvailable  << " Rx available");
-  }
-
-  // as in linux, we extract in order
-  SequenceNumber32 headSSN = m_rxBuffer->HeadSequence();
-//  NS_LOG_LOGIC("Extracting from SSN [" << headSSN << "]");
-  //SequenceNumber32 headDSN;
-   if(!m_RxMappings.GetMappingForSSN(headSSN, mapping))
-//  if(!m_RxMappings.TranslateSSNtoDSN(headSSN, dsn))
-  {
-//      NS_LOG_DEBUG("Could not find a mapping for headSSN=" << headSSN );
-
-      m_RxMappings.Dump();
-      NS_FATAL_ERROR("Could not associate a mapping to ssn [" << headSSN << "]. Should be impossible");
-//    NS_FATAL_ERROR("Could not associate a mapping to ssn [" << headSSN << "]. Should be impossible");
-  }
-  NS_LOG_DEBUG("Extracting mapping " << mapping);
-
-  *headDSN = mapping.HeadDSN();
-
-  if(only_full_mapping) {
-
-    if(mapping.GetLength() > maxSize)
-    {
-      NS_LOG_DEBUG("Not enough space available to extract the full mapping");
-      return p;
-    }
-
-    if(m_rxBuffer->Available() < mapping.GetLength())
-    {
-      NS_LOG_DEBUG("Mapping not fully received yet");
-      return p;
-    }
-  }
-
-  // Extract at most one mapping
-  maxSize = std::min(maxSize, (uint32_t)mapping.GetLength());
-
-  NS_LOG_DEBUG("Extracting at most " << maxSize << " bytes ");
-  p = m_rxBuffer->Extract ( maxSize );
-
-//  m_RxMappings.DiscardMappingsUpToDSN( headDSN);
-  // Not included
-
-  // TODO seulement supprimer ce que l'on a extrait !
-  SequenceNumber32 extractedTail = headSSN + p->GetSize() - 1;
-
-  NS_LOG_DEBUG("ExtractedTail=" << extractedTail << " to compare with " << mapping.TailSSN());
-
-  NS_ASSERT_MSG( extractedTail <= mapping.TailSSN(), "Can not extract more than the size of the mapping");
-
-  if(extractedTail < mapping.TailSSN() )
-  {
-    NS_ASSERT_MSG(!only_full_mapping, "The only extracted size possible should be the one of the mapping");
-    // only if data extracted covers full mapping we can remove the mapping
-  }
-  else
-  {
-    m_RxMappings.DiscardMapping(mapping);
-  }
-//  m_RxMappings.DiscardMappingsUpToSN( mapping.TailDSN() + SequenceNumber32(1), mapping.TailSSN());
-  return p;
-}
-
-
-void
-MpTcpSubflow::AppendDSSMapping (const MpTcpMapping& mapping)
-{
-    NS_LOG_FUNCTION(this << mapping);
-    m_dssFlags |= TcpOptionMpTcpDSS::DSNMappingPresent;
-    m_dssMapping = mapping;
-}
-
-void
-MpTcpSubflow::AppendDSSAck ()
-{
-    NS_LOG_FUNCTION(this);
-    m_dssFlags |= TcpOptionMpTcpDSS::DataAckPresent;
-}
-
-void
-MpTcpSubflow::AppendDSSFin ()
-{
-    NS_LOG_FUNCTION(this);
-    m_dssFlags |= TcpOptionMpTcpDSS::DataFin;
-}
-
-
-uint32_t
-MpTcpSubflow::GetRwnd() const
-{
-  return GetMeta()->m_rWnd;
-}
-
-Ptr<RttEstimator> 
-MpTcpSubflow::GetOwd (OwdEstimator estimator)
-{
-    NS_ASSERT (m_owd);
-    return m_owd[estimator];
-}
-
-/**
-TODO here I should look for an associated mapping.
-
-ProcessEstablished
-
-If there is not, then I discard the stuff
-std::ostream& ns3::operator<<(std::ostream&,const ns3::TcpOptionMptcpMain&)
-
-TODO I should also notify the meta, maybe with an enum saying if it's new data/old etc...
-
-TODO merge with TcpSocketBase
-*/
-void
-MpTcpSubflow::ReceivedData (Ptr<Packet> p, const TcpHeader& tcpHeader)
-{
-  NS_LOG_FUNCTION (this << tcpHeader);
-//  NS_LOG_FUNCTION (this << tcpHeader);NS_LOG_LOGIC ("seq " << tcpHeader.GetSequenceNumber () <<
-//      " ack " << tcpHeader.GetAckNumber () <<
-//      " pkt size " << p->GetSize ()
-//      );
-  // Following was moved to ReceivedAck sincethis is from there that ReceivedData can
-  // be called
-
-  MpTcpMapping mapping;
-  bool sendAck = false;
-
-
-//  OutOfRange
-  // If cannot find an adequate mapping, then it should [check RFC]
-//  if(!m_RxMappings.GetMappingForSSN(tcpHeader.GetSequenceNumber(), mapping) )
-  SequenceNumber32 t= tcpHeader.GetSequenceNumber();
-//  t  -= GetPeerIsn();
-  if(!m_RxMappings.GetMappingForSSN( t, mapping) )
-  {
-
-    m_RxMappings.Dump();
-    NS_FATAL_ERROR("Could not find mapping associated ");
-    return;
-  }
-
-  // Put into Rx buffer
-  SequenceNumber32 expectedSSN = m_rxBuffer->NextRxSequence();
-//  NS_LOG_DEBUG("adding packet " << p->ToString());
-  if (!m_rxBuffer->Add(p, tcpHeader.GetSequenceNumber()))
-    { // Insert failed: No data or RX buffer full
-      NS_LOG_WARN("Insert failed, No data (" << p->GetSize() << ") ?"
-          // Size() returns the actual buffer occupancy
-//          << "or RX buffer full (Available:" << m_rxBuffer->Available()
-//          << " Occupancy=" << m_rxBuffer->Size()
-//          << " OOOSize=" << m_rxBuffer->OutOfOrder ()
-//          << " Maxbuffsize=" << m_rxBuffer->MaxBufferSize() << ")"
-//          << " or already buffered"
-          );
-      m_rxBuffer->Dump();
-
-      AppendDSSAck();
-      SendEmptyPacket(TcpHeader::ACK);
-      return;
-    }
-
-  // Size() = Get the actual buffer occupancy
-  if (m_rxBuffer->Size() > m_rxBuffer->Available() /* Out of order packets exist in buffer */
-    || m_rxBuffer->NextRxSequence() > expectedSSN + p->GetSize() /* or we filled a gap */
-    )
-    { // A gap exists in the buffer, or we filled a gap: Always ACK
-      sendAck = true;
-    }
-  else
-    { // In-sequƒ∂ence packet: ACK if delayed ack count allows
-      // TODO i removed delayed ack. may reestablish later
-//      if (++m_delAckCount >= m_delAckMaxCount)
-//        {
-//          m_delAckEvent.Cancel();
-//          m_delAckCount = 0;
-          sendAck = true;
-//            dss->SetDataAck(GetMeta()->m_rxBuffer->NextRxSequence().GetValue());
-//            SendEmptyPacket(answerHeader);
-//        }
-//      else if (m_delAckEvent.IsExpired())
-//        {
-//          m_delAckEvent = Simulator::Schedule(m_delAckTimeout, &TcpSocketBase::DelAckTimeout, this);
-//          NS_LOG_LOGIC (this << " scheduled delayed ACK at " << (Simulator::Now () + Simulator::GetDelayLeft (m_delAckEvent)).GetSeconds ());
-//        }
-    }
-
-
-
-
-  // Notify app to receive if necessary
-  if (expectedSSN < m_rxBuffer->NextRxSequence())
-    { // NextRxSeq advanced, we have something to send to the app
-      if (!m_shutdownRecv)
-        {
-          // todo maybe retrieve return valu: should we send an ack ?
-           GetMeta()->OnSubflowRecv( this );
-           sendAck = true;
-        }
-      // Handle exceptions
-      if (m_closeNotified)
-        {
-          NS_LOG_WARN ("Why TCP " << this << " got data after close notification?");
-        }
-      // If we received FIN before and now completed all "holes" in rx buffer,
-      // invoke peer close procedure
-      if (m_rxBuffer->Finished() && (tcpHeader.GetFlags() & TcpHeader::FIN) == 0)
-        {
-          DoPeerClose();
-        }
-    }
-
-    // For now we always sent an ack
-
-    // should be always true hack to allow compilation
-    if(sendAck)
-    {
-        // This should be done automatically
-//      TcpHeader answerHeader;
-//      GenerateEmptyPacketHeader(answerHeader, TcpHeader::ACK);
-//      GetMeta()->AppendDataAck(answerHeader);
-//      SendEmptyPacket(answerHeader);
-      SendEmptyPacket(TcpHeader::ACK);
-    }
-
-  // TODO handle out of order case look at parent's member.
-  // TODO pass subflow id to the function
-  // TODO if that acknowledges a full mapping then transfer it to  the metasock
-}
-
-
-
-uint32_t
-MpTcpSubflow::UnAckDataCount()
-{
-  NS_LOG_FUNCTION (this);
-//  return GetMeta()->UnAckDataCount();
-  return TcpSocketBase::UnAckDataCount();
-}
-
-
-uint32_t
-MpTcpSubflow::BytesInFlight()
-{
-  NS_LOG_FUNCTION (this);
-  return TcpSocketBase::BytesInFlight();
-}
-
-/* TODO unsure ?
-*/
-uint32_t
-MpTcpSubflow::AvailableWindow()
-{
-  NS_LOG_FUNCTION (this);
-
-  return TcpSocketBase::AvailableWindow();
-//  GetMeta()->AvailableWindow();
-}
-
-/* this should be ok
-*/
-uint32_t
-MpTcpSubflow::Window (void)
-{
-  NS_LOG_FUNCTION (this);
-  return TcpSocketBase::Window();
-//  return GetMeta()->Window();
-}
-
-//uint32_t
-//MpTcpSubflow::RemoteWindow()
-//{
-//  NS_LOG_FUNCTION (this);
-//  return GetMeta()->RemoteWindow();
-//}
-
-// Ok
-uint16_t
-MpTcpSubflow::AdvertisedWindowSize(void)
-{
-  NS_LOG_DEBUG(this);
-  return GetMeta()->AdvertisedWindowSize();
-}
-
-/*
-   Receive Window:  The receive window in the TCP header indicates the
-      amount of free buffer space for the whole data-level connection
-      (as opposed to for this subflow) that is available at the
-      receiver.  This is the same semantics as regular TCP, but to
-      maintain these semantics the receive window must be interpreted at
-      the sender as relative to the sequence number given in the
-      DATA_ACK rather than the subflow ACK in the TCP header.  In this
-      way, the original flow control role is preserved.  Note that some
-      middleboxes may change the receive window, and so a host SHOULD
-      use the maximum value of those recently seen on the constituent
-      subflows for the connection-level receive window, and also needs
-      to maintain a subflow-level window for subflow-level processing.
-
-
-
-Because of this, an implementation MUST NOT use the RCV.WND
-   field of a TCP segment at the connection level if it does not also
-   carry a DSS option with a Data ACK field.
-*/
-//void
-//MpTcpSubflow::SetRemoteWindow(uint32_t win_size)
-//{
-//  NS_FATAL_ERROR("This function should never be called. Only meta can update remote window");
-////  NS_LOG_FUNCTION(win_size);
-////  MpTcpSubflow::GetMeta()->SetRemoteWindow()
-////  TcpSocketBase::SetRemoteWindow(win_size);
-//}
-
-
-// TODO merge with parent
-void
-MpTcpSubflow::ClosingOnEmpty(TcpHeader& header)
-{
-  /* TODO the question is: is that ever called ?
-  */
-  NS_LOG_FUNCTION(this << "mattator");
-
-    header.SetFlags( header.GetFlags() | TcpHeader::FIN);
-    // flags |= TcpHeader::FIN;
-    if (m_state == ESTABLISHED)
-    { // On active close: I am the first one to send FIN
-      NS_LOG_INFO ("ESTABLISHED -> FIN_WAIT_1");
-      m_state = FIN_WAIT_1;
-      // TODO get DSS, if none
-//      Ptr<TcpOptionMpTcpDSS> dss;
-//
-//      //! TODO add GetOrCreateMpTcpOption member
-//      if(!GetMpTcpOption(header, dss))
-//      {
-//        // !
-//        dss = Create<TcpOptionMpTcpDSS>();
-//
-//      }
-//      dss->SetDataFin(true);
-//      header.AppendOption(dss);
-
-    }
-    else if (m_state == CLOSE_WAIT)
-    {
-      // On passive close: Peer sent me FIN already
-      NS_LOG_INFO ("CLOSE_WAIT -> LAST_ACK");
-      m_state = LAST_ACK;
-
-    }
-
-    GetMeta()->OnSubflowClosing(this);
-}
-
-/*
-Quote from rfc 6824:
-    Because of this, an implementation MUST NOT use the RCV.WND
-    field of a TCP segment at the connection level if it does not also
-    carry a DSS option with a Data ACK field
-
-    and in not established mode ?
-    TODO
-*/
-
-
-
-int
-MpTcpSubflow::ProcessOptionMpTcpDSSEstablished (
-//  const TcpHeader& header, 
-  const Ptr<const TcpOptionMpTcpDSS> dss
-)
-{
-  NS_LOG_FUNCTION (this << dss << " from subflow ");
-
-  if (!GetMeta()->FullyEstablished() )
-  {
-    NS_LOG_LOGIC ("First DSS received !");
-
-    /* TODO
-    this should be removed and the meta should become fully established only when
-    the datack is received, hence it should be processed
-    maybe rework that part so that it pro
-    BecomeFullyEstablished
-    */
-    GetMeta()->BecomeFullyEstablished ();
-
-  }
-
-  SequenceNumber32 headDSN = GetMeta ()->GetRxBuffer()->NextRxSequence();
-  SequenceNumber32 dack;
-
-  //! datafin case handled at the start of the function
-  if( (dss->GetFlags() & TcpOptionMpTcpDSS::DSNMappingPresent) && !dss->DataFinMappingOnly() )
-  {
-      MpTcpMapping m;
-      // TODO Get mapping n'est utilis√© qu'une fois, copier le code ici
-      //+ SequenceNumber(1)
-      m = GetMapping (dss);
-      headDSN = m.HeadDSN();
-      m.MapToSSN ( m.HeadSSN() + GetPeerIsn() );
-//      AddPeerMapping(m);
-      // Add peer mapping
-      bool ok = m_RxMappings.AddMapping (m);
-      if (!ok)
-      {
-        NS_LOG_WARN ("Could not insert mapping: already received ?");
-        NS_LOG_UNCOND ("Dumping Rx mappings...");
-        m_RxMappings.Dump ();
-//        NS_FATAL_ERROR("Insert failed");
-      }
-  }
-
-
-  /* TODO that should have been called earlier, we put it just after the mapping diessction
-   just to retrieve the seq Number
-  */
-  if( dss->GetFlags() & TcpOptionMpTcpDSS::DataAckPresent)
-  {
-    dack = dss->GetDataAck ();
-    //    NS_LOG_DEBUG("DataAck detected");
-    /*  TODO we need access to the windowSize:
-     either we pass the TcpHeader or we use this quick ack:
-     */
-    if (!GetMeta()->UpdateWindowSize (m_receivedHeader.GetWindowSize (), headDSN, dack))
-    {
-      NS_LOG_ERROR ("YOU SHOULD DROP THE PACKET");
-    }
-    m_rWnd = GetMeta()->m_rWnd;
-
-    GetMeta()->ReceivedAck ( dack, this, false);
-//    SequenceNumber32 dack = SequenceNumber32(dss->GetDataAck());
-  }
-
-//  #if 0
-//  uint32_t ack = (tcpHeader.GetAckNumber()).GetValue();
-//  uint32_t tmp = ((ack - initialSeqNb) / m_segmentSize) % mod;
-//  ACK.push_back(std::make_pair(Simulator::Now().GetSeconds(), tmp));
-  if ( dss->GetFlags() & TcpOptionMpTcpDSS::DataFin)
-  {
-    NS_LOG_LOGIC("DFIN detected " << dss->GetDataFinDSN ());
-    GetMeta()->PeerClose ( SequenceNumber32 (dss->GetDataFinDSN()), this);
-  }
-
-  return 0;
-}
-
-uint8_t
-MpTcpSubflow::GetLocalId () const
-{
-  uint8_t localId;
-  bool res = GetMeta() ->m_localIdManager->GetMatch (
-      &localId,
-      InetSocketAddress (m_endPoint->GetLocalAddress(), m_endPoint->GetLocalPort())
-    );
-  NS_ASSERT (res);
-  return localId;
-}
-
-uint8_t
-MpTcpSubflow::GetRemoteId () const
-{
-  uint8_t peerId;
-  bool res = GetMeta() ->m_remoteIdManager->GetMatch (
-    &peerId,
-    InetSocketAddress (m_endPoint->GetPeerAddress(), m_endPoint->GetPeerPort())
-    );
-  NS_ASSERT (res);
-  return peerId;
-}
-
-void
-MpTcpSubflow::Dump (std::ostream &os) const
-{
-  TcpSocketBase::Dump (os);
-  // TODO check if we are connected
-//  os << "Local id=" << GetLocalId ()
-//     << "Remote id = " << GetRemoteId();
-}
-
-/*
-Upon ack receival we need to act depending on if it's new or not
--if it's new it may allow us to discard a mapping
--otherwise notify meta of duplicate
-
-this is called
-*/
-void
-MpTcpSubflow::ReceivedAck (Ptr<Packet> p, const TcpHeader& header)
-{
-  NS_LOG_FUNCTION (this << header);
-
-  // if packet size > 0 then it will call ReceivedData
-  TcpSocketBase::ReceivedAck(p, header );
-
-  // By default we always append a DACK
-  // We should consider more advanced schemes
-  AppendDSSAck ();
-}
-
-// TODO remove
-//bool
-//MpTcpSubflow::AddPeerMapping(const MpTcpMapping& mapping)
-//{
-//  NS_LOG_FUNCTION(this << mapping);
-//
-//  return true;
-//}
-
-} // end of ns3
diff --git a/src/internet/model/mptcp-subflow.h b/src/internet/model/mptcp-subflow.h
deleted file mode 100644
index b9308df..0000000
--- a/src/internet/model/mptcp-subflow.h
+++ /dev/null
@@ -1,620 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 University of Sussex
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author:  Matthieu Coudron <matthieu.coudron@lip6.fr>
- *          Morteza Kheirkhah <m.kheirkhah@sussex.ac.uk>
- */
-#ifndef MPTCP_SUBFLOW_H
-#define MPTCP_SUBFLOW_H
-
-#include <stdint.h>
-#include <vector>
-#include <queue>
-#include <list>
-#include <set>
-#include <map>
-#include "ns3/object.h"
-#include "ns3/uinteger.h"
-#include "ns3/traced-value.h"
-#include "ns3/trace-source-accessor.h"
-#include "ns3/sequence-number.h"
-#include "ns3/rtt-estimator.h"
-#include "ns3/event-id.h"
-#include "ns3/packet.h"
-#include "ns3/tcp-socket.h"
-#include "ns3/ipv4-end-point.h"
-#include "ns3/ipv4-address.h"
-#include "ns3/tcp-socket-base.h"
-#include "ns3/tcp-header.h"
-#include "ns3/mptcp-mapping.h"
-#include "ns3/tcp-option-mptcp.h"
-//#include "ns3/tcp-option-mptcp.h"
-
-using namespace std;
-
-namespace ns3
-{
-
-class MpTcpSocketBase;
-class MpTcpPathIdManager;
-class TcpOptionMpTcpDSS;
-class TcpOptionMpTcp;
-class TcpOptionMpTcpDeltaOWD;
-class TcpOptionMpTcpOwdTimeStamp;
-class SubflowPair;
-
-enum OwdEstimator {
-LocalOwdEstimator = 0,
-RemoteOwdEstimator = 1,
-};
-
-/**
- * \class MpTcpSubflow
-*/
-class MpTcpSubflow : public TcpSocketBase
-{
-public:
-
-  static TypeId
-  GetTypeId(void);
-
-  virtual TypeId GetInstanceTypeId (void) const;
-
-
-  /**
-  * Todo remove, exists in Socket ?
-  */
-  uint32_t GetTxAvailable() const;
-
-
-  /**
-  the metasocket is the socket the application is talking to.
-  Every subflow is linked to that socket.
-  \param The metasocket it is linked to
-  **/
-  MpTcpSubflow();
-
-//  MpTcpSubflow(const TcpSocketBase& sock);
-private:
-  MpTcpSubflow(const MpTcpSubflow&);
-public:
-  virtual ~MpTcpSubflow();
-
-//  TcpStates_t
-//  GetState() const;
-
-  virtual uint32_t
-  UnAckDataCount();
-  virtual uint32_t
-  BytesInFlight();
-  virtual uint32_t
-  AvailableWindow();
-  virtual uint32_t
-  Window(void);               // Return the max possible number of unacked bytes
-  // Undefined for now
-//  virtual uint32_t
-//  AvailableWindow(void);      // Return unfilled portion of window
-
-  /**
-   *
-   */
-  uint8_t GetLocalId () const;
-
-  /**
-   *
-   */
-  uint8_t GetRemoteId () const;
-
-  /**
-   * will update the meta rwnd. Called by subflows whose
-   * \return true
-  */
-  virtual bool UpdateWindowSize (const TcpHeader& header);
-
-  /**
-  \return Value advertised by the meta socket
-  */
-  virtual uint16_t
-  AdvertisedWindowSize(void);
-
-  /**
-   * \param metaSocket
-   */
-  virtual void
-  SetMeta(Ptr<MpTcpSocketBase> metaSocket);
-//  virtual int
-//  Connect(const Address &address);      // Setup endpoint and call ProcessAction() to connect
-
-//  static uint32_t
-//  GenerateTokenForKey(uint64_t key);
-
-//  uint8_t addrId,
-  /**
-  \warning for prototyping purposes, we let the user free to advertise an IP that doesn't belong to the node
-  (in reference to MPTCP connection agility).
-  \note Maybe we should change this behavior ?
-  TODO convert to Address to work with IPv6
-  */
-  virtual void
-  AdvertiseAddress(Ipv4Address , uint16_t port);
-
-
-  /**
-  \param dack left edge window at connection level
-  \param ack
-  \param mapping
-  **/
-  virtual bool
-  DiscardAtMostOneTxMapping(SequenceNumber64 const& dack,
-    MpTcpMapping& mapping);
-
-  /**
-  \brief Send a REM_ADDR for the specific address.
-  \see AdvertiseAddress
-  \return false if no id associated with the address which likely means it was never advertised in the first place
-  */
-  virtual bool
-  StopAdvertisingAddress(Ipv4Address);
-
-  /**
-   * \brief This is important. This should first request data from the meta
-   */
-  virtual void
-  NotifySend (uint32_t spaceAvailable);
-
-  /**
-   * for debug
-   */
-  void DumpInfo() const;
-  virtual void Dump (std::ostream &os) const;
-
-  /**
-  \brief
-  \note A Master socket is the first to initiate the connection, thus it will use the option MP_CAPABLE
-      during the 3WHS while any additionnal subflow must resort to the MP_JOIN option
-  \return True if this subflow is the first (should be unique) subflow attempting to connect
-  **/
-  virtual bool
-  IsMaster() const;
-
-  /**
-  \return True if this subflow shall be used only when all the regular ones failed
-  */
-  virtual bool
-  BackupSubflow() const;
-
-  /**
-  @brief According to rfc6824, the token is used to identify the MPTCP connection and is a
-   cryptographic hash of the receiver's key, as exchanged in the initial
-   MP_CAPABLE handshake (Section 3.1).  In this specification, the
-   tokens presented in this option are generated by the SHA-1 algorithm, truncated to the most significant 32 bits.
-  */
-//  virtual uint32_t
-//  GetLocalToken() const;
-
-//  virtual void
-//  DoForwardUp(Ptr<Packet> packet, Ipv4Header header, uint16_t port, Ptr<Ipv4Interface> incomingInterface);
-
-  virtual bool
-  SendPendingData(bool withAck = false);
-
-
-  /**
-  Disabled for now.
-  SendMapping should be used instead.
-  **/
-  int
-  Send(Ptr<Packet> p, uint32_t flags);
-
-  //! disabled
-  Ptr<Packet>
-  RecvFrom(uint32_t maxSize, uint32_t flags, Address &fromAddress);
-
-  //! disabled
-  Ptr<Packet>
-  Recv(uint32_t maxSize, uint32_t flags);
-
-  //! Disabled
-  Ptr<Packet>
-  Recv(void);
-
-  /**
-  *
-  * \param dsn will set the dsn of the beginning of the data
-  * \param only_full_mappings Set to true if you want to extract only packets that match a whole mapping
-  * \param dsn returns the head DSN of the returned packet
-  *
-  * \return this can return an EmptyPacket if on close
-  * Use a maxsize param ? if buffers linked then useless ?
-  *
-  */
-  virtual Ptr<Packet>
-  ExtractAtMostOneMapping (uint32_t maxSize, bool only_full_mappings, SequenceNumber64 *dsn);
-
-  //  RecvWithMapping(uint32_t maxSize, bool only_full_mappings, SequenceNumber32 &dsn);
-//  Ptr<Packet>
-
-  //! TODO should notify upper layer
-//  virtual void
-//  PeerClose(Ptr<Packet>, const TcpHeader&); // Received a FIN from peer, notify rx buffer
-//  virtual void
-//  DoPeerClose(void); // FIN is in sequence, notify app and respond with a FIN
-
-  /**
-  TODO used in previous implementation to notify meta of subflow closing.
-  See it that's worth keeping
-   */
-  virtual void
-  ClosingOnEmpty(TcpHeader& header);
-
-  virtual void
-  DeallocateEndPoint(void);
-
-  /*
-  TODO move to meta.
-  This should generate an *absolute*
-  mapping with 64bits DSN etc...
-
-  */
-//  virtual void ParseDSS(Ptr<Packet> p, const TcpHeader& header, Ptr<TcpOptionMpTcpDSS> dss);
-
-    // State transition functions
-//  virtual void
-//  ProcessEstablished(Ptr<Packet>, const TcpHeader&); // Received a packet upon ESTABLISHED state
-
-  /**
-  * \
-  * Why do I need this already :/ ?
-  */
-//  virtual Ptr<MpTcpSubflow>
-//  ForkAsSubflow(void) = 0;
-
-  /**
-  * This should
-  */
-  virtual void NewAck(SequenceNumber32 const& ack);
-
-  virtual void TimeWait();
-
-  virtual void DoRetransmit();
-
-/**
-TODO move this up to TcpSocketBase
-**/
-//  virtual void
-//  SetRemoteWindow(uint32_t );
-//  virtual uint32_t
-//  RemoteWindow();
-
-  virtual int Listen(void);
-  /**
-  TODO some options should be forwarded to the meta socket
-  */
-//  bool ReadOptions(Ptr<Packet> pkt, const TcpHeader& mptcpHeader);
-
-  // TODO ? Moved from meta
-  //  void ProcessListen  (uint8_t sFlowIdx, Ptr<Packet>, const TcpHeader&, const Address&, const Address&);
-  void
-  ProcessListen(Ptr<Packet> packet, const TcpHeader& tcpHeader, const Address& fromAddress, const Address& toAddress);
-
-  /**
-   * Will send MP_JOIN or MP_CAPABLE depending on if it is master or not
-   * Updates the meta endpoint
-   *
-   * \see TcpSocketBase::CompleteFork
-   */
-  virtual void
-  CompleteFork(Ptr<const Packet> p, const TcpHeader& h, const Address& fromAddress, const Address& toAddress);
-
-  virtual void
-  ProcessSynRcvd(Ptr<Packet> packet, const TcpHeader& tcpHeader, const Address& fromAddress,
-    const Address& toAddress);
-
-  virtual void ProcessSynSent(Ptr<Packet> packet, const TcpHeader& tcpHeader);
-  virtual void ProcessWait(Ptr<Packet> packet, const TcpHeader& tcpHeader);
-
-  virtual void UpdateTxBuffer();
-  /**
-  */
-  virtual void Retransmit(void);
-
-  /**
-   * Parse DSS essentially
-
-   */
-//  virtual int ProcessOptionMpTcpEstablished(const Ptr<const TcpOption> option);
-  virtual int ProcessOptionMpTcpDSSEstablished (
-//    const TcpHeader& header, 
-    const Ptr<const TcpOptionMpTcpDSS> option
-  );
-  virtual int ProcessOptionMpTcpJoin(const Ptr<const TcpOptionMpTcp> option);
-  virtual int ProcessOptionMpTcpCapable(const Ptr<const TcpOptionMpTcp> option);
-//  virtual int ProcessTcpOptionMpTcpDSS(Ptr<const TcpOptionMpTcpDSS> dss);
-
-  /** WIP TODO move this one to MptcpSubflowOwd */
-  int ProcessOptionMpTcpDeltaOWD (const Ptr<const TcpOptionMpTcpDeltaOWD> option);
-  int ProcessOptionMpTcpOwdTimeStamp (const Ptr<const TcpOptionMpTcpOwdTimeStamp> option);
-
-
-    // TODO rename to get remote or local
-  Ptr<MpTcpPathIdManager> GetIdManager ();
-
-  /**
-  Temporary, for debug
-  **/
-//  void
-//  SetupTracing(const std::string prefix);
-//  MpTcpMapping getSegmentOfACK( uint32_t ack);
-
-
-protected:
-  friend class MpTcpSocketBase;
-
-  //
-
-  /**
-  * This is a public function in TcpSocketBase but it shouldn't be public here !
-  **/
-  virtual int Close(void);
-
-
-  /**
-  TODO move to TcpSocketBase. Split  SendDataPacket into several functions ?
-  TODO remove
-  */
-  void GenerateDataPacketHeader(TcpHeader& header, SequenceNumber32 seq, uint32_t maxSize, bool withAck);
-
-
-  virtual void
-  CloseAndNotify(void);
-
-  ///// Mappings related
-  /**
-  * \param mapping
-  * \todo should check if mappings intersect, already exist etc...
-  */
-//  virtual bool AddPeerMapping(const MpTcpMapping& mapping);
-
-
-  virtual void GetMappedButMissingData(
-                std::set< MpTcpMapping >& missing
-                );
-
-  /**
-   * Depending on if this subflow is master or not, we want to
-   * trigger
-   * Callbacks being private members
-   * Overrides parent in order to warn meta
-   **/
-  virtual void ConnectionSucceeded(void);
-
-//
-//  /**
-//   * \brief NOOP. Initial cwnd should be set by meta.
-//   */
-//  virtual void
-//  SetSSThresh(uint32_t threshold);
-//
-//
-//  /**
-//   * \brief NOOP. Initial cwnd should be set by meta.
-//   */
-//  virtual void
-//  SetInitialCwnd(uint32_t cwnd);
-
-
-  /**
-   * \return Value defined by meta socket GetInitialCwnd
-   */
-//  virtual uint32_t
-//  GetInitialCwnd(void) const;
-
-  int
-  DoConnect();
-
-  /**
-  * TODO in fact, instead of relying on IsMaster etc...
-  * this should depend on meta's state , if it is wait or not
-  * and thus it should be pushed in meta (would also remove the need for crypto accessors)
-  */
-  virtual void
-  AddOptionMpTcp3WHS(TcpHeader& hdr) const;
-
-  // TO remove hopefully
-  virtual void
-  ProcessClosing(Ptr<Packet> packet, const TcpHeader& tcpHeader);
-
-
-  /**
-   * \brief Should be able to process any kind of MPTCP options.
-   *
-   * \warn When overriding this member function, call it last as
-   *       it throws a fatal exception upon unknown options
-   */
-  virtual int ProcessOptionMpTcp (const Ptr<const TcpOption> option);
-
-  /**
-   * To deal with MP_JOIN/MP_CAPABLE
-   */
-//  virtual int ProcessOptionMpTcpSynSent(const Ptr<const TcpOption> optionMapTo);
-
-    void StartOwdProbe ();
-public:
-  /**
-   *
-   */
-  Ptr<MpTcpSocketBase> GetMeta() const;
-
-  virtual uint32_t GetRwnd() const;
-  
-  MpTcpSubflow& operator =(const TcpSocketBase& s);
-  /**
-   * Not implemented
-   * \return false
-   */
-  bool IsInfiniteMappingEnabled() const;
-    
-  Ptr<RttEstimator> GetOwd (OwdEstimator);
-protected:
-
-  /** probe mechanism , check before sending a packet if we should */
-  TcpOptionMpTcpOwdTimeStamp::State m_probeState;
-
-  /**!< True if should add an MP_OWDTS option*/
-  std::pair<bool, Ptr<TcpOptionMpTcpOwdTimeStamp> > m_owdProbeAnswer;
-
-//  Time m_probeStartTime;    /**!< Record */
-//  Ptr<SubflowPair> m_probingStats;
-  Ptr<RttEstimator> m_owd[2];   /** 0 => local, 1 = remote */
-
-//  void DumpInfo () const;
-  /////////////////////////////////////////////
-  //// DSS Mapping handling
-  /////////////////////////////////////////////
-
-  /**
-   * Mapping is said "loose" because it is not tied to an SSN yet, this is the job
-   * of this function: it will look for the FirstUnmappedSSN() and map the DSN to it.
-   *
-   * Thus you should call it with increased dsn.
-   *
-   * \param dsnHead
-   */
-  bool AddLooseMapping (SequenceNumber64 dsnHead, uint16_t length);
-
-  /**
-   * If no mappings set yet, then it returns the tail ssn of the Tx buffer.
-   * Otherwise it returns the last registered mapping TailSequence
-   */
-  SequenceNumber32 FirstUnmappedSSN();
-
-  /**
-   * \brief Creates a DSS option if does not exist and configures it to have a dataack
-   * TODO what happens if existing datack already set ?
-   */
-  virtual void AppendDSSAck();
-
-  /**
-   * Corresponds to mptcp_write_dss_mapping and mptcp_write_dss_ack
-   */
-  virtual void AddMpTcpOptionDSS (TcpHeader& header);
-
-  /**
-   * rename to addDSSFin
-   */
-  virtual void AppendDSSFin ();
-  
-  /**
-   * Might be done differently ? called in 2 places
-   */
-  virtual void AppendDSSMapping(const MpTcpMapping& mapping);
-
-  virtual void ReceivedAck(Ptr<Packet>, const TcpHeader&); // Received an ACK packet
-//  virtual void ReceivedAck(SequenceNumber32 seq); // Received an ACK packet
-
-  virtual void ReceivedData(Ptr<Packet>, const TcpHeader&);
-
-
-  /**
-
-  */
-  uint32_t
-//  SendDataPacket(SequenceNumber32 seq, uint32_t maxSize, bool withAck); // Send a data packet
-  SendDataPacket(TcpHeader& header, SequenceNumber32 ssn, uint32_t maxSize);
-
-  /**
-  * Like send, but pass on the global seq number associated with
-  * \see Send
-  **/
-//  virtual int
-//  SendMapping(Ptr<Packet> p,
-//              //SequenceNumber32 seq
-//              MpTcpMapping& mapping
-//              );
-
-
-  virtual void
-  ReTxTimeout();
-  /**
-  This one overridesprevious one, adding MPTCP options when needed
-  */
-//  virtual void
-//  SendEmptyPacket(uint8_t flags);
-  virtual void
-  SendEmptyPacket(uint8_t flags); // Send a empty packet that carries a flag, e.g. ACK
-
-  virtual void
-  SendEmptyPacket(TcpHeader& header);
-
-  /**
-   * Overrides the TcpSocketBase that just handles the MP_CAPABLE option.
-   *
-   */
-  virtual void AddMpTcpOptions (TcpHeader& header);
-//  virtual Ptr<TcpSocketBase>
-//  Fork(void); // Call CopyObject<> to clone me
-
-
-// N'existe plus dans TcpSocketBase
-//  virtual void
-//  DupAck(const TcpHeader& t, uint32_t count); // Received dupack
-
-  /* TODO should be able to use parent's one little by little
-  */
-  virtual void
-  CancelAllTimers(void); // Cancel all timer when endpoint is deleted
-
-
-  uint8_t m_subflowId;   //!< Subflow's ID (TODO rename into subflowId ). Position of this subflow in MetaSock's subflows std::vector
-
-
-  // Use Ptr here so that we don't have to unallocate memory manually ?
-//  typedef std::list<MpTcpMapping> MappingList
-//  MappingList
-  MpTcpMappingContainer m_TxMappings;  //!< List of mappings to send
-  MpTcpMappingContainer m_RxMappings;  //!< List of mappings to receive
-
-
-protected:
-  Ptr<MpTcpSocketBase> m_metaSocket;    //!< Meta
-  virtual void SendPacket(TcpHeader header, Ptr<Packet> p);
-  
-
-
-private:
-
-  // Delayed values to
-  uint8_t m_dssFlags;           //!< used to know if AddMpTcpOptions should send a flag
-  MpTcpMapping m_dssMapping;    //!< Pending ds configuration to be sent in next packet
-
-
-  bool m_backupSubflow; //!< Priority
-  bool m_masterSocket;  //!< True if this is the first subflow established (with MP_CAPABLE)
-
-//  uint8_t m_localId;  //!< Store local host token, generated during the 3-way handshake
-//  uint8_t m_remoteId;  //!< Store local host token, generated during the 3-way handshake
-
-  uint32_t m_localNonce;  //!< Store local host token, generated during the 3-way handshake
-
-  int m_prefixCounter;  //!< Temporary variable to help with prefix generation . To remove later
-//  uint32_t m_remoteToken; //!< Store remote host token
-
-};
-
-}
-#endif /* MP_TCP_SUBFLOW */
diff --git a/src/internet/model/tcp-congestion-ops.cc b/src/internet/model/tcp-congestion-ops.cc
index 0fd7c12..69f1fac 100644
--- a/src/internet/model/tcp-congestion-ops.cc
+++ b/src/internet/model/tcp-congestion-ops.cc
@@ -38,12 +38,10 @@ TcpCongestionOps::GetTypeId (void)
 
 TcpCongestionOps::TcpCongestionOps ()
 {
-//    NS_LOG_FUNCTION(this);
 }
 
 TcpCongestionOps::TcpCongestionOps (const TcpCongestionOps &other)
 {
-//    NS_LOG_FUNCTION(this << "Copy");
 }
 
 TcpCongestionOps::~TcpCongestionOps ()
@@ -82,7 +80,7 @@ TcpNewReno::TcpNewReno (void) : TcpCongestionOps ()
 TcpNewReno::TcpNewReno (const TcpNewReno& sock)
   : TcpCongestionOps (sock)
 {
-  NS_LOG_FUNCTION (this << " Copy constructor");
+  NS_LOG_FUNCTION (this);
 }
 
 TcpNewReno::~TcpNewReno (void)
@@ -90,7 +88,7 @@ TcpNewReno::~TcpNewReno (void)
 }
 
 void
-TcpNewReno::IncreaseWindow (Ptr<TcpSocketBase> base, Ptr<TcpSocketState> tcb)
+TcpNewReno::IncreaseWindow (Ptr<TcpSocketState> tcb)
 {
   NS_LOG_FUNCTION (this);
 
@@ -98,7 +96,7 @@ TcpNewReno::IncreaseWindow (Ptr<TcpSocketBase> base, Ptr<TcpSocketState> tcb)
   if (tcb->m_cWnd < tcb->m_ssThresh)
     {
       tcb->m_cWnd += tcb->m_segmentSize;
-      NS_LOG_INFO ("In SlowStart, updated tcb " << tcb << " cwnd to " << tcb->m_cWnd << " ssthresh " << tcb->m_ssThresh);
+      NS_LOG_INFO ("In SlowStart, updated to cwnd " << tcb->m_cWnd << " ssthresh " << tcb->m_ssThresh);
     }
   else
     { // Congestion avoidance mode, increase by (segSize*segSize)/cwnd. (RFC2581, sec.3.1)
@@ -106,7 +104,7 @@ TcpNewReno::IncreaseWindow (Ptr<TcpSocketBase> base, Ptr<TcpSocketState> tcb)
       double adder = static_cast<double> (tcb->m_segmentSize * tcb->m_segmentSize) / tcb->m_cWnd.Get ();
       adder = std::max (1.0, adder);
       tcb->m_cWnd += static_cast<uint32_t> (adder);
-      NS_LOG_INFO ("In CongAvoid, updated tcb " << tcb << " cwnd to " << tcb->m_cWnd << " ssthresh " << tcb->m_ssThresh);
+      NS_LOG_INFO ("In CongAvoid, updated to cwnd " << tcb->m_cWnd << " ssthresh " << tcb->m_ssThresh);
     }
 }
 
diff --git a/src/internet/model/tcp-congestion-ops.h b/src/internet/model/tcp-congestion-ops.h
index b80dc9e..ce50c73 100644
--- a/src/internet/model/tcp-congestion-ops.h
+++ b/src/internet/model/tcp-congestion-ops.h
@@ -25,7 +25,6 @@
 namespace ns3 {
 
 class TcpSocketState;
-class TcpSocketBase;
 
 /**
  * \brief Congestion control abstract class
@@ -65,7 +64,7 @@ public:
    *
    * \param Socket internal state
    */
-  virtual void IncreaseWindow (Ptr<TcpSocketBase> , Ptr<TcpSocketState> tcb) = 0;
+  virtual void IncreaseWindow (Ptr<TcpSocketState> tcb) = 0;
 
   virtual void PktsAcked (Ptr<TcpSocketState> tcb, uint32_t packetsAcked,
                           const Time& rtt) { }
@@ -99,10 +98,10 @@ public:
 
   ~TcpNewReno ();
 
-  virtual std::string GetName () const;
+  std::string GetName () const;
 
-  virtual void IncreaseWindow (Ptr<TcpSocketBase> , Ptr<TcpSocketState> tcb);
-  virtual uint32_t GetSsThresh (Ptr<const TcpSocketState> tcb);
+  void IncreaseWindow (Ptr<TcpSocketState> tcb);
+  uint32_t GetSsThresh (Ptr<const TcpSocketState> tcb);
 
   virtual Ptr<TcpCongestionOps> Fork ();
 };
diff --git a/src/internet/model/tcp-header.cc b/src/internet/model/tcp-header.cc
index 347c9e2..f0d5881 100644
--- a/src/internet/model/tcp-header.cc
+++ b/src/internet/model/tcp-header.cc
@@ -22,7 +22,6 @@
 #include <iostream>
 #include "tcp-header.h"
 #include "tcp-option.h"
-#include "tcp-option-mptcp.h"
 #include "ns3/buffer.h"
 #include "ns3/address-utils.h"
 #include "ns3/log.h"
@@ -70,7 +69,7 @@ TcpHeader::FlagsToString (uint8_t flags, const std::string& delimiter)
     {
       if (flags & (1 << i))
         {
-          if (flagsDescription.length() > 0)
+          if (flagsDescription.length() > 0) 
             {
               flagsDescription += delimiter;
             }
@@ -176,7 +175,7 @@ TcpHeader::GetUrgentPointer () const
   return m_urgentPointer;
 }
 
-void
+void 
 TcpHeader::InitializeChecksum (const Ipv4Address &source,
                                const Ipv4Address &destination,
                                uint8_t protocol)
@@ -186,7 +185,7 @@ TcpHeader::InitializeChecksum (const Ipv4Address &source,
   m_protocol = protocol;
 }
 
-void
+void 
 TcpHeader::InitializeChecksum (const Ipv6Address &source,
                                const Ipv6Address &destination,
                                uint8_t protocol)
@@ -196,7 +195,7 @@ TcpHeader::InitializeChecksum (const Ipv6Address &source,
   m_protocol = protocol;
 }
 
-void
+void 
 TcpHeader::InitializeChecksum (const Address &source,
                                const Address &destination,
                                uint8_t protocol)
@@ -249,20 +248,13 @@ TcpHeader::CalculateHeaderChecksum (uint16_t size) const
   return ~(it.CalculateIpChecksum (hdrSize));
 }
 
-
-void
-TcpHeader::GetOptions (TcpHeader::TcpOptionList& l) const
-{
-  l = m_options;
-}
-
 bool
 TcpHeader::IsChecksumOk (void) const
 {
   return m_goodChecksum;
 }
 
-TypeId
+TypeId 
 TcpHeader::GetTypeId (void)
 {
   static TypeId tid = TypeId ("ns3::TcpHeader")
@@ -273,7 +265,7 @@ TcpHeader::GetTypeId (void)
   return tid;
 }
 
-TypeId
+TypeId 
 TcpHeader::GetInstanceTypeId (void) const
 {
   return GetTypeId ();
@@ -380,18 +372,11 @@ TcpHeader::Deserialize (Buffer::Iterator start)
       uint8_t kind = i.PeekU8 ();
       Ptr<TcpOption> op;
       uint32_t optionSize;
-      if( kind == TcpOption::MPTCP)
-      {
-        i.ReadU16(); // skip TCP kind & length
-        uint8_t subtype = i.ReadU8() >> 4;  // read MPTCP subtype
-        i.Prev(3); // revert the iterator back to where it should be
-        op = TcpOptionMpTcp::CreateMpTcpOption (subtype);
-      }
-      else if (TcpOption::IsKindKnown (kind))
+      if (TcpOption::IsKindKnown (kind))
         {
           op = TcpOption::CreateOption (kind);
         }
-      else
+      else 
         {
           op = TcpOption::CreateOption (TcpOption::UNKNOWN);
           NS_LOG_WARN ("Option kind " << static_cast<int> (kind) << " unknown, skipping.");
@@ -460,7 +445,7 @@ TcpHeader::CalculateHeaderLength () const
 }
 
 bool
-TcpHeader::AppendOption (Ptr<const TcpOption> option)
+TcpHeader::AppendOption (Ptr<TcpOption> option)
 {
   if (m_optionsLen + option->GetSerializedSize () <= m_maxOptionsLen)
     {
@@ -474,9 +459,6 @@ TcpHeader::AppendOption (Ptr<const TcpOption> option)
         {
           m_options.push_back (option);
           m_optionsLen += option->GetSerializedSize ();
-          NS_LOG_DEBUG("Added option [" << option  << "] "
-                       << " of size=" << static_cast<int> (option->GetSerializedSize ())
-                       << ". New m_optionsLen=" << static_cast<int> (m_optionsLen));
 
           uint32_t totalLen = 20 + 3 + m_optionsLen;
           m_length = totalLen >> 2;
@@ -485,25 +467,24 @@ TcpHeader::AppendOption (Ptr<const TcpOption> option)
       return true;
     }
 
-  NS_LOG_WARN ("Not enough space to add option " << option );
   return false;
 }
 
-//Ptr<TcpOption>
-//TcpHeader::GetOption (uint8_t kind) const
-//{
-//  TcpOptionList::const_iterator i;
-//
-//  for (i = m_options.begin (); i != m_options.end (); ++i)
-//    {
-//      if ((*i)->GetKind () == kind)
-//        {
-//          return (*i);
-//        }
-//    }
-//
-//  return 0;
-//}
+Ptr<TcpOption>
+TcpHeader::GetOption (uint8_t kind) const
+{
+  TcpOptionList::const_iterator i;
+
+  for (i = m_options.begin (); i != m_options.end (); ++i)
+    {
+      if ((*i)->GetKind () == kind)
+        {
+          return (*i);
+        }
+    }
+
+  return 0;
+}
 
 bool
 TcpHeader::HasOption (uint8_t kind) const
diff --git a/src/internet/model/tcp-header.h b/src/internet/model/tcp-header.h
index a51c1f2..8ba7906 100644
--- a/src/internet/model/tcp-header.h
+++ b/src/internet/model/tcp-header.h
@@ -168,9 +168,6 @@ public:
 
   /**
    * \brief Get the window size
-   * This should be in bytes but the definite value may need to be corrected in 
-   * case the TCP window scale option is enabled
-   *
    * \return the window size for this TcpHeader
    */
   uint16_t GetWindowSize () const;
@@ -186,16 +183,7 @@ public:
    * \param kind the option to retrieve
    * \return Whether the header contains a specific kind of option, or 0
    */
-//  Ptr<TcpOption> GetOption (uint8_t kind) const;
-
-  typedef std::list< Ptr<const TcpOption> > TcpOptionList; /**< List of TcpOption */
-
-  /**
-   * \brief Copy all options in a list
-   * \note The list should be empty
-   * \param options Return a copy of the options
-   */
-  void GetOptions (TcpHeader::TcpOptionList& options) const;
+  Ptr<TcpOption> GetOption (uint8_t kind) const;
 
   /**
    * \brief Check if the header has the option specified
@@ -209,7 +197,7 @@ public:
    * \param option The option to append
    * \return true if option has been appended, false otherwise
    */
-  bool AppendOption (Ptr<const TcpOption> option);
+  bool AppendOption (Ptr<TcpOption> option);
 
   /**
    * \brief Initialize the TCP checksum.
@@ -306,8 +294,6 @@ public:
    */
   friend bool operator== (const TcpHeader &lhs, const TcpHeader &rhs);
 
-  static const uint8_t m_maxOptionsLen = 40; //!< Maximum options length
-
 private:
   /**
    * \brief Calculate the header checksum
@@ -332,7 +318,7 @@ private:
   SequenceNumber32 m_ackNumber;       //!< ACK number
   uint8_t m_length;             //!< Length (really a uint4_t) in words.
   uint8_t m_flags;              //!< Flags (really a uint6_t)
-  uint16_t m_windowSize;        //!< Window size (SEG.WND)
+  uint16_t m_windowSize;        //!< Window size
   uint16_t m_urgentPointer;     //!< Urgent pointer
 
   Address m_source;       //!< Source IP address
@@ -343,37 +329,12 @@ private:
   bool m_goodChecksum;    //!< Flag to indicate that checksum is correct
 
 
+  typedef std::list< Ptr<TcpOption> > TcpOptionList; //!< List of TcpOption
   TcpOptionList m_options; //!< TcpOption present in the header
   uint8_t m_optionsLen; //!< Tcp options length.
-
+  static const uint8_t m_maxOptionsLen = 40; //!< Maximum options length
 };
 
-/**
- * \brief Helper function to find an MPTCP option
- *
- * \param ret save found option in ret, otherwise
- * \return true if matching option type found. If false, ret should be considered invalid
-*/
-template<class T>
-bool
-GetTcpOption (const TcpHeader& header, Ptr<const T>& ret)
-{
-  TcpHeader::TcpOptionList l;
-  header.GetOptions (l);
-  for (TcpHeader::TcpOptionList::const_iterator it = l.begin (); it != l.end (); ++it)
-    {
-//      std::cout << "comparing " << ((*it)->GetInstanceTypeId ().GetName())
-//                    << " with " << T::GetTypeId().GetName()
-                    ;
-      if ( (*it)->GetInstanceTypeId () == T::GetTypeId())
-        {
-              ret = DynamicCast<const T> ( *it );
-              return (ret != 0);
-        }
-    }
-  return false;
-}
-
 } // namespace ns3
 
 #endif /* TCP_HEADER */
diff --git a/src/internet/model/tcp-l4-protocol.cc b/src/internet/model/tcp-l4-protocol.cc
index 23ca834..af533a9 100644
--- a/src/internet/model/tcp-l4-protocol.cc
+++ b/src/internet/model/tcp-l4-protocol.cc
@@ -41,17 +41,11 @@
 #include "ipv6-routing-protocol.h"
 #include "tcp-socket-factory-impl.h"
 #include "tcp-socket-base.h"
-#include "mptcp-socket-base.h"
-#include "mptcp-subflow.h"
-#include "tcp-option-mptcp.h"
 #include "rtt-estimator.h"
 
 #include <vector>
 #include <sstream>
 #include <iomanip>
-#include <algorithm>
-#include <type_traits>
-#include <memory>
 
 namespace ns3 {
 
@@ -85,27 +79,16 @@ TcpL4Protocol::GetTypeId (void)
                    TypeIdValue (TcpNewReno::GetTypeId ()),
                    MakeTypeIdAccessor (&TcpL4Protocol::m_congestionTypeId),
                    MakeTypeIdChecker ())
-//    .AddAttribute ("EnableMpTcp", "Enable or disable MPTCP support",
-//                   BooleanValue (false),
-//                   MakeBooleanAccessor (&TcpL4Protocol::m_mptcpEnabled),
-//                   MakeBooleanChecker ())
     .AddAttribute ("SocketList", "The list of sockets associated to this protocol.",
                    ObjectVectorValue (),
                    MakeObjectVectorAccessor (&TcpL4Protocol::m_sockets),
-                   MakeObjectVectorChecker<TcpSocket> ())
-    .AddAttribute ("OnNewSocket", "Callback invoked whenever a socket is created.",
-                   CallbackValue (),
-                   MakeCallbackAccessor (&TcpL4Protocol::m_onNewSocket),
-                   MakeCallbackChecker ())
+                   MakeObjectVectorChecker<TcpSocketBase> ())
   ;
   return tid;
 }
 
 TcpL4Protocol::TcpL4Protocol ()
-  :
-    m_mptcpEnabled(false),
-    m_endPoints (new Ipv4EndPointDemux ()),
-    m_endPoints6 (new Ipv6EndPointDemux ())
+  : m_endPoints (new Ipv4EndPointDemux ()), m_endPoints6 (new Ipv6EndPointDemux ())
 {
   NS_LOG_FUNCTION_NOARGS ();
   NS_LOG_LOGIC ("Made a TcpL4Protocol " << this);
@@ -188,92 +171,29 @@ TcpL4Protocol::DoDispose (void)
   IpL4Protocol::DoDispose ();
 }
 
-
 Ptr<Socket>
-TcpL4Protocol::CreateSocket (TypeId congestionTypeId, TypeId socketTypeId)
-{
-    ObjectFactory congestionAlgorithmFactory;
-    congestionAlgorithmFactory.SetTypeId (congestionTypeId);
-    Ptr<TcpCongestionOps> algo = congestionAlgorithmFactory.Create<TcpCongestionOps> ();
-
-    return CreateSocket(algo, socketTypeId);
-}
-
-//// TODO create a ForkSocket Function ?
-//Ptr<Socket>
-//TcpL4Protocol::CreateSocket (TypeId congestionTypeId, TypeId socketTypeId)
-//{
-//}
-
-
-Ptr<Socket>
-TcpL4Protocol::CreateSocket (Ptr<TcpCongestionOps> algo, TypeId socketTypeId)
+TcpL4Protocol::CreateSocket (TypeId congestionTypeId)
 {
   NS_LOG_FUNCTION_NOARGS ();
   ObjectFactory rttFactory;
-  ObjectFactory socketFactory;
+  ObjectFactory congestionAlgorithmFactory;
   rttFactory.SetTypeId (m_rttTypeId);
-  socketFactory.SetTypeId(socketTypeId);
+  congestionAlgorithmFactory.SetTypeId (congestionTypeId);
 
   Ptr<RttEstimator> rtt = rttFactory.Create<RttEstimator> ();
+  Ptr<TcpSocketBase> socket = CreateObject<TcpSocketBase> ();
+  Ptr<TcpCongestionOps> algo = congestionAlgorithmFactory.Create<TcpCongestionOps> ();
 
-  Ptr<TcpSocketBase> socket;
-
-  // TODO allocate the max between children of tcpsocketbase ?
-//  MpTcpSocketBase *addr = new MpTcpSocketBase;
-//addr->~MpTcpSocketBase();
-  NS_LOG_UNCOND(
-                "sizeof(mtcp)=" << sizeof(MpTcpSocketBase)
-                << "sizeof(aligned mtcp)=" << sizeof(std::aligned_storage<sizeof(MpTcpSocketBase)>::type)
-                << " & sizeof(tcp) = "<< sizeof(TcpSocketBase)
-
-                );
-
-  NS_LOG_UNCOND( "socketTypeId=" << socketTypeId );
-  /**
-  This part is a hackish and creates memory leaks. The idea here is that when one creates a TcpSocketBase,
-  there is the possibility that this socket may be replaced by an MpTcp Socket. In order for the application to
-  see the same socket, we reallocate via the "placement new" technique
-  **/
-  if(socketTypeId == TcpSocketBase::GetTypeId())
-  {
-      //  char *addr = new char[ std::max(sizeof(MpTcpSocketBase), sizeof(TcpSocketBase))];
-      char *addr = new char[sizeof(std::aligned_storage<sizeof(MpTcpSocketBase)>::type)];
-
-      // now we should call the destructor ourself
-      TcpSocketBase *temp = new (addr) TcpSocketBase();
-      socket = CompleteConstruct (temp);
-//      socket->Ref();
-//      socket->Ref();
-  }
-  else
-  {
-    socket = socketFactory.Create<TcpSocketBase> ();
-  }
   socket->SetNode (m_node);
   socket->SetTcp (this);
   socket->SetRtt (rtt);
-  socket->InitLocalISN ();
-
-  // TODO solve
-  NS_LOG_DEBUG ("Test"  << algo);
-  NS_LOG_DEBUG ("Setting CC with " << algo->GetName());
-  NS_LOG_DEBUG ("Default CC =" << m_congestionTypeId.GetName());
   socket->SetCongestionControlAlgorithm (algo);
 
-//  m_sockets.push_back (socket);
-  AddSocket (socket);
+  m_sockets.push_back (socket);
   return socket;
 }
 
 Ptr<Socket>
-TcpL4Protocol::CreateSocket (TypeId congestionTypeId)
-{
-    return CreateSocket (congestionTypeId, TcpSocketBase::GetTypeId());
-}
-
-
-Ptr<Socket>
 TcpL4Protocol::CreateSocket (void)
 {
   return CreateSocket (m_congestionTypeId);
@@ -304,24 +224,7 @@ Ipv4EndPoint *
 TcpL4Protocol::Allocate (Ipv4Address address, uint16_t port)
 {
   NS_LOG_FUNCTION (this << address << port);
-//  NS_LOG_UNCOND("Matt should check if address belong to node before ?");
-  // TODO map ipv4 to and NetDevice
-  Ipv4EndPoint * endPoint = m_endPoints->Allocate (address, port);
-//  if(endPoint) {
-//    //!
-//
-//    Ptr<Ipv4> ipv4client = m_node->GetObject<Ipv4>();
-//      for( uint32_t n =0; n < ipv4client->GetNInterfaces(); n++){
-//        for( uint32_t a=0; a < ipv4client->GetNAddresses(n); a++){
-//            NS_LOG_UNCOND( "Client addr " << n <<"/" << a << "=" << ipv4client->GetAddress(n,a));
-//            if(address ==ipv4client->GetAddress(n,a).GetLocal()) {
-//                NS_LOG_UNCOND("EUREKA same ip=" << address);
-////                endPoint->BindToNetDevice(m_node->GetDevice(n));
-//            }
-//        }
-//      }
-//  }
-  return endPoint;
+  return m_endPoints->Allocate (address, port);
 }
 
 Ipv4EndPoint *
@@ -466,27 +369,6 @@ TcpL4Protocol::PacketReceived (Ptr<Packet> packet, TcpHeader &incomingTcpHeader,
   return IpL4Protocol::RX_OK;
 }
 
-
-/**
-TODO return Meta & subflow ?
-**/
-//Ptr<MpTcpSubflow>
-//TcpL4Protocol::UpgradeToMpTcpMetaSocket(Ptr<TcpSocketBase> socket)
-//{
-//
-//
-//  Ptr<MpTcpSubflow> master =  new MpTcpSubflow(*socket);
-//  AddSocket(master);
-////  MpTcpSocketBase* meta = new MpTcpSocketBase(*socket);
-//
-//  MpTcpSocketBase* meta = new (this) MpTcpSocketBase;
-//
-//  meta->AddSubflow(master);
-//
-//  return master;
-//}
-
-
 void
 TcpL4Protocol::NoEndPointsFound (const TcpHeader &incomingHeader,
                                  const Address &incomingSAddr,
@@ -522,52 +404,6 @@ TcpL4Protocol::NoEndPointsFound (const TcpHeader &incomingHeader,
     }
 }
 
-Ptr<TcpSocket>
-TcpL4Protocol::LookupMpTcpToken (uint32_t token)
-{
-
-
-  //! We should find the token
-    NS_LOG_INFO("Looking for token=" << token
-        << " among " << m_sockets.size() << " sockets "
-        );
-
-    /* We go through all the metas to find one with the correct token */
-    for(std::vector<Ptr<TcpSocket> >::iterator it = m_sockets.begin(), last(m_sockets.end());
-      it != last;
-      it++
-     )
-    {
-          Ptr<TcpSocket> sock = *it;
-          Ptr<MpTcpSocketBase> meta = DynamicCast<MpTcpSocketBase>( sock );
-          Address addr;
-          (*it)->GetSockName(addr);
-          NS_LOG_DEBUG("Socket : " << sock
-                << " socket of type=" << sock->GetInstanceTypeId());
-          if(!meta)
-          {
-            NS_LOG_DEBUG("Conversion failed: " << sock << " is not an mptcp socket");
-            continue;
-          }
-
-          NS_LOG_DEBUG("Conversion succeeded: " << sock << " is an mptcp socket. Comparing "
-                        "meta->GetLocalToken()=" << meta->GetLocalToken() << " and token="<<  token);
-          if(meta->GetLocalToken() == token)
-          {
-              NS_LOG_DEBUG("Found match " << &meta);
-              return meta;
-
-    //        NS_LOG_DEBUG("Token " << meta->GetToken() << " differ from MP_JOIN token " << join->GetPeerToken());
-    //        continue;
-          }
-
-
-    }
-
-    return 0;
-}
-
-
 enum IpL4Protocol::RxStatus
 TcpL4Protocol::Receive (Ptr<Packet> packet,
                         Ipv4Header const &incomingIpHeader,
@@ -596,67 +432,6 @@ TcpL4Protocol::Receive (Ptr<Packet> packet,
                                    incomingTcpHeader.GetSourcePort (),
                                    incomingInterface);
 
-
-  /**
-  TODO clean this part, maybe TcpL4protocol should be reworked a bit
-  **/
-  if (endPoints.empty())
-  {
-      NS_LOG_LOGIC ("No Ipv4 endpoints matched on TcpL4Protocol, "
-                    "checking if packet is a MP_JOIN request:" << incomingIpHeader);
-
-    // MPTCP related modification----------------------------
-    // Extract MPTCP options if there is any
-    Ptr<const TcpOptionMpTcpJoin> join;
-    Ptr<MpTcpSocketBase> meta;
-
-    // If it is a SYN packet with an MP_JOIN option
-    if( (incomingTcpHeader.GetFlags() & TcpHeader::SYN)
-        && GetTcpOption(incomingTcpHeader, join)
-        && join->GetMode() == TcpOptionMpTcpJoin::Syn
-       )
-    {
-        NS_LOG_DEBUG("This is indeed a MP_JOIN");
-
-        meta = DynamicCast<MpTcpSocketBase>(LookupMpTcpToken(join->GetPeerToken()));
-        if(meta)
-        {
-
-            NS_LOG_LOGIC ("Found meta " << meta << " matching MP_JOIN token=" << join->GetPeerToken());
-
-            Ipv4EndPoint *endP =  meta->NewSubflowRequest(
-                  packet,
-                  incomingTcpHeader,
-                  InetSocketAddress(incomingIpHeader.GetSource(), incomingTcpHeader.GetSourcePort() ),
-                  InetSocketAddress(incomingIpHeader.GetDestination(), incomingTcpHeader.GetDestinationPort() ) ,
-                  join
-                  );
-
-            NS_LOG_DEBUG("value of endP=" << endP);
-
-            // TODO check that it sends a RST otherwise
-            if(endP)
-            {
-              NS_LOG_DEBUG("subflow endpoint pushed in vector");
-              endPoints.push_back(endP);
-
-              // if we don't break here, then it will infintely loop, each time pushing a new SocketBase with a valid token
-              //return IpL4Protocol::RX_OK;
-            }
-        }
-    }
-
-//        NS_ASSERT_MSG(endPoints.size () == 1, "Demux returned more or less than one endpoint");
-//        (*endPoints.begin())->ForwardUp(packet, ipHeader, tcpHeader.GetSourcePort(), incomingInterface);
-
-  //    }
-  //    else {
-  //      NS_LOG_DEBUG("Ignore MP_JOIN with state " << join->GetState());
-  //    }
-
-
-  }
-
   if (endPoints.empty ())
     {
       if (this->GetObject<Ipv6L3Protocol> () != 0)
@@ -687,7 +462,7 @@ TcpL4Protocol::Receive (Ptr<Packet> packet,
     }
 
   NS_ASSERT_MSG (endPoints.size () == 1, "Demux returned more than one endpoint");
-  NS_LOG_LOGIC ("TcpL4Protocol " << this << " forwarding up to endpoint/socket " << (*endPoints.begin ()));
+  NS_LOG_LOGIC ("TcpL4Protocol " << this << " forwarding up to endpoint/socket");
 
   (*endPoints.begin ())->ForwardUp (packet, incomingIpHeader,
                                     incomingTcpHeader.GetSourcePort (),
@@ -900,71 +675,27 @@ TcpL4Protocol::SendPacket (Ptr<Packet> pkt, const TcpHeader &outgoing,
 }
 
 void
-TcpL4Protocol::DumpSockets () const
+TcpL4Protocol::AddSocket (Ptr<TcpSocketBase> socket)
 {
-    NS_LOG_UNCOND ("== Dumping sockets ==");
-    for(std::vector<Ptr<TcpSocket> >::const_iterator it = m_sockets.cbegin(), last(m_sockets.cend());
-      it != last;
-      it++
-     )
-    {
-        Ptr<TcpSocket> sock = *it;
-        NS_LOG_DEBUG("Socket : " << sock << " socket of type=" << sock->GetInstanceTypeId());
-    }
-    NS_LOG_UNCOND ("== end of dump ==");
-}
-
-
-bool
-TcpL4Protocol::NotifyNewSocket (Ptr<TcpSocket> socket)
-{
-  if(!m_onNewSocket.IsNull())
-  {
-    NS_LOG_DEBUG ("Calling m_onNewSocket");
-    m_onNewSocket (socket);
-  }
-  return true;
-}
-
-/**
-TODO we should check MPTCP token is not registered twice
-**/
-bool
-TcpL4Protocol::AddSocket (Ptr<TcpSocket> socket)
-{
-//  std::vector<Ptr<TcpSocketBase> >::iterator it = m_sockets.begin ();
-
-//  while (it != m_sockets.end ())
-//    {
-//      if (*it == socket)
-//        {
-//          return;
-//        }
-//
-//      ++it;
-//    }
-  NS_LOG_FUNCTION(socket);
-  // TODO remove afterwards
-  DumpSockets();
-
+  std::vector<Ptr<TcpSocketBase> >::iterator it = m_sockets.begin ();
 
+  while (it != m_sockets.end ())
+    {
+      if (*it == socket)
+        {
+          return;
+        }
 
+      ++it;
+    }
 
-  std::vector<Ptr<TcpSocket> >::iterator it = std::find(m_sockets.begin(), m_sockets.end(), socket);
-  if (it == m_sockets.end())
-  {
-    m_sockets.push_back (socket);
-    NotifyNewSocket (socket);
-    return true;
-  }
-  return false;
+  m_sockets.push_back (socket);
 }
 
 bool
-TcpL4Protocol::RemoveSocket (Ptr<TcpSocket> socket)
+TcpL4Protocol::RemoveSocket (Ptr<TcpSocketBase> socket)
 {
-  std::vector<Ptr<TcpSocket> >::iterator it = m_sockets.begin ();
-
+  std::vector<Ptr<TcpSocketBase> >::iterator it = m_sockets.begin ();
 
   while (it != m_sockets.end ())
     {
@@ -978,7 +709,6 @@ TcpL4Protocol::RemoveSocket (Ptr<TcpSocket> socket)
     }
 
   return false;
-//  std::remove(m_sockets.begin(), m_sockets.end(), socket);
 }
 
 void
diff --git a/src/internet/model/tcp-l4-protocol.h b/src/internet/model/tcp-l4-protocol.h
index a70aab9..cf40cca 100644
--- a/src/internet/model/tcp-l4-protocol.h
+++ b/src/internet/model/tcp-l4-protocol.h
@@ -37,17 +37,14 @@ class TcpHeader;
 class Ipv4EndPointDemux;
 class Ipv6EndPointDemux;
 class Ipv4Interface;
-class TcpSocket;
+class TcpSocketBase;
 class Ipv4EndPoint;
 class Ipv6EndPoint;
-//class MpTcpSubflow;
-class TcpSocketBase;
-class TcpCongestionOps;
 
 /**
  * \ingroup tcp
  * \brief Tcp socket creation and multiplexing/demultiplexing
- *
+ * 
  * A single instance of this class is held by one instance of class Node.
  *
  * The creation of TcpSocket are handled in the method CreateSocket, which is
@@ -91,7 +88,6 @@ public:
    * of the TCP protocol
    */
   Ptr<Socket> CreateSocket (void);
-
   /**
    * \brief Create a TCP socket using the specified TypeId
    *
@@ -103,16 +99,6 @@ public:
    * \param socketTypeId the socket TypeId
    */
   Ptr<Socket> CreateSocket (TypeId congestionTypeId);
-  Ptr<Socket> CreateSocket (TypeId congestionTypeId, TypeId socketTypeId);
-  Ptr<Socket> CreateSocket (Ptr<TcpCongestionOps> algo, TypeId socketTypeId);
-
-  /**
-   * \param inplace true if it's a fork, if it should share memory
-   fork it first then do inplace where you want
-   */
-//  Ptr<MpTcpSubflow>
-//  UpgradeToMpTcpMetaSocket(Ptr<TcpSocketBase> socket);
-  void DumpSockets () const;
 
   /**
    * \brief Allocate an IPv4 Endpoint
@@ -184,12 +170,6 @@ public:
                            Ipv6Address peerAddress, uint16_t peerPort);
 
   /**
-   *
-   */
-  Ptr<TcpSocket>
-  LookupMpTcpToken (uint32_t token);
-
-  /**
    * \brief Send a packet via TCP (IP-agnostic)
    *
    * \param pkt The packet to send
@@ -206,12 +186,10 @@ public:
    * \brief Make a socket fully operational
    *
    * Called after a socket has been bound, it is inserted in an internal vector.
-   * It should be called once all parameters are all set since socket
-   * parameters might be traced right after this function being called
    *
    * \param socket Socket to be added
    */
-  bool AddSocket (Ptr<TcpSocket> socket);
+  void AddSocket (Ptr<TcpSocketBase> socket);
 
   /**
    * \brief Remove a socket from the internal list
@@ -219,7 +197,7 @@ public:
    * \param socket socket to Remove
    * \return true if the socket has been removed
    */
-  bool RemoveSocket (Ptr<TcpSocket> socket);
+  bool RemoveSocket (Ptr<TcpSocketBase> socket);
 
   /**
    * \brief Remove an IPv4 Endpoint.
@@ -255,14 +233,6 @@ public:
   virtual IpL4Protocol::DownTargetCallback GetDownTarget (void) const;
   virtual IpL4Protocol::DownTargetCallback6 GetDownTarget6 (void) const;
 
-  
-  /* 
-  HACK matt while waiting for https://www.nsnam.org/bugzilla/show_bug.cgi?id=2336
-  TODO put it as an attribute of TcpL4Protocol
-  */
-  Callback<void, Ptr<TcpSocket> > m_onNewSocket;
-  bool NotifyNewSocket (Ptr<TcpSocket> socket);
-
 protected:
   virtual void DoDispose (void);
 
@@ -309,12 +279,11 @@ protected:
 
 private:
   Ptr<Node> m_node;                //!< the node this stack is associated with
-  bool     m_mptcpEnabled;         //!< MpTcp option enabled
   Ipv4EndPointDemux *m_endPoints;  //!< A list of IPv4 end points.
   Ipv6EndPointDemux *m_endPoints6; //!< A list of IPv6 end points.
   TypeId m_rttTypeId;              //!< The RTT Estimator TypeId
   TypeId m_congestionTypeId;       //!< The socket TypeId
-  std::vector<Ptr<TcpSocket> > m_sockets;      //!< list of sockets
+  std::vector<Ptr<TcpSocketBase> > m_sockets;      //!< list of sockets
   IpL4Protocol::DownTargetCallback m_downTarget;   //!< Callback to send packets over IPv4
   IpL4Protocol::DownTargetCallback6 m_downTarget6; //!< Callback to send packets over IPv6
 
diff --git a/src/internet/model/tcp-option-mptcp.cc b/src/internet/model/tcp-option-mptcp.cc
deleted file mode 100644
index 5babd44..0000000
--- a/src/internet/model/tcp-option-mptcp.cc
+++ /dev/null
@@ -1,1852 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-
-#include "tcp-option-mptcp.h"
-#include "ns3/log.h"
-
-
-static inline
-uint64_t TRUNC_TO_32(uint64_t seq) {
-  return static_cast<uint32_t>(seq);
-}
-
-
-namespace ns3 {
-
-NS_OBJECT_ENSURE_REGISTERED (TcpOptionMpTcpCapable);
-NS_OBJECT_ENSURE_REGISTERED (TcpOptionMpTcpAddAddress );
-NS_OBJECT_ENSURE_REGISTERED (TcpOptionMpTcpRemoveAddress );
-NS_OBJECT_ENSURE_REGISTERED (TcpOptionMpTcpJoin);
-NS_OBJECT_ENSURE_REGISTERED (TcpOptionMpTcpChangePriority );
-NS_OBJECT_ENSURE_REGISTERED (TcpOptionMpTcpDSS);
-NS_OBJECT_ENSURE_REGISTERED (TcpOptionMpTcpFail);
-NS_OBJECT_ENSURE_REGISTERED (TcpOptionMpTcpFastClose);
-NS_OBJECT_ENSURE_REGISTERED (TcpOptionMpTcpDeltaOWD);
-
-
-
-/**
-\note This is a global MPTCP option logger
-*/
-NS_LOG_COMPONENT_DEFINE ("TcpOptionMpTcp");
-
-
-/////////////////////////////////////////////////////////
-////////  Base for MPTCP options
-/////////////////////////////////////////////////////////
-TcpOptionMpTcp::TcpOptionMpTcp (uint8_t subtype)
-  : TcpOption (),
-  m_subtype (subtype)
-
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-TcpOptionMpTcp::~TcpOptionMpTcp ()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-TypeId
-TcpOptionMpTcp::GetInstanceTypeId (void) const
-{
-  return GetTypeId ();
-}
-
-uint8_t
-TcpOptionMpTcp::GetKind (void) const
-{
-  return TcpOption::MPTCP;
-}
-
-TypeId
-TcpOptionMpTcp::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::TcpOptionMpTcp")
-    .SetParent<TcpOption> ()
-  ;
-  return tid;
-}
-
-uint8_t
-TcpOptionMpTcp::GetSubType (void) const {
-  return m_subtype;
-}
-
-
-
-void
-TcpOptionMpTcp::Print (std::ostream &os) const
-{
-  NS_ASSERT_MSG (false, " You should override TcpOptionMpTcp::Print function");
-//    os << "MPTCP option. You should override";
-}
-
-
-
-std::string
-TcpOptionMpTcp::SubTypeToString (const uint8_t& flags, const std::string& delimiter)
-{
-  static const char* flagNames[MP_LAST] = {
-    "CAPABLE",
-    "JOIN",
-    "DSS",
-    "ADD_ADDR",
-    "REM_ADDR",
-    "CHANGE_PRIORITY",
-    "MP_FAIL",
-    "MP_FASTCLOSE",
-    "MP_DELTAOWD",
-    "MP_OWDTS"
-  };
-
-  std::string flagsDescription = "";
-
-  for (int i = 0; i < 8; ++i)
-    {
-      if ( flags & (1 << i) )
-        {
-          if (flagsDescription.length () > 0)
-            {
-              flagsDescription += delimiter;
-            }
-          flagsDescription.append ( flagNames[i] );
-
-        }
-    }
-  return flagsDescription;
-}
-
-
-Ptr<TcpOption>
-TcpOptionMpTcp::CreateMpTcpOption (const uint8_t& subtype)
-{
-  NS_LOG_FUNCTION_NOARGS();
-  switch (subtype)
-    {
-    case MP_CAPABLE:
-      return CreateObject<TcpOptionMpTcpCapable>();
-    case MP_JOIN:
-      return CreateObject<TcpOptionMpTcpJoin>();
-    case MP_DSS:
-      return CreateObject<TcpOptionMpTcpDSS>();
-    case MP_FAIL:
-      return CreateObject<TcpOptionMpTcpFail>();
-    case MP_FASTCLOSE:
-      return CreateObject<TcpOptionMpTcpFastClose>();
-    case MP_PRIO:
-      return CreateObject<TcpOptionMpTcpChangePriority>();
-    case MP_REMOVE_ADDR:
-      return CreateObject<TcpOptionMpTcpRemoveAddress>();
-    case MP_ADD_ADDR:
-      return CreateObject<TcpOptionMpTcpAddAddress>();
-    case MP_DELTAOWD:
-      return CreateObject<TcpOptionMpTcpDeltaOWD>();    
-    case MP_OWDTS:
-      return CreateObject<TcpOptionMpTcpOwdTimeStamp>();
-    default:
-      break;
-    }
-
-  NS_FATAL_ERROR ("Unsupported MPTCP suboption" << subtype);
-  return 0;
-}
-
-void
-TcpOptionMpTcp::SerializeRef (Buffer::Iterator& i, uint8_t lower_bits) const
-{
-  i.WriteU8 (GetKind ());
-  i.WriteU8 (GetSerializedSize ());
-  i.WriteU8 ( (GetSubType () << 4) + (lower_bits & 0x0f));
-}
-
-uint32_t
-TcpOptionMpTcp::DeserializeRef (Buffer::Iterator& i) const
-{
-  uint8_t kind = i.ReadU8 ();
-  uint32_t length = 0;
-
-  NS_ASSERT (kind == GetKind ());
-
-  length = static_cast<uint32_t>(i.ReadU8 ());
-  return length;
-}
-
-
-/////////////////////////////////////////////////////////
-////////  MP_CAPABLE
-/////////////////////////////////////////////////////////
-TcpOptionMpTcpCapable::TcpOptionMpTcpCapable ()
-  : TcpOptionMpTcp (TcpOptionMpTcp::MP_CAPABLE),
-    m_version (0),
-    m_flags ( HMAC_SHA1 ),
-    m_senderKey (0),
-    m_remoteKey (0),
-    m_length (12)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-TcpOptionMpTcpCapable::~TcpOptionMpTcpCapable ()
-{
-  NS_LOG_FUNCTION_NOARGS ();
-}
-
-TypeId
-TcpOptionMpTcpCapable::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::TcpOptionMpTcpCapable")
-    .SetParent<TcpOptionMpTcp> ()
-    .AddConstructor<TcpOptionMpTcpCapable> ()
-  ;
-  return tid;
-}
-
-TypeId
-TcpOptionMpTcpCapable::GetInstanceTypeId (void) const
-{
-  return TcpOptionMpTcpCapable::GetTypeId ();
-}
-
-bool
-TcpOptionMpTcpCapable::operator== (const TcpOptionMpTcpCapable& opt) const
-{
-  return (GetPeerKey () == opt.GetPeerKey () && GetSenderKey () == opt.GetSenderKey () );
-}
-
-
-void
-TcpOptionMpTcpCapable::SetSenderKey (const uint64_t& senderKey)
-{
-  NS_LOG_FUNCTION (this);
-  m_senderKey = senderKey;
-}
-
-void
-TcpOptionMpTcpCapable::SetPeerKey (const uint64_t& remoteKey)
-{
-  NS_LOG_FUNCTION (this);
-  m_length = 20;
-  m_remoteKey = remoteKey;
-}
-
-void
-TcpOptionMpTcpCapable::Print (std::ostream &os) const
-{
-  os << "MP_CAPABLE:"
-     << " flags=" << (int)m_flags << "]"
-     << " flags=" << (int)m_flags << "]"
-     << " Sender's Key :[" << GetSenderKey () << "]";
-  if ( HasReceiverKey () )
-    {
-      os << " Peer's Key [" << GetPeerKey () << "]";
-    }
-
-}
-
-bool
-TcpOptionMpTcpCapable::IsChecksumRequired () const
-{
-  return (m_flags >> 7);
-}
-
-void
-TcpOptionMpTcpCapable::Serialize (Buffer::Iterator i) const
-{
-  TcpOptionMpTcp::SerializeRef (i, (0x0f & GetVersion ()));
-
-//  i.WriteU8 ( (GetSubType () << 4) +  ); // Kind
-  i.WriteU8 ( m_flags ); //
-  i.WriteHtonU64 ( GetSenderKey () );
-  if ( HasReceiverKey () )
-    {
-      i.WriteHtonU64 ( GetPeerKey () );
-    }
-}
-
-
-uint32_t
-TcpOptionMpTcpCapable::Deserialize (Buffer::Iterator i)
-{
-  uint32_t length = TcpOptionMpTcp::DeserializeRef (i);
-
-  NS_ASSERT ( length == 12 || length == 20 );
-
-  uint8_t subtype_and_version = i.ReadU8 ();
-  NS_ASSERT ( subtype_and_version >> 4 == GetSubType () );
-  m_flags = i.ReadU8 ();
-
-  SetSenderKey ( i.ReadNtohU64 () );
-
-  if (length == 20)
-    {
-      SetPeerKey ( i.ReadNtohU64 () );
-    }
-  return length;
-}
-
-
-uint32_t
-TcpOptionMpTcpCapable::GetSerializedSize (void) const
-{
-  return (m_length);
-}
-
-
-uint8_t
-TcpOptionMpTcpCapable::GetVersion (void) const
-{
-  return 0;
-}
-
-
-uint64_t
-TcpOptionMpTcpCapable::GetSenderKey (void) const
-{
-  return m_senderKey;
-}
-
-uint64_t
-TcpOptionMpTcpCapable::GetPeerKey (void) const
-{
-  return m_remoteKey;
-}
-
-
-bool
-TcpOptionMpTcpCapable::HasReceiverKey (void) const
-{
-  return GetSerializedSize () == 20;
-}
-
-
-
-/////////////////////////////////////////////////////////
-////////  MP_JOIN Initial SYN
-/////////////////////////////////////////////////////////
-
-TypeId
-TcpOptionMpTcpJoin::GetTypeId (void)
-{
-    //!
-  static TypeId tid = TypeId ("ns3::TcpOptionMpTcpJoin")
-    .SetParent<TcpOptionMpTcp> ()
-    .AddConstructor<TcpOptionMpTcpJoin> ()
-  ;
-  return tid;
-}
-
-
-TypeId
-TcpOptionMpTcpJoin::GetInstanceTypeId (void) const
-{
-  return TcpOptionMpTcpJoin::GetTypeId ();
-}
-
-TcpOptionMpTcpJoin::TcpOptionMpTcpJoin ()
-  : TcpOptionMpTcp (TcpOptionMpTcp::MP_JOIN),
-    m_mode (Uninitialized),
-    m_addressId (0),
-    m_flags (0)
-{
-  NS_LOG_FUNCTION (this);
-  memset(&m_buffer[0], 0, sizeof(uint32_t) * 5);
-}
-
-
-TcpOptionMpTcpJoin::~TcpOptionMpTcpJoin ()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-void
-TcpOptionMpTcpJoin::SetPeerToken (const uint32_t& token)
-{
-  NS_ASSERT ( m_mode & Syn);
-  m_buffer[0] = token;
-}
-
-
-void
-TcpOptionMpTcpJoin::Print (std::ostream &os) const
-{
-  os << "MP_JOIN: ";
-  switch (m_mode)
-    {
-    case Uninitialized:
-      os << "Uninitialized";
-      return;
-    case Syn:
-      os << "[Syn] with token=" << GetPeerToken () << ", nonce=" << GetNonce ();
-      return;
-    case SynAck:
-      os << "[SynAck] with nonce=" << GetNonce ();
-      return;
-    case Ack:
-      os << "[Ack] with hash";
-      return;
-    }
-}
-
-
-void
-TcpOptionMpTcpJoin::SetAddressId (const uint8_t& addrId)
-{
-  NS_ASSERT (m_mode & (SynAck | Ack) );
-  m_addressId =  addrId;
-}
-
-
-uint32_t
-TcpOptionMpTcpJoin::GetPeerToken () const
-{
-  NS_ASSERT (m_mode & Syn );
-  return m_buffer[0];
-}
-
-
-void
-TcpOptionMpTcpJoin::SetMode (Mode s)
-{
-  NS_ASSERT_MSG (m_mode == Uninitialized, "Can't change state once initialized.");
-  m_mode = s;
-}
-
-
-uint8_t
-TcpOptionMpTcpJoin::GetAddressId () const
-{
-  NS_ASSERT_MSG (m_mode & (SynAck | Ack), "AddressId only available in states SynAck and Ack");
-  return m_addressId;
-}
-
-
-bool
-TcpOptionMpTcpJoin::operator== (const TcpOptionMpTcpJoin& opt) const
-{
-
-  if ( m_mode != opt.m_mode)
-    {
-      return false;
-    }
-
-  /* depending on mode, operator does not check same fields */
-  switch (m_mode)
-    {
-    case Uninitialized:
-      return true;
-
-    case Syn:
-      return (
-               GetPeerToken () == opt.GetPeerToken ()
-               && GetNonce () == opt.GetNonce ()
-               && GetAddressId () == opt.GetAddressId ()
-               );
-
-    case SynAck:
-      return (
-               GetNonce () == opt.GetNonce ()
-               && GetAddressId ()  == opt.GetAddressId ()
-               );
-
-    case Ack:
-      return true;
-    }
-
-  NS_FATAL_ERROR ( "This should never trigger. Contact ns3 team");
-  return false;
-}
-
-
-TcpOptionMpTcpJoin::Mode
-TcpOptionMpTcpJoin::GetMode (void) const
-{
-  return m_mode;
-}
-
-
-uint32_t
-TcpOptionMpTcpJoin::GetNonce () const
-{
-  NS_ASSERT_MSG (m_mode & (Syn | SynAck), "Nonce only available in Syn and SynAck modes");
-  return m_buffer[0];
-}
-
-
-void
-TcpOptionMpTcpJoin::SetNonce (const uint32_t& nonce)
-{
-
-  if (m_mode == Syn)
-    {
-      m_buffer[1] = nonce;
-    }
-  else if (m_mode == SynAck)
-    {
-      m_buffer[2] = nonce;
-    }
-  else
-    {
-      NS_FATAL_ERROR ("Unavailable command in this mode");
-    }
-}
-
-
-void
-TcpOptionMpTcpJoin::Serialize (Buffer::Iterator i) const
-{
-  TcpOptionMpTcp::SerializeRef (i, 0);
-//  i.WriteU8 ( GetSubType () << 4 );
-  if (m_mode & (Syn | SynAck))
-    {
-      i.WriteU8 (GetAddressId ());
-    }
-  else
-    {
-      i.WriteU8 ( 0 );
-    }
-
-  switch ( m_mode )
-    {
-    case Uninitialized:
-      NS_FATAL_ERROR ("Uninitialized option");
-
-    case Syn:
-      i.WriteHtonU32 ( GetPeerToken () );
-      i.WriteHtonU32 ( GetNonce () );
-      break;
-
-    case SynAck:
-      {
-        uint64_t hmac = GetTruncatedHmac ();
-        i.WriteHtonU64 (hmac);
-      }
-      i.WriteHtonU32 ( GetNonce () );
-      break;
-
-    case Ack:
-      // +=4 cos' amount of bytes we write
-      for (int j = 0; j < m_mode / 4 - 1; j++)
-        {
-          i.WriteHtonU32 ( m_buffer[j]);
-        }
-      break;
-    default:
-      NS_FATAL_ERROR("Unhandled case");
-    }
-}
-
-const uint8_t*
-TcpOptionMpTcpJoin::GetHmac () const
-{
-  NS_ASSERT_MSG (m_mode == Ack, "Only available in Ack mode");
-//  i.Read( &m_hmac[0], 20);
-//  m_buffer.Read();
-//  return &m_hmac[0];
-  return 0;
-}
-
-
-uint32_t
-TcpOptionMpTcpJoin::Deserialize (Buffer::Iterator i)
-{
-  NS_ASSERT (m_mode == Uninitialized);
-
-  uint32_t length = TcpOptionMpTcp::DeserializeRef (i);
-
-
-  uint8_t subtype_and_flags = i.ReadU8 ();
-  NS_ASSERT ( (subtype_and_flags >> 4) == GetSubType () );
-
-  m_mode = static_cast<Mode> ( length );
-
-  m_addressId = i.ReadU8 ();
-
-  switch ( m_mode )
-    {
-    case Uninitialized:
-      NS_FATAL_ERROR ("Unitialized option, this case should not happen." );
-
-    case Syn:
-      SetPeerToken ( i.ReadNtohU32 () );
-      SetNonce ( i.ReadNtohU32 () );
-      break;
-
-    case SynAck:
-      SetTruncatedHmac ( i.ReadNtohU64 () );
-      SetNonce ( i.ReadNtohU32 () );  // read nonce
-      break;
-
-    case Ack:
-      i.Read ( (uint8_t*)&m_buffer, 20);
-      break;
-    }
-
-  return m_mode;
-}
-
-
-void
-TcpOptionMpTcpJoin::SetHmac (uint8_t hmac[20])
-{
-  NS_LOG_ERROR ("Not implemented");
-//  std::copy(hmac, hmac+20,m_hmac);
-}
-
-
-uint32_t
-TcpOptionMpTcpJoin::GetSerializedSize (void) const
-{
-  NS_ASSERT (m_mode != Uninitialized);
-
-  return (m_mode);
-}
-
-void
-TcpOptionMpTcpJoin::SetTruncatedHmac (const uint64_t& hmac)
-{
-  NS_ASSERT_MSG (m_mode == SynAck, "Wrong mode");
-  m_buffer[0] = hmac >> 32;
-  m_buffer[1] = (hmac);
-}
-
-uint64_t
-TcpOptionMpTcpJoin::GetTruncatedHmac () const
-{
-  NS_ASSERT_MSG (m_mode == SynAck, "Wrong mode");
-  uint64_t temp = 0;
-  temp = m_buffer[0];
-  temp = temp << 32;
-  temp |= m_buffer[1];
-
-  return temp;
-}
-
-
-
-
-
-
-///////////////////////////////////////:
-//// MP_DSS
-////
-TcpOptionMpTcpDSS::TcpOptionMpTcpDSS ()
-  : TcpOptionMpTcp (TcpOptionMpTcp::MP_DSS),
-    m_hasChecksum (false),
-    m_checksum (0),
-    m_flags (0),
-    m_dataAck (0),
-    m_dsn (0),
-    m_ssn (0),
-    m_mappingLength (0)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-TcpOptionMpTcpDSS::~TcpOptionMpTcpDSS ()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-TypeId
-TcpOptionMpTcpDSS::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::TcpOptionMpTcpDSS")
-    .SetParent<TcpOptionMpTcp> ()
-    .AddConstructor<TcpOptionMpTcpDSS> ()
-  ;
-  return tid;
-}
-
-
-TypeId
-TcpOptionMpTcpDSS::GetInstanceTypeId (void) const
-{
-  return TcpOptionMpTcpDSS::GetTypeId ();
-}
-
-
-void
-TcpOptionMpTcpDSS::TruncateDSS (bool truncate)
-{
-    NS_ASSERT_MSG(m_flags & DSNMappingPresent, "Call it only after setting the mapping");
-
-    if(truncate) 
-    {
-        m_flags &=  ~(0xff & DSNOfEightBytes);
-    }
-    else {
-        m_flags |= DSNOfEightBytes;
-    }
-}
-
-
-//void
-//TcpOptionMpTcpDSS::AddDataFin (
-////        const uint64_t& dfin, const bool& send_as_32bits
-//        )
-//{
-//  NS_ASSERT_MSG ( (GetFlags () & DataFin ) == 0, "You already set a DATA FIN");
-//  NS_LOG_LOGIC ("Setting datafin to " << dfin);
-//
-//  //! If already a mapping registered
-//  if ( m_flags & DSNMappingPresent)
-//    {
-//      // check we can increment length without wrapping
-//      uint16_t temp = 0;
-//      temp = ~temp;
-////      NS_LOG_DEBUG ("TEMP => " << temp); //~(uint16_t) 0
-//      NS_ASSERT_MSG ( (m_dataLevelLength < temp ), "Datafin increments DSS length by 1");
-//      NS_ASSERT_MSG ( m_dsn + m_dataLevelLength + 1 == dfin, "DFIN dsn does not match already registered mapping data");
-//    }
-//  else
-//    {
-//      m_dsn = dfin;
-//    }
-//
-//  m_dataLevelLength++;
-//  m_flags |=  DataFin | DSNMappingPresent;
-//}
-
-
-void
-TcpOptionMpTcpDSS::SetMapping (uint64_t headDsn, uint32_t headSsn, uint16_t length, bool enable_dfin)
-{
-//  NS_ASSERT_MSG ( !(m_flags & DataFin), "For now you can't set mapping after enabling datafin");
-//  NS_ASSERT_MSG ( !(m_flags & DSNMappingPresent), "You already set a mapping");
-
-  m_dsn = headDsn;
-  m_ssn = headSsn;
-  // += in case there is a datafin
-  m_mappingLength = length;
-  m_flags |= DSNMappingPresent;
-
-  if (enable_dfin)
-  {
-    m_flags |= DataFin;
-
-    NS_ASSERT_MSG ( length > 0 || (headSsn == 0), 
-      "When there is no segment with the datafin, SSN must be set to 0");
-  }
-}
-
-
-void
-TcpOptionMpTcpDSS::GetMapping (uint64_t& dsn, uint32_t& ssn, uint16_t& length) const
-{
-  NS_ASSERT ( (m_flags & DSNMappingPresent) && !IsInfiniteMapping () );
-  ssn = m_ssn;
-  dsn = m_dsn;
-  length = m_mappingLength;
-//  if (GetFlags () & DataFin)
-//    {
-//      length--;
-//    }
-}
-
-uint32_t
-TcpOptionMpTcpDSS::GetSerializedSize (void) const
-{
-  uint32_t len = GetSizeFromFlags (m_flags) + ((m_hasChecksum) ? 2 : 0);
-  return len;
-}
-
-uint64_t
-TcpOptionMpTcpDSS::GetDataAck (void) const
-{
-  NS_ASSERT_MSG ( m_flags & DataAckPresent, "Can't request DataAck value when DataAck flag was not set. Check for its presence first" );
-  return m_dataAck;
-}
-
-
-void
-TcpOptionMpTcpDSS::SetChecksum (const uint16_t& checksum)
-{
-  m_hasChecksum = checksum;
-}
-
-
-uint16_t
-TcpOptionMpTcpDSS::GetChecksum (void) const
-{
-  NS_ASSERT (m_hasChecksum);
-  return m_checksum;
-}
-
-void
-TcpOptionMpTcpDSS::Print (std::ostream& os) const
-{
-
-  os << " MP_DSS: ";
-  if (GetFlags () & DataAckPresent)
-    {
-      os << "Acknowledges [" << GetDataAck () << "] ";
-      if (GetFlags () & DataAckOf8Bytes)
-        {
-          os << "(8bytes DACK)";
-        }
-    }
-
-  if (GetFlags () & DSNMappingPresent)
-    {
-
-      if (IsInfiniteMapping ())
-        {
-          os << " Infinite Mapping";
-        }
-      else if (GetFlags () & DataFin)
-        {
-          os << "Has datafin for seq [" << GetDataFinDSN () << "]";
-        }
-
-      os << " DSN:" << m_dsn << " length=" << GetDataLevelLength() << " ssn=" << m_ssn;
-      if (GetFlags () & DSNOfEightBytes)
-        {
-          os << "(8bytes mapping)";
-        }
-    }
-}
-
-
-void
-TcpOptionMpTcpDSS::Serialize (Buffer::Iterator i) const
-{
-  TcpOptionMpTcp::SerializeRef (i, 0);
-//  i.WriteU8 ( GetSubType () << 4);
-  i.WriteU8 ( m_flags );
-
-  if ( m_flags & DataAckPresent)
-    {
-      if ( m_flags & DataAckOf8Bytes)
-        {
-          i.WriteHtonU64 ( m_dataAck );
-        }
-      else
-        {
-          i.WriteHtonU32 ( static_cast<uint32_t>(m_dataAck) );
-        }
-    }
-
-  if (m_flags & DSNMappingPresent)
-    {
-
-      if ( m_flags & DSNOfEightBytes)
-        {
-          i.WriteHtonU64 ( m_dsn );
-        }
-      else
-        {
-          i.WriteHtonU32 ( m_dsn );
-        }
-
-      // Write relative SSN
-
-      i.WriteHtonU32 ( m_ssn );
-      i.WriteHtonU16 ( GetDataLevelLength() );
-    }
-
-  if (m_hasChecksum)
-    {
-      i.WriteHtonU16 ( m_checksum );
-    }
-}
-
-uint16_t
-TcpOptionMpTcpDSS::GetDataLevelLength () const
-{
-  uint16_t dataLevelLength = m_mappingLength;
-  if (m_flags & DataFin) 
-  {
-    NS_ASSERT_MSG (dataLevelLength < 0xff, "Can't set datafin else will wrap");
-    dataLevelLength += 1;
-  }
-  return dataLevelLength;
-}
-
-uint32_t
-TcpOptionMpTcpDSS::GetSizeFromFlags (uint16_t flags)
-{
-
-  uint32_t length = 4;
-
-  if ( flags & DataAckPresent)
-    {
-      length += 4;
-      if ( flags & DataAckOf8Bytes)
-        {
-          length += 4;
-        }
-    }
-
-
-  if ( flags & DSNMappingPresent)
-    {
-      length += 10; /* data length (2) + ssn (4) + DSN min size (4) */
-      if ( flags & DSNOfEightBytes)
-        {
-          length += 4;
-        }
-    }
-
-  return length;
-}
-
-uint32_t
-TcpOptionMpTcpDSS::Deserialize (Buffer::Iterator i)
-{
-
-  uint32_t length =  TcpOptionMpTcp::DeserializeRef (i);
-
-  uint8_t subtype_and_reserved = i.ReadU8 ();
-
-  NS_ASSERT ( (subtype_and_reserved >> 4) == GetSubType ()  );
-  m_flags = i.ReadU8 ();
-
-  uint32_t shouldBeLength = GetSizeFromFlags (m_flags);
-
-  NS_ASSERT (shouldBeLength == length || shouldBeLength + 2 == length);
-
-  if (shouldBeLength + 2 == length)
-    {
-      m_hasChecksum = true;
-    }
-
-  if ( m_flags & DataAckPresent)
-    {
-      if ( m_flags & DataAckOf8Bytes)
-        {
-          m_dataAck = i.ReadNtohU64 ();
-        }
-      else
-        {
-          m_dataAck = i.ReadNtohU32 ();
-        }
-    }
-
-  // Read mapping
-  if (m_flags & DSNMappingPresent)
-    {
-
-      if ( m_flags & DSNOfEightBytes)
-        {
-          m_dsn = i.ReadNtohU64 ();
-        }
-      else
-        {
-          m_dsn = i.ReadNtohU32 ();
-        }
-
-      m_ssn = i.ReadNtohU32 ();
-      uint16_t dataLevelLength = i.ReadNtohU16 ();
-
-      m_mappingLength = dataLevelLength;
-      // TODO
-      if(m_flags & DataFin)
-      {
-        NS_ASSERT_MSG (dataLevelLength != 0, "Should not be possible");
-        m_mappingLength = dataLevelLength - 1;
-      }
-    }
-
-
-  if (m_hasChecksum)
-    {
-      m_checksum = i.ReadNtohU16 ( );
-    }
-
-  return length;
-}
-
-uint8_t
-TcpOptionMpTcpDSS::GetFlags (void) const
-{
-  return m_flags;
-}
-
-/*
-Note that when the DATA_FIN is not attached to a TCP segment
-containing data, the Data Sequence Signal MUST have a subflow
-sequence number of 0, a Data-Level Length of 1, and the data sequence
-number that corresponds with the DATA_FIN itself
-*/
-bool
-TcpOptionMpTcpDSS::DataFinMappingOnly () const
-{
-  return (m_flags & DataFin) && (m_mappingLength == 0) && (m_ssn == 0);
-}
-
-bool
-TcpOptionMpTcpDSS::IsInfiniteMapping () const
-{
-  //  The checksum, in such a case, will also be set to zero
-  return (GetFlags () & DSNMappingPresent) && (GetDataLevelLength() == 0);
-}
-
-uint64_t
-TcpOptionMpTcpDSS::GetDataFinDSN () const
-{
-  NS_ASSERT ( GetFlags () & DataFin);
-
-  if (DataFinMappingOnly ())
-    {
-      return m_dsn;
-    }
-  else
-    {
-      return m_dsn + m_mappingLength;
-    }
-}
-
-
-
-void
-TcpOptionMpTcpDSS::SetDataAck (const uint64_t& dack, const bool& send_as_32bits)
-{
-  NS_LOG_LOGIC (this << dack);
-
-  m_dataAck = dack;
-  m_flags |= DataAckPresent;
-
-  if (send_as_32bits)
-    {
-      m_dataAck = TRUNC_TO_32 (m_dataAck);
-    }
-  else
-    {
-      m_flags |= DataAckOf8Bytes;
-    }
-
-}
-
-bool
-TcpOptionMpTcpDSS::operator== (const TcpOptionMpTcpDSS& opt) const
-{
-
-  bool ret = m_flags == opt.m_flags;
-  ret &= opt.m_checksum == m_checksum;
-  ret &= opt.m_dsn == m_dsn;
-  ret &= opt.m_ssn == m_ssn;
-  ret &= opt.m_dataAck == m_dataAck;
-  ret &= opt.m_mappingLength == m_mappingLength;
-  return ( ret );
-}
-
-
-///////////////////////////////////////:
-//// ADD_ADDR
-////
-TcpOptionMpTcpAddAddress::TcpOptionMpTcpAddAddress ()
-  : TcpOptionMpTcp (TcpOptionMpTcp::MP_ADD_ADDR),
-    m_addressVersion (0),
-    m_addrId (0)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-TcpOptionMpTcpAddAddress::~TcpOptionMpTcpAddAddress ()
-{
-  NS_LOG_FUNCTION (this);
-
-}
-
-TypeId
-TcpOptionMpTcpAddAddress::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::TcpOptionMpTcpAddAddress")
-    .SetParent<TcpOptionMpTcp> ()
-    .AddConstructor<TcpOptionMpTcpAddAddress> ()
-  ;
-  return tid;
-}
-
-
-TypeId
-TcpOptionMpTcpAddAddress::GetInstanceTypeId (void) const
-{
-  return TcpOptionMpTcpAddAddress::GetTypeId ();
-}
-
-void
-TcpOptionMpTcpAddAddress::SetAddress (const Address& _address, uint8_t addrId
-//, bool advertise_port
-                                      )
-{
-  if (InetSocketAddress::IsMatchingType (_address) )
-    {
-      m_addressVersion = 4;
-      InetSocketAddress address =  InetSocketAddress::ConvertFrom (_address);
-      m_address = address.GetIpv4 ();
-      m_port = address.GetPort ();
-    }
-  else
-    {
-      NS_ASSERT_MSG (Inet6SocketAddress::IsMatchingType (_address), "Address of unsupported type");
-      m_addressVersion = 6;
-      Inet6SocketAddress address6 =  Inet6SocketAddress::ConvertFrom (_address);
-      m_address6 = address6.GetIpv6 ();
-      m_port = address6.GetPort ();
-    }
-
-  m_addrId  = addrId;
-}
-
-
-void
-TcpOptionMpTcpAddAddress::Print (std::ostream &os) const
-{
-  os << "ADD_ADDR: address id=" << GetAddressId ()
-     << " associated to IP [";
-  if (m_addressVersion == 4)
-    {
-      os << m_address;
-    }
-  else
-    {
-      os << m_address6;
-    }
-  os << "]";
-}
-
-InetSocketAddress
-TcpOptionMpTcpAddAddress::GetAddress () const
-{
-  NS_ASSERT (m_addressVersion == 4);
-  return InetSocketAddress (m_address, m_port);
-}
-
-
-Inet6SocketAddress
-TcpOptionMpTcpAddAddress::GetAddress6 () const
-{
-  NS_ASSERT (m_addressVersion == 6);
-  return Inet6SocketAddress (m_address6,m_port);
-}
-
-
-
-uint8_t
-TcpOptionMpTcpAddAddress::GetAddressId () const
-{
-  return m_addrId;
-}
-
-void
-TcpOptionMpTcpAddAddress::Serialize (Buffer::Iterator i) const
-{
-  TcpOptionMpTcp::SerializeRef (i, m_addressVersion);
-
-  NS_ASSERT_MSG (m_addressVersion == 4 || m_addressVersion == 6, "Set an IP before serializing");
-
-//  i.WriteU8 ( (GetSubType () << 4) + (uint8_t) m_addressVersion );
-  i.WriteU8 ( GetAddressId () );
-
-
-  if (m_addressVersion == 4)
-    {
-      i.WriteHtonU32 ( m_address.Get () );
-    }
-  else
-    {
-      NS_ASSERT_MSG (m_addressVersion == 6, "You should set an IP address before serializing MPTCP option ADD_ADDR");
-
-      uint8_t     buf[16];
-      m_address6.GetBytes ( buf );
-      for (int j = 0; j < 16; ++j)
-        {
-          i.WriteU8 ( buf[j] );
-        }
-    }
-
-  i.WriteU8 (m_port);
-}
-
-
-
-uint32_t
-TcpOptionMpTcpAddAddress::Deserialize (Buffer::Iterator i)
-{
-  uint32_t length =  TcpOptionMpTcp::DeserializeRef (i);
-  NS_ASSERT ( length > 3);
-
-  // TODO here we should be able to deserialize more than one
-  uint8_t subtype_and_ipversion = i.ReadU8 ();
-  NS_ASSERT ( subtype_and_ipversion >> 4 == GetSubType ()  );
-
-  m_addressVersion = subtype_and_ipversion  & 0x0f;
-  NS_ASSERT_MSG (m_addressVersion == 4 || m_addressVersion == 6, "Unsupported address version");
-
-  m_addrId =  i.ReadU8 ();
-
-  if ( m_addressVersion == 4)
-    {
-      m_address.Set ( i.ReadNtohU32 () );
-    }
-  else
-    {
-      NS_FATAL_ERROR ("IPv6 not supported yet");
-    }
-  return length;
-}
-
-uint8_t
-TcpOptionMpTcpAddAddress::GetAddressVersion (void) const
-{
-  return m_addressVersion;
-}
-
-uint32_t
-TcpOptionMpTcpAddAddress::GetSerializedSize (void) const
-{
-  if ( GetAddressVersion () == 4)
-    {
-      return 10;
-    }
-
-  NS_ASSERT_MSG ( GetAddressVersion ()  == 6,"Wrong IP version. Maybe you didn't set an address to the MPTCP ADD_ADDR option ?");
-  return 22;
-}
-
-
-bool
-TcpOptionMpTcpAddAddress::operator== (const TcpOptionMpTcpAddAddress& opt) const
-{
-  return (GetAddressId () == opt.GetAddressId ()
-          && m_address == opt.m_address
-          && m_address6 == opt.m_address6
-          );
-}
-
-
-///////////////////////////////////////:
-//// DEL_ADDR Remove address
-////
-
-TcpOptionMpTcpRemoveAddress::TcpOptionMpTcpRemoveAddress ()
-  : TcpOptionMpTcp (TcpOptionMpTcp::MP_REMOVE_ADDR)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-TcpOptionMpTcpRemoveAddress::~TcpOptionMpTcpRemoveAddress ()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-TypeId
-TcpOptionMpTcpRemoveAddress::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::TcpOptionMpTcpRemoveAddress")
-    .SetParent<TcpOptionMpTcp> ()
-    .AddConstructor<TcpOptionMpTcpRemoveAddress> ()
-  ;
-  return tid;
-}
-
-TypeId
-TcpOptionMpTcpRemoveAddress::GetInstanceTypeId (void) const
-{
-  return TcpOptionMpTcpRemoveAddress::GetTypeId ();
-}
-
-void
-TcpOptionMpTcpRemoveAddress::GetAddresses (std::vector<uint8_t>& addresses)
-{
-  addresses = m_addressesId;
-}
-
-
-void
-TcpOptionMpTcpRemoveAddress::AddAddressId ( uint8_t addrId )
-{
-  NS_ASSERT_MSG (m_addressesId.size () < 5, "5 is a random limit but it \
-            should be weird that you remove more than 5 addresses at once. \
-                  Maybe increase it");
-
-  m_addressesId.push_back ( addrId );
-}
-
-
-void
-TcpOptionMpTcpRemoveAddress::Serialize (Buffer::Iterator i) const
-{
-  TcpOptionMpTcp::SerializeRef (i, 0);
-
-//  i.WriteU8 ( (GetSubType () << 4) );
-  for (
-    std::vector<uint8_t>::const_iterator it = m_addressesId.begin ();
-    it != m_addressesId.end ();
-    it++
-    )
-    {
-      i.WriteU8 ( *it );
-    }
-}
-
-uint32_t
-TcpOptionMpTcpRemoveAddress::Deserialize (Buffer::Iterator i)
-{
-  uint32_t length =  TcpOptionMpTcp::DeserializeRef (i);
-
-  NS_ASSERT_MSG ( length > 3, "You probably forgot to add AddrId to the MPTCP Remove option");
-
-  uint8_t subtype_and_resvd = i.ReadU8 ();
-  NS_ASSERT ( subtype_and_resvd >> 4 == GetSubType ()  );
-
-  m_addressesId.clear ();
-  for (uint32_t j = 3; j < length; ++j)
-    {
-      m_addressesId.push_back ( i.ReadU8 () );
-    }
-
-  return length;
-
-}
-
-uint32_t
-TcpOptionMpTcpRemoveAddress::GetSerializedSize (void) const
-{
-  return ( 3 + m_addressesId.size () );
-}
-
-void
-TcpOptionMpTcpRemoveAddress::Print (std::ostream &os) const
-{
-  os << "REMOVE_ADDR. Removing addresses:";
-  for (
-    std::vector<uint8_t>::const_iterator it = m_addressesId.begin ();
-    it != m_addressesId.end ();
-    it++
-    )
-    {
-      os << *it << "/";
-    }
-}
-
-bool
-TcpOptionMpTcpRemoveAddress::operator== (const TcpOptionMpTcpRemoveAddress& opt) const
-{
-  return (m_addressesId == opt.m_addressesId);
-
-}
-
-
-
-///////////////////////////////////////:
-//// MP_PRIO change priority
-////
-TcpOptionMpTcpChangePriority::TcpOptionMpTcpChangePriority ()
-  : TcpOptionMpTcp (TcpOptionMpTcp::MP_PRIO),
-    m_length (3),
-    m_addrId (0),
-    m_flags (false)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-TcpOptionMpTcpChangePriority::~TcpOptionMpTcpChangePriority (void)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-
-TypeId
-TcpOptionMpTcpChangePriority::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::TcpOptionMpTcpChangePriority")
-    .SetParent<TcpOptionMpTcp> ()
-    .AddConstructor<TcpOptionMpTcpChangePriority> ()
-  ;
-  return tid;
-}
-
-
-TypeId
-TcpOptionMpTcpChangePriority::GetInstanceTypeId (void) const
-{
-  return TcpOptionMpTcpChangePriority::GetTypeId ();
-}
-
-void
-TcpOptionMpTcpChangePriority::Print (std::ostream &os) const
-{
-  os << "MP_Prio: address with id [";
-
-  if ( EmbeddedAddressId () )
-    {
-      os << m_addrId;
-    }
-  else
-    {
-      os << "Not set";
-    }
-  os << "] to flags ["  << static_cast<int>(GetFlags ()) << "]";
-}
-
-void
-TcpOptionMpTcpChangePriority::SetAddressId (const uint8_t& addrId)
-{
-  NS_ASSERT_MSG (addrId != BAD_ADDRID, "ns3 prevents the use of this id for internal reasons");
-  m_addrId = addrId;
-  m_length = 4;
-}
-
-
-uint8_t
-TcpOptionMpTcpChangePriority::GetAddressId () const
-{
-  NS_ASSERT_MSG (EmbeddedAddressId (), "Use EmbeddedAddressId to check beforehand if this option carries an id");
-  return m_addrId;
-}
-
-
-void
-TcpOptionMpTcpChangePriority::Serialize (Buffer::Iterator i) const
-{
-  TcpOptionMpTcp::SerializeRef (i, m_flags);
-
-//  i.WriteU8 ( (GetSubType () << 4) + (uint8_t)m_flags );
-  if ( EmbeddedAddressId () )
-    {
-      i.WriteU8 ( m_addrId );
-    }
-}
-
-
-uint32_t
-TcpOptionMpTcpChangePriority::Deserialize (Buffer::Iterator i)
-{
-
-  uint32_t length =  TcpOptionMpTcp::DeserializeRef (i);
-
-  NS_ASSERT ( length == 3 || length == 4 );
-
-  uint8_t subtype_and_flags = i.ReadU8 ();
-  NS_ASSERT ( subtype_and_flags >> 4 == GetSubType ()  );
-  SetFlags (subtype_and_flags);
-
-  if (length == 4)
-    {
-      SetAddressId (i.ReadU8 ());
-    }
-
-  return m_length;
-}
-
-uint32_t
-TcpOptionMpTcpChangePriority::GetSerializedSize (void) const
-{
-  return m_length;
-}
-
-void
-TcpOptionMpTcpChangePriority::SetFlags (const uint8_t& flags)
-{
-  NS_LOG_FUNCTION (flags);
-
-  /* only save the LSB bits */
-  m_flags = 0x0f & flags;
-}
-
-
-uint8_t
-TcpOptionMpTcpChangePriority::GetFlags (void) const
-{
-  return m_flags & 0x0f;
-}
-
-bool
-TcpOptionMpTcpChangePriority::EmbeddedAddressId () const
-{
-  return (GetSerializedSize () == 4);
-}
-
-bool
-TcpOptionMpTcpChangePriority::operator== (const TcpOptionMpTcpChangePriority& opt) const
-{
-
-  return (
-           GetFlags () == opt.GetFlags ()
-           && m_addrId == opt.m_addrId
-           );
-}
-
-
-
-
-///////////////////////////////////////////////////
-//// MP_FASTCLOSE to totally stop a flow of data
-////
-TcpOptionMpTcpFastClose::TcpOptionMpTcpFastClose ()
-  : TcpOptionMpTcp (TcpOptionMpTcp::MP_FASTCLOSE),
-    m_peerKey (0)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-TcpOptionMpTcpFastClose::~TcpOptionMpTcpFastClose (void)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-void
-TcpOptionMpTcpFastClose::SetPeerKey (const uint64_t& remoteKey)
-{
-  m_peerKey = remoteKey;
-}
-
-uint64_t
-TcpOptionMpTcpFastClose::GetPeerKey (void) const
-{
-  return m_peerKey;
-}
-
-void
-TcpOptionMpTcpFastClose::Print (std::ostream &os) const
-{
-  os << "MP_FastClose: Receiver key set to ["
-     << GetPeerKey () << "]";
-}
-
-bool
-TcpOptionMpTcpFastClose::operator== (const TcpOptionMpTcpFastClose& opt) const
-{
-
-  return ( GetPeerKey () == opt.GetPeerKey () );
-}
-
-
-void
-TcpOptionMpTcpFastClose::Serialize (Buffer::Iterator i) const
-{
-  TcpOptionMpTcp::SerializeRef (i, 0);
-
-//  i.WriteU8 ( (GetSubType () << 4) + (uint8_t)0 );
-  i.WriteHtonU64 ( GetPeerKey () );
-}
-
-
-uint32_t
-TcpOptionMpTcpFastClose::Deserialize (Buffer::Iterator i)
-{
-
-  uint32_t length =  TcpOptionMpTcp::DeserializeRef (i);
-
-  NS_ASSERT ( length == GetSerializedSize() );
-
-  uint8_t subtype_and_flags = i.ReadU8 ();
-  NS_ASSERT ( subtype_and_flags >> 4 == GetSubType ()  );
-
-  SetPeerKey ( i.ReadNtohU64 () );
-
-  return GetSerializedSize();
-}
-
-uint32_t
-TcpOptionMpTcpFastClose::GetSerializedSize (void) const
-{
-  return 12;
-}
-
-///////////////////////////////////////////////////
-//// MP_FAIL to totally stop a flow of data
-////
-TcpOptionMpTcpFail::TcpOptionMpTcpFail ()
-  : TcpOptionMpTcp (TcpOptionMpTcp::MP_FAIL),
-    m_dsn (0)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-TcpOptionMpTcpFail::~TcpOptionMpTcpFail (void)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-void
-TcpOptionMpTcpFail::SetDSN (const uint64_t& dsn)
-{
-  NS_LOG_FUNCTION (dsn);
-  m_dsn = dsn;
-}
-
-
-uint64_t
-TcpOptionMpTcpFail::GetDSN (void) const
-{
-  return m_dsn;
-}
-
-
-void
-TcpOptionMpTcpFail::Print (std::ostream &os) const
-{
-  os << "MP_FAIL for DSN=" << GetDSN ();
-}
-
-
-bool
-TcpOptionMpTcpFail::operator== (const TcpOptionMpTcpFail& opt) const
-{
-  return (GetDSN () == opt.GetDSN ());
-}
-
-
-void
-TcpOptionMpTcpFail::Serialize (Buffer::Iterator i) const
-{
-  TcpOptionMpTcp::SerializeRef (i, 0);
-
-//  i.WriteU8 ( (GetSubType () << 4) + (uint8_t)0 );
-  i.WriteU8 ( 0 ); // reserved
-  i.WriteHtonU64 ( GetDSN () );
-}
-
-
-uint32_t
-TcpOptionMpTcpFail::Deserialize (Buffer::Iterator i)
-{
-
-  uint32_t length = TcpOptionMpTcp::DeserializeRef (i);
-  NS_ASSERT ( length == 12 );
-
-  uint8_t subtype_and_flags = i.ReadU8 ();
-  NS_ASSERT ( subtype_and_flags >> 4 == GetSubType ()  );
-
-  SetDSN ( i.ReadNtohU64 () );
-
-  return 12;
-}
-
-uint32_t
-TcpOptionMpTcpFail::GetSerializedSize (void) const
-{
-  return 12;
-}
-
-
-
-///////////////////////////////////////////////////
-//// MP_FAIL to totally stop a flow of data
-////
-TcpOptionMpTcpDeltaOWD::TcpOptionMpTcpDeltaOWD ()
-  : TcpOptionMpTcp (MP_DELTAOWD),
-//    m_targetedSubflow (0),
-    m_cookie (0),
-    m_nanoseconds (0)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-TcpOptionMpTcpDeltaOWD::~TcpOptionMpTcpDeltaOWD (void)
-{
-  NS_LOG_FUNCTION (this);
-}
-//
-//void
-//TcpOptionMpTcpDeltaOWD::SetDSN (const uint64_t& dsn)
-//{
-//  NS_LOG_FUNCTION (dsn);
-//  m_dsn = dsn;
-//}
-//uint64_t
-//TcpOptionMpTcpDeltaOWD::GetDSN (void) const
-//{
-//  return m_dsn;
-//}
-
-
-void
-TcpOptionMpTcpDeltaOWD::Print (std::ostream &os) const
-{
-  os << "MP_DELTAOWD "
-//    << "targeting=" <<  (int)m_targetedSubflow
-    << " cookie=" << m_cookie
-     << " with a recorded delay of =" << m_nanoseconds ;
-}
-
-
-bool
-TcpOptionMpTcpDeltaOWD::operator== (const TcpOptionMpTcpDeltaOWD& opt) const
-{
-  return (m_nanoseconds == opt.m_nanoseconds
-//        && m_targetedSubflow == opt.m_targetedSubflow
-        && m_cookie == opt.m_cookie
-        && m_type == opt.m_type
-        );
-}
-
-
-void
-TcpOptionMpTcpDeltaOWD::Serialize (Buffer::Iterator i) const
-{
-  TcpOptionMpTcp::SerializeRef (i, m_type);
-
-//  i.WriteU8 ( (GetSubType () << 4) + (uint8_t)0 );
-//  i.WriteU8 ( m_targetedSubflow );
-  i.WriteU8 ( m_cookie );
-  i.WriteHtonU64 ( m_nanoseconds );
-}
-
-TcpOptionMpTcpDeltaOWD::Type
-TcpOptionMpTcpDeltaOWD::GetType () const
-{
-
-    return m_type;
-}
-
-uint32_t
-TcpOptionMpTcpDeltaOWD::Deserialize (Buffer::Iterator i)
-{
-
-  uint32_t length = TcpOptionMpTcp::DeserializeRef (i);
-  NS_ASSERT ( length == 12 );
-
-  uint8_t subtype_and_flags = i.ReadU8 ();
-  NS_ASSERT ( subtype_and_flags >> 4 == GetSubType ()  );
-
-  m_cookie = i.ReadU8 ();
-  m_nanoseconds = i.ReadNtohU64 ();
-
-  return GetSerializedSize ();
-}
-
-uint32_t
-TcpOptionMpTcpDeltaOWD::GetSerializedSize (void) const
-{
-  return 12;
-}
-
-
-///////////////////////////////////////////////////
-//// MP_FAIL to totally stop a flow of data
-////
-TcpOptionMpTcpOwdTimeStamp::TcpOptionMpTcpOwdTimeStamp ()
-  : TcpOptionMpTcp (MP_OWDTS),
-    m_type (Request),
-    m_cookie (0),
-    m_nanoseconds (0)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-TcpOptionMpTcpOwdTimeStamp::~TcpOptionMpTcpOwdTimeStamp (void)
-{
-  NS_LOG_FUNCTION (this);
-}
-//
-//void
-//TcpOptionMpTcpOwdTimeStamp::SetDSN (const uint64_t& dsn)
-//{
-//  NS_LOG_FUNCTION (dsn);
-//  m_dsn = dsn;
-//}
-//uint64_t
-//TcpOptionMpTcpOwdTimeStamp::GetDSN (void) const
-//{
-//  return m_dsn;
-//}
-
-
-void
-TcpOptionMpTcpOwdTimeStamp::Print (std::ostream &os) const
-{
-  os << "MP_OWDTS"
-//    << "targeting=" <<  (int)m_targetedSubflow
-    << " cookie=" << m_cookie
-     << " with a recorded delay of =" << m_nanoseconds ;
-}
-
-
-bool
-TcpOptionMpTcpOwdTimeStamp::operator== (const TcpOptionMpTcpOwdTimeStamp& opt) const
-{
-  return (m_nanoseconds == opt.m_nanoseconds
-//        && m_targetedSubflow == opt.m_targetedSubflow
-        && m_cookie == opt.m_cookie
-        && m_type == opt.m_type
-        );
-}
-
-void
-TcpOptionMpTcpOwdTimeStamp::Serialize (Buffer::Iterator i) const
-{
-  TcpOptionMpTcp::SerializeRef (i, m_type);
-
-//  i.WriteU8 ( (GetSubType () << 4) + (uint8_t)0 );
-//  i.WriteU8 ( m_targetedSubflow );
-  i.WriteU8 ( m_cookie );
-  i.WriteHtonU64 ( m_nanoseconds );
-}
-
-TcpOptionMpTcpOwdTimeStamp::Type
-TcpOptionMpTcpOwdTimeStamp::GetType () const
-{
-
-    return m_type;
-}
-
-void
-TcpOptionMpTcpOwdTimeStamp::Setup (Type type, uint8_t cookie, int64_t nanoseconds)
-{
-  NS_LOG_FUNCTION (type << (int) cookie << nanoseconds);
-  m_type = type;
-  m_cookie = cookie;
-  m_nanoseconds = nanoseconds;
-}
-
-uint32_t
-TcpOptionMpTcpOwdTimeStamp::Deserialize (Buffer::Iterator i)
-{
-
-  uint32_t length = TcpOptionMpTcp::DeserializeRef (i);
-  NS_ASSERT ( length == 12 );
-
-  uint8_t subtype_and_flags = i.ReadU8 ();
-  NS_ASSERT ( subtype_and_flags >> 4 == GetSubType ()  );
-
-  m_type = static_cast<Type> (subtype_and_flags & 0x0f);
-  NS_ASSERT (m_type == Answer || m_type == Request);
-  
-  m_cookie = i.ReadU8 ();
-  m_nanoseconds = i.ReadNtohU64 ();
-
-  return GetSerializedSize ();
-}
-
-uint32_t
-TcpOptionMpTcpOwdTimeStamp::GetSerializedSize (void) const
-{
-  return 12;
-}
-
-
-} // namespace ns3
diff --git a/src/internet/model/tcp-option-mptcp.h b/src/internet/model/tcp-option-mptcp.h
deleted file mode 100644
index 0513fa0..0000000
--- a/src/internet/model/tcp-option-mptcp.h
+++ /dev/null
@@ -1,1326 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Matthieu Coudron
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-
-#ifndef TCP_OPTION_MPTCP_H
-#define TCP_OPTION_MPTCP_H
-
-#include "tcp-option.h"
-#include "tcp-header.h"
-#include "ns3/log.h"
-#include "ns3/address.h"
-#include "ns3/inet-socket-address.h"
-#include "ns3/inet6-socket-address.h"
-#include "ns3/mptcp-crypto.h"
-#include "ns3/sequence-number.h"
-#include <vector>
-
-/**
- * \ingroup mptcp
- *
- * Here are a few notations/acronyms used in the multipath tcp group
- * - 3WHS = three way handshake (SYN/SYN+ACK/ACK)
- * - DSN = Data Sequence Number
- * - DSS = Data Sequence Signaling
- */
-
-namespace ns3 {
-
-/**
- * \brief Defines the TCP option of kind 30 (Multipath TCP) as in \RFC{6824}
- *
- * MPTCP signaling messages are all encoded under the same TCP option number 30.
- * MPTCP then uses a subtype
- */
-class TcpOptionMpTcp : public TcpOption
-{
-public:
-  /**
-   * List the different subtypes of MPTCP options
-   */
-  enum SubType
-  {
-    MP_CAPABLE,
-    MP_JOIN,
-    MP_DSS,
-    MP_ADD_ADDR,
-    MP_REMOVE_ADDR,
-    MP_PRIO,
-    MP_FAIL,
-    MP_FASTCLOSE,
-
-    /** Non standard ones */
-    MP_DELTAOWD,    /**!< Incomplete implementation */
-    MP_OWDTS,       /**!< to retrieve OWDs */
-    
-    /** To retrieve length of the enum (keep last) */
-    MP_LAST
-  };
-
-
-  TcpOptionMpTcp (uint8_t subtype);
-  virtual ~TcpOptionMpTcp (void);
-
-  static TypeId GetTypeId (void);
-  virtual TypeId GetInstanceTypeId (void) const;
-  virtual void Print (std::ostream &os) const;
-
-  /**
-   * Converts a list of mptcp subtypes
-   *
-   * \return Human readable string of subtypes
-   */
-  static std::string
-  SubTypeToString (const uint8_t& flags, const std::string& delimiter);
-
-
-  /**
-   * Calls CreateObject with the template parameter with the class matching the given subtype
-   *
-   * \param Subtype of the MPTCP option to create
-   *
-   * \return An allocated but unconfigured option
-   */
-  static Ptr<TcpOption>
-  CreateMpTcpOption (const uint8_t& kind);
-
-  virtual uint32_t
-  GetSerializedSize (void) const = 0;
-
-  /** Get the subtype number assigned to this MPTCP option */
-  virtual uint8_t
-  GetKind (void) const;
-
-  virtual void
-  Serialize (Buffer::Iterator start) const = 0;
-
-  /**
-   * \return the MPTCP subtype of this class
-   */
-  virtual uint8_t
-  GetSubType (void) const;
-
-protected:
-  /**
-   * \brief Serialize TCP option type & length of the option
-   *
-   * \param lower_bits Only 4 rightmost bits will be kept
-   *
-   * Let children write the subtype since Buffer iterators
-   * can't write less than 1 byte
-   * Should be called at the start of every subclass Serialize call
-   */
-  virtual void
-  SerializeRef (Buffer::Iterator& i, uint8_t lower_bits) const;
-
-  /**
-   * \brief Factorizes ation reading/subtype check that each subclass should do.
-   *    Should be called at the start of every subclass Deserialize
-   * \return length of the option
-   */
-  uint32_t
-  DeserializeRef (Buffer::Iterator& i) const;
-
-private:
-  const uint8_t m_subtype;
-};
-
-#if 0
-/**
- * \tparam SUBTYPE should be an integer
- */
-template<TcpOptionMpTcp::SubType SUBTYPE>
-class TcpOptionMpTcp : public TcpOptionMpTcp
-{
-public:
-  TcpOptionMpTcp () : TcpOptionMpTcp ()
-  {
-  }
-
-  virtual ~TcpOptionMpTcp (void)
-  {
-  }
-
-  /**
-   * \return MPTCP option type
-   */
-  virtual TcpOptionMpTcp::SubType
-  GetSubType (void) const
-  {
-    return SUBTYPE;
-  }
-};
-#endif
-
-/**
- * \brief The MP_CAPABLE option is carried on the SYN, SYN/ACK, and ACK packets of the first TCP connection
- *  established by a MPTCP connection.
- *
- * This first subflow is sometimes called the *master* subflow. It embeds a key that will be used by later TCP connections (subflows)
- * to authenticate themselves as they want to join the MPTCP connection.
- *
- * Here is how the initial 3WHS must look like:
- *
- * \verbatim
-Host A                                  Host B
-------                                  ------
-MP_CAPABLE            ->
-[A's key, flags]
-                    <-                MP_CAPABLE
-                                      [B's key, flags]
-ACK + MP_CAPABLE      ->
-[A's key, B's key, flags]
-
-\endverbatim
-
-Here is the format as defined in \RFC{6824}, flags C to H refer to the crypto algorithm.
-Only sha1 is defined and supported in the standard (same for ns3).
-\verbatim
-
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+-------+---------------+
-|     Kind      |    Length     |Subtype|Version|A|B|C|D|E|F|G|H|
-+---------------+---------------+-------+-------+---------------+
-|                   Option Sender's Key (64 bits)               |
-|                                                               |
-|                                                               |
-+---------------------------------------------------------------+
-|                  Option Receiver's Key (64 bits)              |
-|                     (if option Length == 20)                  |
-|                                                               |
-+---------------------------------------------------------------+
-\endverbatim
- */
-class TcpOptionMpTcpCapable : public TcpOptionMpTcp
-{
-public:
-  TcpOptionMpTcpCapable (void);
-  virtual ~TcpOptionMpTcpCapable (void);
-
-  static TypeId GetTypeId (void);
-  virtual TypeId GetInstanceTypeId (void) const;
-
-
-  bool operator== (const TcpOptionMpTcpCapable&) const;
-
-  /**
-   * \brief Only version 0 is standardized so far
-   * \return 0
-   */
-  virtual uint8_t GetVersion (void) const;
-
-  /**
-   * \note MPTCP Checksums are not used in ns3
-   * \return True if checksum is required
-   */
-  virtual bool IsChecksumRequired (void) const;
-
-  /**
-   * Set sender key. Useful for each step of the 3WHS
-   *
-   * \param senderKey sender key
-   */
-  virtual void SetSenderKey (const uint64_t& senderKey);
-
-  /**
-   * Set remote key. Useful only for the last ACK of the 3WHS.
-   *
-   * \param remoteKey remote key that was received in the SYN/ACK
-   */
-  virtual void SetPeerKey (const uint64_t& remoteKey);
-
-  /**
-   * \brief Can tell if the option contain the peer key based on the option length
-   * \return True if peer key available
-   */
-  virtual bool HasReceiverKey (void) const;
-
-  /**
-   * \return Sender's key
-   */
-  virtual uint64_t GetSenderKey (void) const;
-
-  /**
-   * \warn
-   * \return Sender's key
-   */
-  virtual uint64_t GetPeerKey (void) const;
-
-
-  //! Inherited
-  virtual void Print (std::ostream &os) const;
-  virtual void Serialize (Buffer::Iterator start) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-  virtual uint32_t GetSerializedSize (void) const;
-
-protected:
-  uint8_t m_version;    /**< MPTCP version (4 bytes) */
-  uint8_t m_flags;      /**< 8 bits bitfield (unused in the standard for now) */
-  uint64_t m_senderKey; /**< Sender key */
-  uint64_t m_remoteKey; /**< Peer key */
-  uint32_t m_length;    /**< Stores the length of the option */
-
-private:
-  //! Defined and unimplemented to avoid misuse
-  TcpOptionMpTcpCapable (const TcpOptionMpTcpCapable&);
-  TcpOptionMpTcpCapable& operator= (const TcpOptionMpTcpCapable&);
-};
-
-
-/**
- * \brief The MP_JOIN option is used to add new subflows to an existing MPTCP connection
- *
- * Once cryptographic keys have been exchanged and the first MPTCP Data Ack (in a DSS option) was received from the server (i.e. 2 RTTs),
- * an MPTCP socket can decide to open/close subflows.
- * The opening of new subflows is similar to the MP_CAPABLE 3WHS but it uses MP_JOIN option instead.
- * The MP_JOIN embeds cryptographic data generated from a nonce and the keys sent through the initial MP_CAPABLE in
- * order to be recognized by the remote host as valid connections (to prevent connection hijacking).
- *
- * An MP_JOIN is exchanged during the 3 modes of the 3WHS: Syn/SynAck/Ack and depending on the mode,
- * the structure of the option is very different as can be seen in the following:
- *
- * MP_JOIN Option for Initial SYN:
- * \verbatim
-                     1                   2                   3
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+-----+-+---------------+
-|     Kind      |  Length = 12  |Subtype|     |B|   Address ID  |
-+---------------+---------------+-------+-----+-+---------------+
-|                   Receiver's Token (32 bits)                  |
-+---------------------------------------------------------------+
-|                Sender's Random Number (32 bits)               |
-+---------------------------------------------------------------+
-\endverbatim
-
-MP_JOIN for responding SYN/ACK
-\verbatim
-                     1                   2                   3
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+-----+-+---------------+
-|     Kind      |  Length = 16  |Subtype|     |B|   Address ID  |
-+---------------+---------------+-------+-----+-+---------------+
-|                                                               |
-|                Sender's Truncated HMAC (64 bits)              |
-|                                                               |
-+---------------------------------------------------------------+
-|                Sender's Random Number (32 bits)               |
-+---------------------------------------------------------------+
-
-\endverbatim
-MP_JOIN Option for third ACK:
-\verbatim
-                     1                   2                   3
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+-----------------------+
-|     Kind      |  Length = 24  |Subtype|      (reserved)       |
-+---------------+---------------+-------+-----------------------+
-|                                                               |
-|                                                               |
-|                   Sender's HMAC (160 bits)                    |
-|                                                               |
-|                                                               |
-+---------------------------------------------------------------+
-\endverbatim
-
-To sum up a subflow 3WHS :
-\verbatim
-Host A                          Host B
- |   SYN + MP_JOIN(Token-B, R-A)  |
- |------------------------------->|
- |<-------------------------------|
- | SYN/ACK + MP_JOIN(HMAC-B, R-B) |
- |                                |
- |     ACK + MP_JOIN(HMAC-A)      |
- |------------------------------->|
- |<-------------------------------|
- |             ACK                |
-
-HMAC-A = HMAC(Key=(Key-A+Key-B), Msg=(R-A+R-B))
-HMAC-B = HMAC(Key=(Key-B+Key-A), Msg=(R-B+R-A))
-\endverbatim
-or
-\verbatim
-  Host A                                  Host B
-  ------                                  ------
-  MP_JOIN               ->
-  [B's token, A's nonce,
-   A's Address ID, flags]
-                        <-                MP_JOIN
-                                          [B's HMAC, B's nonce,
-                                           B's Address ID, flags]
-  ACK + MP_JOIN         ->
-  [A's HMAC]
-
-                        <-                ACK
-\endverbatim
-**/
-class TcpOptionMpTcpJoin :
-//public TcpOptionMpTcp<TcpOptionMpTcp::MP_JOIN>
-public TcpOptionMpTcp
-{
-
-public:
-  /**
-   * \enum State
-   * \brief The MPTCP standard assigns only one MP_JOIN subtype but depending on its rank
-   * during the 3 WHS, it can have very different meanings. In order to prevent misuse by the user,
-   * this option is very defensive and won't accept setter or getter calls for a rank that is
-   * not its current rank
-   * The enum values match the size (in bytes) of the option.
-  **/
-  enum Mode
-  {
-    Uninitialized = 0,
-    Syn    = 12,  /**< peer token + nonce */
-    SynAck = 16,  /**< peer truncated hmac + nonce */
-    Ack    = 24   /**< Send sender full hmac */
-  };
-
-  static TypeId GetTypeId (void);
-  virtual TypeId GetInstanceTypeId (void) const;
-
-  TcpOptionMpTcpJoin (void);
-  virtual ~TcpOptionMpTcpJoin (void);
-
-  virtual bool operator== (const TcpOptionMpTcpJoin&) const;
-
-  /**
-   * \return Mode (internal value) in which the option is configured
-   */
-  virtual Mode
-  GetMode (void) const;
-
-  /**
-   * \brief Available in Syn and SynAck modes
-   * \return nonce
-  **/
-  virtual uint32_t
-  GetNonce (void) const;
-
-  /**
-   * \param nonce Random number used to prevent malicious subflow establishement from
-   * malicious nodes
-   */
-  virtual void
-  SetNonce (const uint32_t& nonce);
-
-  /**
-  * \note Available in SynAck mode only
-  **/
-  virtual void SetTruncatedHmac (const uint64_t& );
-
-  /**
-  * \note Available in SynAck mode
-  **/
-  virtual uint64_t GetTruncatedHmac (void) const;
-
-  /**
-  * \brief Returns hmac generated by the peer.
-  * \warning Available in Ack mode only
-  * \return null for now (not implemented)
-  */
-  virtual const uint8_t* GetHmac (void) const;
-
-  /**
-  * \brief Available only in Ack mode. Sets Hmac computed from the nonce, tokens previously exchanged
-  * \warning Available in Ack mode only
-  * \param hmac
-  * \todo not implemented
-  */
-  virtual void SetHmac (uint8_t hmac[20]);
-
-
-  /**
-   * \brief Set token computed from peer's key
-   * Used in the SYN message of the MP_JOIN 3WHS
-   */
-  virtual void
-  SetPeerToken (const uint32_t& token);
-
-  /**
-  * \return Peer token (the token being a hash of the key)
-  */
-  virtual uint32_t
-  GetPeerToken (void) const;
-
-  /**
-   * \brief Unique id assigned by the remote host to this subflow combination (ip,port).
-   * \return Identifier of the subflow
-   */
-  virtual uint8_t
-  GetAddressId (void) const;
-
-  /**
-  * \brief When a subflow joins a connection, it should advertise a unique identifier
-  *
-  * \param addrId unique identifier associated with this very subflow
-  */
-  virtual void
-  SetAddressId (const uint8_t& addrId);
-
-
-  virtual void Print (std::ostream &os) const;
-
-  virtual void Serialize (Buffer::Iterator start) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-  virtual uint32_t GetSerializedSize (void) const;
-
-  /**
-   * \brief When creating from scratch a, MP_CAPABLE option, to call first. Once a mode has been set,
-   * it is not possible to change. Depending on the chosen mode, some functions will trigger a fatal error
-   * to prevent ns3 from doing meaningless actions.
-   *
-   * \param mode Mode in which we want to configure the option: Syn or SynAck or Ack
-  **/
-  virtual void SetMode (Mode s);
-
-protected:
-  Mode m_mode;          /**<  3 typs of MP_JOIN. Members will throw an exception if used in wrong mode. */
-  uint8_t m_addressId;  /**< Unique identifier assigend to this subflow */
-  uint8_t m_flags;      /**< Unused so far. */
-  uint32_t m_buffer[5]; /**< Memory buffer to register the data of the different modes */
-
-private:
-  //! Defined and unimplemented to avoid misuse
-  TcpOptionMpTcpJoin (const TcpOptionMpTcpJoin&);
-  TcpOptionMpTcpJoin& operator= (const TcpOptionMpTcpJoin&);
-};
-
-
-
-/**
- * \brief DSS option (Data Sequence Signaling)
- *
- * This option can transport 3 different optional semantic information.
- * First it is important to understand that MPTCP uses an additional sequence number space
- * on top of TCP sequence numbers in order to reorder the bytes at the receiver.
- * The DSS option is in charge of carrying MPTCP sequence number related information between
- * the hosts.
- * MPTCP sequence numbers are mapped to TCP sequence numbers through this option and
- * are acked through this option as well. It it also this option that signals the end of
- * the MPTCP connection (similar to the TCP FIN flag).
- *
- * \warn Note that members asserts that flag is enabled before returning any value.
- *
- * \note MPTCP sequence numbers are 8 bytes long but when conveyed through a TCP option,
- *       they can be trimmed to 4 bytes in order to save TCP option space.
- *
- * \warn ns3 should allow to carry both 4 and 8 bytes but the initial implementation relied on 4 bytes
- *       so you may find bugs
- *
- * \warn checksum are not supported since they make little sense in ns3 case
- * The data sequence number is specified as an absolute value, whereas
-   the subflow sequence numbering is relative (the SYN at the start of
-   the subflow has relative subflow sequence number 0).  This is to
-   allow middleboxes to change the initial sequence number of a subflow,
-   such as firewalls that undertake ISN randomization.
- *
- * Data Sequence Signal (DSS) Option
- *
-
-\verbatim
-                      1                   2                   3
-  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
- +---------------+---------------+-------+----------------------+
- |     Kind      |    Length     |Subtype| (reserved) |F|m|M|a|A|
- +---------------+---------------+-------+----------------------+
- |           Data ACK (4 or 8 octets, depending on flags)       |
- +--------------------------------------------------------------+
- |   Data sequence number (4 or 8 octets, depending on flags)   |
- +--------------------------------------------------------------+
- |              Subflow Sequence Number (4 octets)              |
- +-------------------------------+------------------------------+
- |  Data-Level Length (2 octets) |      Checksum (2 octets)     |
- +-------------------------------+------------------------------+
-
-\endverbatim
-*/
-class TcpOptionMpTcpDSS :
-//public TcpOptionMpTcp<TcpOptionMpTcp::MP_DSS>
-public TcpOptionMpTcp
-{
-
-public:
-  /**
-   * Each value represents the offset of a flag in LSB order
-   * \see TcpOptionMpTcpDSS
-   */
-  enum FLAG
-  {
-    DataAckPresent  = 1,       //!< matches the "A" in previous packet format
-    DataAckOf8Bytes = 2,       //!< a
-    DSNMappingPresent = 4,     //!< M bit
-    DSNOfEightBytes   = 8,     //!< m bit
-    DataFin           = 16,    //!< F . set to indicate end of communication
-    CheckSumPresent   = 32     //!< Not computed for now
-
-  };
-
-  static TypeId GetTypeId (void);
-  virtual TypeId GetInstanceTypeId (void) const;
-
-  TcpOptionMpTcpDSS (void);
-  virtual ~TcpOptionMpTcpDSS (void);
-
-
-  /**
-   * \brief Upon detecting an error, an MPTCP connection can fallback to legacy TCP.
-   *
-   * \return False (not implemented)
-   */
-  virtual bool IsInfiniteMapping () const;
-
-  /**
-   * \brief when DataFin is set, the data level length is increased by one.
-   * \return True if the mapping present is just because of the datafin
-   */
-  virtual bool DataFinMappingOnly () const;
-
-
-  /**
-   *
-   */
-  virtual void TruncateDSS (bool truncate);
-
-  /**
-   * \brief This returns a copy
-   * \warning Asserts if flags
-   * \
-   */
-  // Disabled to remove dependancy towards MpTcpMapping
-  // ToDo prepare a wrapper to create mapping from that
-//  MpTcpMapping GetMapping(void) const;
-  virtual void GetMapping (uint64_t& dsn, uint32_t& ssn, uint16_t& length) const;
-
-  /**
-   * \brief
- * Related to DFIN
-   The DATA_FIN is signaled by setting the 'F' flag in the Data Sequence
-   Signal option (Figure 9) to 1.  A DATA_FIN occupies 1 octet (the
-   final octet) of the connection-level sequence space.  Note that the
-   DATA_FIN is included in the Data-Level Length, but not at the subflow
-   level: for example, a segment with DSN 80, and Data-Level Length 11,
-   with DATA_FIN set, would map 10 octets from the subflow into data
-   sequence space 80-89, the DATA_FIN is DSN 90; therefore, this segment
-   including DATA_FIN would be acknowledged with a DATA_ACK of 91.
-
-   Note that when the DATA_FIN is not attached to a TCP segment
-   containing data, the Data Sequence Signal MUST have a subflow
-   sequence number of 0, a Data-Level Length of 1, and the data sequence
-   number that corresponds with the DATA_FIN itself.  The checksum in
-   this case will only cover the pseudo-header.
-
-   * \param mappingLength You should not add the 
-   * \param trunc_to_32bits Set to true to send a 32bit DSN
-   * \warn Mapping can be set only once, otherwise it will crash ns3
-   */
-  virtual void SetMapping (uint64_t headDsn, uint32_t headSsn, uint16_t mappingLength, bool enable_dfin);
-
-  /**
-   * \brief A DSS length depends on what content it embeds. This is defined by the flags.
-   * \return All flags
-   */
-  virtual uint8_t GetFlags (void) const;
-
-
-  virtual bool operator== (const TcpOptionMpTcpDSS&) const;
-
-  /**
-  * \brief Set seq nb of acked data at MPTP level
-  * \param dack Sequence number of the dataack
-  * \param send_as_32bits Decides if the DACK should be sent as a 32 bits number
-  */
-  virtual void SetDataAck (const uint64_t& dack, const bool& send_as_32bits = true);
-
-  /**
-  * \brief Get data ack value
-  *
-  * \warning  check the flags to know if the returned value is a 32 or 64 bits DSN
-  */
-  virtual uint64_t GetDataAck (void) const;
-
-  /**
-   * \brief Unimplemented
-   */
-  virtual void SetChecksum (const uint16_t&);
-
-  /**
-   * \brief Unimplemented
-   */
-  virtual uint16_t GetChecksum (void) const;
-
-  /**
-   * \brief Enable also a mapping flag
-   * \param final_dsn Last MPTCP sequence number. Will be ignored if a mapping had been previsouly set.
-   * \param send_as_32bits Set to true to truncate final_dsn to its 32 bits version
-   *
-   */
-//  virtual void AddDataFin ();
-
-  /**
-  * \return If DFIN is set, returns its associated DSN
-  *
-  * \warning check the flags to know if it returns a 32 or 64 bits DSN
-  */
-  virtual uint64_t GetDataFinDSN () const;
-  virtual uint16_t GetDataLevelLength () const;
-
-
-  virtual void Print (std::ostream &os) const;
-  virtual void Serialize (Buffer::Iterator ) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-  virtual uint32_t GetSerializedSize (void) const;
-
-  /**
-  * \brief the DSS option size can change a lot
-  *
-  * The DSS size depends if it embeds a DataAck, a mapping, in 32 bits
-  *   or in 64 bits. This can compute the size depending on the flags
-  *
-  * \param flags flags of the DSS option
-  */
-  static uint32_t GetSizeFromFlags (uint16_t flags);
-
-protected:
-
-  bool m_hasChecksum;   //!< true if checksums enabled
-  uint16_t m_checksum;  //!< valeu of the checksum
-
-  uint8_t m_flags;  //!< bitfield
-
-  // In fact for now we use only 32 LSB
-  uint64_t m_dataAck;         /**< Can be On 32 bits dependings on the flags **/
-  uint64_t m_dsn;             /**< Data Sequence Number (Can be On 32 bits dependings on the flags) */
-  uint32_t m_ssn;             /**< Subflow Sequence Number, always 32bits */
-  
-  /**< Length of the mapping only, without consideration for DFIN => 
-    It is not the exact dataLevelLength
-  */
-  uint16_t m_mappingLength;
-
-private:
-  //! Defined and unimplemented to avoid misuse
-  TcpOptionMpTcpDSS (const TcpOptionMpTcpDSS&);
-  TcpOptionMpTcpDSS& operator= (const TcpOptionMpTcpDSS&);
-};
-
-
-
-
-/**
- * \brief Used to advertise new subflow possibilities
- *
- * This option signals to the peer an IP or a couple (IP, port) to which the peer could
- * open a new subflow.
- * Every combination (IP, port) must have a unique ID ("Address ID"), whose allocation is not specified
- * in the standard.
- *
- * \see TcpOptionMpTcpRemoveAddress
- *
- * \note Only supports IPv4 version for now
- *
- * \note Though the port is optional in the RFC, ns3 implementation always include it, even if
- * it's 0 for the sake of simplicity.
- *
- * Add Address (ADD_ADDR) option:
-\verbatim
-                     1                   2                   3
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+-------+---------------+
-|     Kind      |     Length    |Subtype| IPVer |  Address ID   |
-+---------------+---------------+-------+-------+---------------+
-|          Address (IPv4 - 4 octets / IPv6 - 16 octets)         |
-+-------------------------------+-------------------------------+
-|   Port (2 octets, optional)   |
-+-------------------------------+
-\endverbatim
-
- */
-class TcpOptionMpTcpAddAddress :
-//public TcpOptionMpTcp<TcpOptionMpTcp::MP_ADD_ADDR>
-public TcpOptionMpTcp
-{
-
-public:
-  static TypeId GetTypeId (void);
-  virtual TypeId GetInstanceTypeId (void) const;
-
-  TcpOptionMpTcpAddAddress (void);
-  virtual ~TcpOptionMpTcpAddAddress (void);
-
-
-  /**
-  we always send the port, even if it's 0 ?
-
-   "port is specified, MPTCP SHOULD attempt to connect to the specified
-   address on the same port as is already in use by the subflow on which
-   the MP_ADD_ADDR signal was sent"
-  */
-//  virtual bool IsPortEmbedded(void) ;
-
-  /**
-   * \brief Expects InetXSocketAddress
-   */
-  virtual void SetAddress (const Address& address, uint8_t addrId);
-
-  virtual bool operator== (const TcpOptionMpTcpAddAddress&) const;
-
-  /**
-   * \note Only IPv4 is supported so far
-   *
-   * \return IP version (i.e., 4 or 6)
-   */
-  virtual uint8_t GetAddressVersion (void) const;
-
-  /**
-   * \brief Return advertised InetSocketAddress.
-   * If port unset, ns3 sets it to 0
-   * \return
-   */
-  virtual InetSocketAddress GetAddress (void) const;
-
-  /**
-   * \see GetAddress
-   */
-  virtual Inet6SocketAddress GetAddress6 (void) const;
-
-  /**
-   * \return Address id assigned to the combination
-   */
-  virtual uint8_t GetAddressId (void) const;
-
-  //! Inherited
-  virtual void Print (std::ostream &os) const;
-  virtual void Serialize (Buffer::Iterator start) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-  virtual uint32_t GetSerializedSize (void) const;
-
-protected:
-  uint8_t m_addressVersion; /**< IPversion (4 or 6) */
-  uint8_t m_addrId;
-  uint8_t m_port; /**< Optional value */
-
-  Ipv4Address m_address;  /**< Advertised IPv4 address */
-  Ipv6Address m_address6; //!< unused
-
-private:
-  //! Defined and unimplemented to avoid misuse
-  TcpOptionMpTcpAddAddress (const TcpOptionMpTcpAddAddress&);
-  TcpOptionMpTcpAddAddress& operator= (const TcpOptionMpTcpAddAddress&);
-};
-
-/**
- * \see TcpOptionMpTcpAddAddress
- *
- * \brief Allow to remove joinable addresses
- *
- * In case ADD_ADDR was used to advertise an IP that is not valid anymore (e.g., because of roaming),
- * this option allows to remove it from peer memory (and can remove a batch of them).
- * The subflow should not exist yet (else you must use TCP FIN to close it).
- *
- * REMOVE_ADDR option:
- * \verbatim
-                     1                   2                   3
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+-------+---------------+
-|     Kind      |  Length = 3+n |Subtype|(resvd)|   Address ID  | ...
-+---------------+---------------+-------+-------+---------------+
-            (followed by n-1 Address IDs, if required)
-
-\endverbatim
- */
-class TcpOptionMpTcpRemoveAddress :
-//public TcpOptionMpTcp<TcpOptionMpTcp::MP_REMOVE_ADDR>
-public TcpOptionMpTcp
-{
-
-public:
-  static TypeId GetTypeId (void);
-  virtual TypeId GetInstanceTypeId (void) const;
-
-  TcpOptionMpTcpRemoveAddress (void);
-  virtual ~TcpOptionMpTcpRemoveAddress (void);
-
-  /**
-   * As we do not know in advance the number of records, we pass a vector
-   * \param Returns the addresses into a vector. Empty it before use.
-   */
-  void GetAddresses (std::vector<uint8_t>& addresses);
-
-  /**
-   * Append an association id to remove from peer memory
-   * \param addressId The association (IP,port) id
-   */
-  void AddAddressId (uint8_t addressId);
-
-
-  virtual bool operator== (const TcpOptionMpTcpRemoveAddress&) const;
-
-  //! Inherited
-  virtual void Print (std::ostream &os) const;
-  virtual void Serialize (Buffer::Iterator start) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-  virtual uint32_t GetSerializedSize (void) const;
-
-protected:
-  std::vector<uint8_t> m_addressesId; /**< List of removed association ids */
-
-private:
-  //! Defined and unimplemented to avoid misuse
-  TcpOptionMpTcpRemoveAddress (const TcpOptionMpTcpRemoveAddress&);
-  TcpOptionMpTcpRemoveAddress& operator= (const TcpOptionMpTcpRemoveAddress&);
-};
-
-
-/**
- * \brief Allow to (un)block emission from peer on this subflow
- *
- * MPTCP allows a host to advertise their preference about the links they would prefer to use.
- * It is advertised as a boolean (B) that means "Please don't send data on this connection, except if
- * there is a problem".
- * The peer is free to ignore this preference.
- * This option is unidirectional, i.e, an emitter may ask not to receive data
- * on a subflow while transmitting on it.
- *
- * \warn This option is not taken into account by ns3 yet.
- *
- * MP_PRIO option:
-\verbatim
-                     1                   2                   3
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+-----+-+--------------+
-|     Kind      |     Length    |Subtype|     |B| AddrID (opt) |
-+---------------+---------------+-------+-----+-+--------------+
-
-\endverbatim
- *
- */
-class TcpOptionMpTcpChangePriority : public TcpOptionMpTcp
-{
-
-public:
-
-  /**
-   * This is to help finding bugs in the code where one subflow would have forgotten
-   *
-   */
-  static const uint8_t BAD_ADDRID = 0xff;
-
-  /**
-   * Only one flag standardized
-   */
-  enum Flags
-  {
-    Backup = 0 /**< Set this flag if you prefer not to receive data on path addressId*/
-  };
-
-  static TypeId GetTypeId (void);
-  virtual TypeId GetInstanceTypeId (void) const;
-
-  TcpOptionMpTcpChangePriority (void);
-  virtual ~TcpOptionMpTcpChangePriority (void);
-
-  /**
-   * \brief All flags should be set at once.
-   *
-   * You can append flags by using SetFlags( option.GetFlags() | NewFlag)
-   *
-   * \example SetFlags(TcpOptionMpTcpChangePriority::Backup);
-   */
-  virtual void SetFlags (const uint8_t& flags);
-
-  /**
-   * \brief Optional. If you don't set addrId, the receiver considers the subflow on which the
-   * option was received
-   */
-  virtual void SetAddressId (const uint8_t& addrId);
-
-  /**
-   * \return True if an address id was set in the packet.
-   * \note Result depends on length of the option
-   */
-  virtual bool EmbeddedAddressId (void) const;
-
-  /**
-   * \return association id
-   * \warning will assert if addressId was not set. check it with \see EmbeddedAddressId
-   */
-  virtual uint8_t GetAddressId () const;
-
-  /**
-   * \return flags, i.e., the 4 LSB
-   */
-  virtual uint8_t GetFlags (void) const;
-
-  virtual bool operator== (const TcpOptionMpTcpChangePriority& ) const;
-
-
-  virtual void Print (std::ostream &os) const;
-  virtual void Serialize (Buffer::Iterator start) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-
-  /**
-   * \brief Length may be 3 or 4 (if addrId present)
-  */
-  virtual uint32_t GetSerializedSize (void) const;
-
-
-private:
-  /**
-   * \brief Copy constructor
-   *
-   * Defined and unimplemented to avoid misuse
-   */
-  TcpOptionMpTcpChangePriority (const TcpOptionMpTcpChangePriority&);
-  TcpOptionMpTcpChangePriority& operator= (const TcpOptionMpTcpChangePriority&);
-
-  uint8_t m_length;   /**< Length of this option */
-
-  uint8_t m_addrId;   //!< May be unset
-  uint8_t m_flags;    //!< On 4 bits
-};
-
-
-/**
- * \brief MP_FASTCLOSE is the equivalent of TCP RST at the MPTCP level
- *
- * For example, if the operating system is running out of resources, MPTCP could send an
- * MP_FASTCLOSE.
- * This should not be very useful in ns3 scenarii.
- *
- * MP_FASTCLOSE option:
-\verbatim
-
-                     1                   2                   3
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+-----------------------+
-|     Kind      |    Length     |Subtype|      (reserved)       |
-+---------------+---------------+-------+-----------------------+
-|                      Option Receiver's Key                    |
-|                            (64 bits)                          |
-|                                                               |
-+---------------------------------------------------------------+
-
-\endverbatim
-**/
-class TcpOptionMpTcpFastClose :
-//public TcpOptionMpTcp<TcpOptionMpTcp::MP_FASTCLOSE>
-public TcpOptionMpTcp
-{
-
-public:
-  TcpOptionMpTcpFastClose (void);
-  virtual ~TcpOptionMpTcpFastClose (void);
-
-
-  virtual bool operator== (const TcpOptionMpTcpFastClose&) const;
-
-
-  /**
-  * \brief Set peer key to prevent spoofing a MP_FastClose.
-  * \param remoteKey key exchanged during the 3WHS.
-  */
-  virtual void SetPeerKey (const uint64_t& remoteKey);
-
-  /**
-  * \return peer's key
-  */
-  virtual uint64_t GetPeerKey (void) const;
-
-  //! Inherited
-  virtual void Print (std::ostream &os) const;
-  virtual void Serialize (Buffer::Iterator start) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-  virtual uint32_t GetSerializedSize (void) const;
-
-
-private:
-  uint64_t m_peerKey; /**< Key of the remote host so that it accepts the RST */
-
-  //! Defined and unimplemented to avoid misuse
-  TcpOptionMpTcpFastClose (const TcpOptionMpTcpFastClose&);
-  TcpOptionMpTcpFastClose& operator= (const TcpOptionMpTcpFastClose&);
-};
-
-
-/**
- * \brief Option used when a problem is noticed at any point during a connection (payload changed etc).
- * A subflow would sends RST and MP_FAIL option
- *
- *
- * Note that the MP_FAIL option requires the use of the full 64-bit sequence number, even if 32-bit sequence numbers are
- * normally in use in the DSS signals on the path.
- *
- * Such a situation is likely to never happen in ns3 and thus this option is implemented as a reference only.
- *
- MP_FAIL option:
-\verbatim
-                     1                   2                   3
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+----------------------+
-|     Kind      |   Length=12   |Subtype|      (reserved)      |
-+---------------+---------------+-------+----------------------+
-|                                                              |
-|                 Data Sequence Number (8 octets)              |
-|                                                              |
-+--------------------------------------------------------------+
-
-\endverbatim
-*/
-class TcpOptionMpTcpFail :
-//public TcpOptionMpTcp<TcpOptionMpTcp::MP_FAIL>
-public TcpOptionMpTcp
-{
-
-public:
-  TcpOptionMpTcpFail (void);
-  virtual ~TcpOptionMpTcpFail (void);
-
-  virtual bool operator== (const TcpOptionMpTcpFail& ) const;
-
-  /**
-   * \brief Set Data Sequence Number (DSN) until which the communication was fine
-   * \param dsn Last in-order ACK-1 received
-   */
-  virtual void SetDSN (const uint64_t& dsn);
-
-  /**
-   * \return DSN for which error was detected
-   */
-  virtual uint64_t GetDSN (void) const;
-
-  //! Inherited
-  virtual void Print (std::ostream &os) const;
-  virtual void Serialize (Buffer::Iterator start) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-  virtual uint32_t GetSerializedSize (void) const;
-
-
-private:
-  //! Defined and unimplemented to avoid misuse
-  TcpOptionMpTcpFail (const TcpOptionMpTcpFail&);
-  TcpOptionMpTcpFail& operator= (const TcpOptionMpTcpFail&);
-
-  uint64_t m_dsn; /**< Last acked dsn */
-};
-
-
-
-/**
- * We assume a nanosecond resolution.
- * This resolution could be exchanged in a 3WHS manner
- *
- *
-\verbatim
-                     1                   2                   3
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+-----+-+--------------+
-|     Kind      |     Length    |Subtype|  type |    cookie    |
-+---------------+---------------+-------+----------------------+
-|                                                              |
-|                 Departure time       (8 octets)              |
-|                                                              |
-+--------------------------------------------------------------+
-
-\endverbatim
- */
-class TcpOptionMpTcpDeltaOWD :
-//public TcpOptionMpTcp<TcpOptionMpTcp::MP_FAIL>
-public TcpOptionMpTcp
-{
-
-public:
-  TcpOptionMpTcpDeltaOWD (void);
-  virtual ~TcpOptionMpTcpDeltaOWD (void);
-
-  virtual bool operator== (const TcpOptionMpTcpDeltaOWD& ) const;
-
-  enum State {
-  None,
-  ExpectingAnswer,          /**!< Probe was sent, waiting for answer */
-//  ExpectingOtherSubflow,    /**!< Probe was sent, waiting for answer */
-  ExpectingCoupledSubflow,  /**!< answer was received on this subflow only */
-  PendingSend   /**!< Ready to send a new probe */
-  };
-  /**
-   We don't care if it's hackish anymore, this is our own o/
-   we rule the world !
-  **/
-//  uint8_t m_targetedSubflow;  /**< subflow id from which to compare arrival times */
-
-  enum Type {
-    Answer,
-    Request
-  };
-
-
-  int m_cookie;     /* to identify option */
-  int64_t m_nanoseconds;      /**< assume this resolution Could be passed via the option */
-
-  Type GetType () const;
-  
-  void Setup (Type type, uint8_t cookie, int64_t nanoseconds);
-  
-  //! Inherited
-  virtual void Print (std::ostream &os) const;
-  virtual void Serialize (Buffer::Iterator start) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-  virtual uint32_t GetSerializedSize (void) const;
-
-protected:
-//  bool m_type;     /* to identify option */
-  Type m_type;     /* answer/request */
-private:
-  //! Defined and unimplemented to avoid misuse
-  TcpOptionMpTcpDeltaOWD (const TcpOptionMpTcpDeltaOWD&);
-  TcpOptionMpTcpDeltaOWD& operator= (const TcpOptionMpTcpDeltaOWD&);
-
-
-//  uint64_t m_dsn; /**< Last acked dsn */
-};
-
-
-/**
- * We assume a nanosecond resolution.
- * This resolution could be exchanged in a 3WHS manner
- *
- *
-\verbatim
-                     1                   2                   3
- 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
-+---------------+---------------+-------+-----+-+--------------+
-|     Kind      |     Length    |Subtype|  type |    cookie    |
-+---------------+---------------+-------+----------------------+
-|                                                              |
-|                 Departure time       (8 octets)              |
-|                                                              |
-+--------------------------------------------------------------+
-
-\endverbatim
- */
-class TcpOptionMpTcpOwdTimeStamp :
-//public TcpOptionMpTcp<TcpOptionMpTcp::MP_FAIL>
-public TcpOptionMpTcp
-{
-
-public:
-  TcpOptionMpTcpOwdTimeStamp (void);
-  virtual ~TcpOptionMpTcpOwdTimeStamp (void);
-
-  virtual bool operator== (const TcpOptionMpTcpOwdTimeStamp& ) const;
-
-  enum State {
-  None,
-  ExpectingAnswer,          /**!< Probe was sent, waiting for answer */
-//  ExpectingOtherSubflow,    /**!< Probe was sent, waiting for answer */
-//  ExpectingCoupledSubflow,  /**!< answer was received on this subflow only */
-  PendingSend   /**!< Ready to send a new probe */
-  };
-
-  /**
-   We don't care if it's hackish anymore, this is our own o/
-   we rule the world !
-  **/
-//  uint8_t m_targetedSubflow;  /**< subflow id from which to compare arrival times */
-
-  enum Type {
-    Answer,
-    Request
-  };
-
-  void Setup (Type type, uint8_t cookie, int64_t nanoseconds);
-  
-//  bool m_type;     /* to identify option */
-  Type m_type;     /* answer/request */
-  int m_cookie;     /* to identify option */
-  int64_t m_nanoseconds;      /**< assume this resolution Could be passed via the option */
-
-  
-  
-  Type GetType () const;
-
-  //! Inherited
-  virtual void Print (std::ostream &os) const;
-  virtual void Serialize (Buffer::Iterator start) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-  virtual uint32_t GetSerializedSize (void) const;
-
-
-private:
-  //! Defined and unimplemented to avoid misuse
-  TcpOptionMpTcpOwdTimeStamp (const TcpOptionMpTcpOwdTimeStamp&);
-  TcpOptionMpTcpOwdTimeStamp& operator= (const TcpOptionMpTcpOwdTimeStamp&);
-
-
-//  uint64_t m_dsn; /**< Last acked dsn */
-};
-
-/**
- * \brief Helper function to find an MPTCP option
- *
- * \param ret save found option in ret, otherwise
- * \return true if matching option type found. If false, ret should be considered invalid
-*/
-//template<class T>
-//bool
-//GetMpTcpOption (const TcpHeader& header, Ptr<T>& ret)
-//{
-//  TcpHeader::TcpOptionList l;
-//  header.GetOptions (l);
-//  for (TcpHeader::TcpOptionList::const_iterator it = l.begin (); it != l.end (); ++it)
-//    {
-//      if ( (*it)->GetKind () == TcpOption::MPTCP)
-//        {
-//          Ptr<TcpOptionMpTcp> opt = DynamicCast<TcpOptionMpTcp> (*it);
-//          NS_ASSERT (opt);
-//          T temp;
-//          if ( opt->GetSubType () == temp.GetSubType ()  )
-//            {
-//              ret = DynamicCast<T> (opt);
-//              return true;
-//            }
-//        }
-//    }
-//  return false;
-//}
-
-/**
- * \brief Like GetMpTcpOption but if does not find the option then it creates one
- *       and append it to the the header
- *
- * \see GetMpTcpOption
- * \return false if it had to create the option
-**/
-template<class T>
-bool
-GetOrCreateMpTcpOption (TcpHeader& header, Ptr<T>& ret)
-{
-  if (!GetTcpOption (header,ret))
-    {
-      ret = Create<T> ();
-      header.AppendOption (ret);
-      return false;
-    }
-  return true;
-}
-
-
-} // namespace ns3
-
-#endif /* TCP_OPTION_MPTCP */
diff --git a/src/internet/model/tcp-option-winscale.cc b/src/internet/model/tcp-option-winscale.cc
index 1cf962b..d01427a 100644
--- a/src/internet/model/tcp-option-winscale.cc
+++ b/src/internet/model/tcp-option-winscale.cc
@@ -58,7 +58,7 @@ TcpOptionWinScale::GetInstanceTypeId (void) const
 void
 TcpOptionWinScale::Print (std::ostream &os) const
 {
-  os << "WinScale=" << static_cast<int> (m_scale);
+  os << static_cast<int> (m_scale);
 }
 
 uint32_t
diff --git a/src/internet/model/tcp-option.cc b/src/internet/model/tcp-option.cc
index f42a2d9..d668f19 100644
--- a/src/internet/model/tcp-option.cc
+++ b/src/internet/model/tcp-option.cc
@@ -59,12 +59,6 @@ TcpOption::GetInstanceTypeId (void) const
   return GetTypeId ();
 }
 
-void
-TcpOption::Print (std::ostream &os) const
-{
-  os << "TCP option kind=" << GetKind() << " size=" << static_cast<int>(GetSerializedSize());
-}
-
 Ptr<TcpOption>
 TcpOption::CreateOption (uint8_t kind)
 {
@@ -82,7 +76,7 @@ TcpOption::CreateOption (uint8_t kind)
     { TcpOption::NOP,       TcpOptionNOP::GetTypeId () },
     { TcpOption::TS,        TcpOptionTS::GetTypeId () },
     { TcpOption::WINSCALE,  TcpOptionWinScale::GetTypeId () },
-    { TcpOption::UNKNOWN,   TcpOptionUnknown::GetTypeId () }
+    { TcpOption::UNKNOWN,  TcpOptionUnknown::GetTypeId () }
   };
 
   for (unsigned int i = 0; i < sizeof (toTid) / sizeof (kindToTid); ++i)
@@ -107,7 +101,6 @@ TcpOption::IsKindKnown (uint8_t kind)
     case MSS:
     case WINSCALE:
     case TS:
-    case MPTCP:
     // Do not add UNKNOWN here
       return true;
     }
@@ -197,17 +190,4 @@ TcpOptionUnknown::GetKind (void) const
   return m_kind;
 }
 
-std::ostream &
-operator << (std::ostream &os, const TcpOption &option)
-{
-  option.Print(os);
-  return os;
-}
-std::ostream&
-operator<< (std::ostream& os, Ptr<const TcpOption> opt)
-{
-  opt->Print (os);
-  return os;
-}
-
 } // namespace ns3
diff --git a/src/internet/model/tcp-option.h b/src/internet/model/tcp-option.h
index b3ebf64..9fed484 100644
--- a/src/internet/model/tcp-option.h
+++ b/src/internet/model/tcp-option.h
@@ -38,15 +38,6 @@ public:
   virtual ~TcpOption ();
 
   /**
-   * \brief Print a TCP header into an output stream
-   *
-   * \param os output stream
-   * \param opt TCP option to print
-   * \return The ostream passed as first argument
-   */
-  friend std::ostream& operator<<(std::ostream& os, Ptr<const TcpOption> opt);
-
-  /**
    * \brief Get the type ID.
    * \return the object TypeId
    */
@@ -66,7 +57,6 @@ public:
     MSS = 2,      //!< MSS
     WINSCALE = 3, //!< WINSCALE
     TS = 8,       //!< TS
-    MPTCP = 30,   //! Multipath TCP options share the same Kind
     UNKNOWN = 255 //!< not a standardized value; for unknown recv'd options
   };
 
@@ -74,7 +64,7 @@ public:
    * \brief Print the Option contents
    * \param os the output stream
    */
-  virtual void Print (std::ostream &os) const;
+  virtual void Print (std::ostream &os) const = 0;
   /**
    * \brief Serialize the Option to a buffer iterator
    * \param start the buffer iterator
@@ -150,11 +140,6 @@ private:
 
 };
 
-std::ostream &
-operator << (std::ostream &os, const TcpOption &option);
-
-
-
 } // namespace ns3
 
 #endif /* TCP_OPTION */
diff --git a/src/internet/model/tcp-rx-buffer.cc b/src/internet/model/tcp-rx-buffer.cc
index a23b5f1..dcc5ad9 100644
--- a/src/internet/model/tcp-rx-buffer.cc
+++ b/src/internet/model/tcp-rx-buffer.cc
@@ -40,12 +40,6 @@ TcpRxBuffer::GetTypeId (void)
                      "Next sequence number expected (RCV.NXT)",
                      MakeTraceSourceAccessor (&TcpRxBuffer::m_nextRxSeq),
                      "ns3::SequenceNumber32TracedValueCallback")
-    .AddTraceSource ("RxTotal",
-                     "Size of all packets in receive buffer ",
-                     MakeTraceSourceAccessor (&TcpRxBuffer::m_size))
-    .AddTraceSource ("RxAvailable",
-                     "Size of all packets in receive buffer ",
-                     MakeTraceSourceAccessor (&TcpRxBuffer::m_availBytes))
   ;
   return tid;
 }
@@ -67,32 +61,6 @@ TcpRxBuffer::~TcpRxBuffer ()
 }
 
 SequenceNumber32
-TcpRxBuffer::HeadSequence(void) const
-{
-  return NextRxSequence()-Available();
-}
-
-void
-TcpRxBuffer::Dump() const
-{
-  std::ostringstream oss;
-  NS_LOG_DEBUG("=== Dumping content of RxBuffer " << this);
-  oss  << "> nextRxSeq=" << m_nextRxSeq << " Occupancy=" << m_size;
-  if (m_gotFin) {
-    oss << " Got Fin [" << m_finSeq << "]; still waiting for [" << m_finSeq - NextRxSequence()<< "] bytes";
-  }
-
-//  NS_LOG_DEBUG("> nextRxSeq=" << m_nextRxSeq << " Occupancy=" << m_size);
-  NS_LOG_DEBUG ( oss.str() );
-  std::map<SequenceNumber32, Ptr<Packet> >::const_iterator i = m_data.begin ();
-  for( ; i != m_data.end (); ++i)
-    {
-      NS_LOG_DEBUG( "head:" << i->first << " of size:" << i->second->GetSize());
-    }
-//  NS_LOG_DEBUG("=== End of dump");
-}
-
-SequenceNumber32
 TcpRxBuffer::NextRxSequence (void) const
 {
   return m_nextRxSeq;
@@ -134,7 +102,7 @@ TcpRxBuffer::IncNextRxSequence ()
   NS_LOG_FUNCTION (this);
   // Increment nextRxSeq is valid only if we don't have any data buffered,
   // this is supposed to be called only during the three-way handshake
-  NS_ASSERT (m_size == (uint32_t)0);
+  NS_ASSERT (m_size == 0);
   m_nextRxSeq++;
 }
 
@@ -160,9 +128,7 @@ TcpRxBuffer::SetFinSequence (const SequenceNumber32& s)
 
   m_gotFin = true;
   m_finSeq = s;
-  if (m_nextRxSeq == m_finSeq) {
-    ++m_nextRxSeq;
-  }
+  if (m_nextRxSeq == m_finSeq) ++m_nextRxSeq;
 }
 
 bool
@@ -171,19 +137,13 @@ TcpRxBuffer::Finished (void)
   return (m_gotFin && m_finSeq < m_nextRxSeq);
 }
 
-//bool
-//TcpRxBuffer::Add (Ptr<Packet> p, TcpHeader const& tcph)
-//{
-//    return Add (p, tcph.GetSequenceNumber());
-//}
-
 bool
-TcpRxBuffer::Add (Ptr<Packet> p,  SequenceNumber32 const& _headSeq)
+TcpRxBuffer::Add (Ptr<Packet> p, TcpHeader const& tcph)
 {
-  NS_LOG_FUNCTION (this << p << _headSeq);
+  NS_LOG_FUNCTION (this << p << tcph);
 
   uint32_t pktSize = p->GetSize ();
-  SequenceNumber32 headSeq = _headSeq;
+  SequenceNumber32 headSeq = tcph.GetSequenceNumber ();
   SequenceNumber32 tailSeq = headSeq + SequenceNumber32 (pktSize);
   NS_LOG_LOGIC ("Add pkt " << p << " len=" << pktSize << " seq=" << headSeq
                            << ", when NextRxSeq=" << m_nextRxSeq << ", buffsize=" << m_size);
@@ -228,7 +188,7 @@ TcpRxBuffer::Add (Ptr<Packet> p,  SequenceNumber32 const& _headSeq)
     }
   else
     {
-      uint32_t start = headSeq - _headSeq;
+      uint32_t start = headSeq - tcph.GetSequenceNumber ();
       uint32_t length = tailSeq - headSeq;
       p = p->CreateFragment (start, length);
       NS_ASSERT (length == p->GetSize ());
@@ -265,7 +225,7 @@ TcpRxBuffer::Extract (uint32_t maxSize)
 {
   NS_LOG_FUNCTION (this << maxSize);
 
-  uint32_t extractSize = std::min (maxSize, m_availBytes.Get());
+  uint32_t extractSize = std::min (maxSize, m_availBytes);
   NS_LOG_LOGIC ("Requested to extract " << extractSize << " bytes from TcpRxBuffer of size=" << m_size);
   if (extractSize == 0) return 0;  // No contiguous block to return
   NS_ASSERT (m_data.size ()); // At least we have something to extract
diff --git a/src/internet/model/tcp-rx-buffer.h b/src/internet/model/tcp-rx-buffer.h
index eac6a2a..48ce046 100644
--- a/src/internet/model/tcp-rx-buffer.h
+++ b/src/internet/model/tcp-rx-buffer.h
@@ -52,18 +52,9 @@ public:
   TcpRxBuffer (uint32_t n = 0);
   virtual ~TcpRxBuffer ();
 
-  /**
-  * \return First in order sequence sumber
-  *
-  **/
-  SequenceNumber32 HeadSequence(void) const;
-
-  void Dump() const;
-
-
   // Accessors
   /**
-   * \brief Get Next in-order Rx Sequence number (RCV.NXT)
+   * \brief Get Next Rx Sequence number
    * \returns Next Rx Sequence number
    */
   SequenceNumber32 NextRxSequence (void) const;
@@ -74,7 +65,6 @@ public:
   SequenceNumber32 MaxRxSequence (void) const;
   /**
    * \brief Increment the Next Sequence number
-   * Valid only during the 3WHS
    */
   void IncNextRxSequence (void);
   /**
@@ -88,12 +78,12 @@ public:
    */
   void SetFinSequence (const SequenceNumber32& s);
   /**
-   * \brief Get the Maximum buffer size (in bytes)
+   * \brief Get the Maximum buffer size
    * \returns the Maximum buffer size
    */
   uint32_t MaxBufferSize (void) const;
   /**
-   * \brief Set the Maximum buffer size (in bytes)
+   * \brief Set the Maximum buffer size
    * \param s the Maximum buffer size
    */
   void SetMaxBufferSize (uint32_t s);
@@ -124,8 +114,7 @@ public:
    * \param tcph packet's TCP header
    * \return True when success, false otherwise.
    */
-//  bool Add (Ptr<Packet> p, TcpHeader const& tcph);
-  bool Add (Ptr<Packet> p,  SequenceNumber32 const& headSeq);
+  bool Add (Ptr<Packet> p, TcpHeader const& tcph);
 
   /**
    * Extract data from the head of the buffer as indicated by nextRxSeq.
@@ -141,9 +130,9 @@ public:
   TracedValue<SequenceNumber32> m_nextRxSeq; //!< Seqnum of the first missing byte in data (RCV.NXT)
   SequenceNumber32 m_finSeq;                 //!< Seqnum of the FIN packet
   bool m_gotFin;                             //!< Did I received FIN packet?
-  TracedValue<uint32_t> m_size;              //!< Number of total data bytes in the buffer, not necessarily contiguous
+  uint32_t m_size;                           //!< Number of total data bytes in the buffer, not necessarily contiguous
   uint32_t m_maxBuffer;                      //!< Upper bound of the number of data bytes in buffer (RCV.WND)
-  TracedValue<uint32_t> m_availBytes;        //!< Number of bytes available to read, i.e. contiguous block at head
+  uint32_t m_availBytes;                     //!< Number of bytes available to read, i.e. contiguous block at head
   std::map<SequenceNumber32, Ptr<Packet> > m_data; //!< Corresponding data (may be null)
 };
 
diff --git a/src/internet/model/tcp-socket-base.cc b/src/internet/model/tcp-socket-base.cc
index a156fe3..e5a402c 100644
--- a/src/internet/model/tcp-socket-base.cc
+++ b/src/internet/model/tcp-socket-base.cc
@@ -41,7 +41,6 @@
 #include "ns3/double.h"
 #include "ns3/pointer.h"
 #include "ns3/trace-source-accessor.h"
-#include "ns3/tcp-trace-helper.h"
 #include "tcp-socket-base.h"
 #include "tcp-l4-protocol.h"
 #include "ipv4-end-point.h"
@@ -51,10 +50,6 @@
 #include "tcp-option-winscale.h"
 #include "tcp-option-ts.h"
 #include "rtt-estimator.h"
-#include "mptcp-crypto.h"
-#include "mptcp-subflow.h"
-#include "mptcp-socket-base.h"
-#include "tcp-option-mptcp.h"
 
 #include <math.h>
 #include <algorithm>
@@ -65,16 +60,6 @@ NS_LOG_COMPONENT_DEFINE ("TcpSocketBase");
 
 NS_OBJECT_ENSURE_REGISTERED (TcpSocketBase);
 
-
-
-void 
-DumpSocketState (std::ostream& os, Ptr<TcpSocketState> tcb )
-{
-  os << "CWND=" << tcb->m_cWnd << " SSTHRESH=" << tcb->m_ssThresh << std::endl
-    << "ack fsm in state [" << tcb->m_ackState << "]"
-    ;
-}
-
 TypeId
 TcpSocketBase::GetTypeId (void)
 {
@@ -96,17 +81,6 @@ TcpSocketBase::GetTypeId (void)
                    UintegerValue (65535),
                    MakeUintegerAccessor (&TcpSocketBase::m_maxWinSize),
                    MakeUintegerChecker<uint16_t> ())
-    .AddAttribute ("NullISN",
-                   "Set to false if you want to enable random isn",
-                   BooleanValue (true),
-            //      MakeBooleanAccessor (&TcpSocketBase::SetQosSupported,&RegularWifiMac::GetQosSupported)
-                   MakeBooleanAccessor (&TcpSocketBase::m_nullIsn),
-                   MakeBooleanChecker ())
-    .AddAttribute ("EnableMpTcp",
-                   "Enable or disable MPTCP support",
-                   BooleanValue (false),
-                   MakeBooleanAccessor (&TcpSocketBase::m_mptcpEnabled),
-                   MakeBooleanChecker ())
     .AddAttribute ("IcmpCallback", "Callback invoked whenever an icmp error is received on this socket.",
                    CallbackValue (),
                    MakeCallbackAccessor (&TcpSocketBase::m_icmpCallback),
@@ -116,15 +90,11 @@ TcpSocketBase::GetTypeId (void)
                    MakeCallbackAccessor (&TcpSocketBase::m_icmpCallback6),
                    MakeCallbackChecker ())
     .AddAttribute ("WindowScaling", "Enable or disable Window Scaling option",
-                   BooleanValue (false),
+                   BooleanValue (true),
                    MakeBooleanAccessor (&TcpSocketBase::m_winScalingEnabled),
                    MakeBooleanChecker ())
-    .AddAttribute ("NoDelay", "Enable or disable Nagle algorithm",
-                   BooleanValue (false),
-                   MakeBooleanAccessor (&TcpSocketBase::GetTcpNoDelay,&TcpSocketBase::SetTcpNoDelay),
-                   MakeBooleanChecker ())
     .AddAttribute ("Timestamp", "Enable or disable Timestamp option",
-                   BooleanValue (false),
+                   BooleanValue (true),
                    MakeBooleanAccessor (&TcpSocketBase::m_timestampEnabled),
                    MakeBooleanChecker ())
     .AddAttribute ("MinRto",
@@ -154,7 +124,7 @@ TcpSocketBase::GetTypeId (void)
                     MakeUintegerAccessor (&TcpSocketBase::m_retxThresh),
                     MakeUintegerChecker<uint32_t> ())
     .AddAttribute ("LimitedTransmit", "Enable limited transmit",
-                   BooleanValue (false),
+                   BooleanValue (true),
                    MakeBooleanAccessor (&TcpSocketBase::m_limitedTx),
                    MakeBooleanChecker ())
     .AddTraceSource ("RTO",
@@ -185,7 +155,6 @@ TcpSocketBase::GetTypeId (void)
                      "Remote side's flow control window",
                      MakeTraceSourceAccessor (&TcpSocketBase::m_rWnd),
                      "ns3::TracedValue::Uint32Callback")
-    // This is strange since zis is decorellated from rxBuffer->NextRxSequence
     .AddTraceSource ("HighestRxSequence",
                      "Highest sequence number received from peer",
                      MakeTraceSourceAccessor (&TcpSocketBase::m_highRxMark),
@@ -202,22 +171,11 @@ TcpSocketBase::GetTypeId (void)
                      "TCP slow start threshold (bytes)",
                      MakeTraceSourceAccessor (&TcpSocketBase::m_ssThTrace),
                      "ns3::TracedValue::Uint32Callback")
-    .AddTraceSource("UnackSequence",
-                    "First unacknowledged sequence number (SND.UNA)",
-                    MakeTraceSourceAccessor(&TcpSocketBase::m_firstTxUnack),
-                    "ns3::SequenceNumber32TracedValueCallback")
-
   ;
   return tid;
 }
 
-TypeId
-TcpSocketBase::GetInstanceTypeId() const
-{
-    return TcpSocketBase::GetTypeId();
-}
-
-
+// TcpSocketState
 TypeId
 TcpSocketState::GetTypeId (void)
 {
@@ -269,126 +227,14 @@ TcpSocketState::TcpAckStateName[TcpSocketState::LAST_ACKSTATE] =
   "OPEN", "DISORDER", "CWR", "RECOVERY", "LOSS"
 };
 
-
-TcpSocketBase& 
-TcpSocketBase::operator=(const TcpSocketBase& sock)
-{
-  Socket::operator=(sock);
-  m_delAckCount = 0;
-  m_endPoint = 0;
-  m_endPoint6 = 0;
-//  m_rtt = 0;
-
-  m_dupAckCount = sock.m_dupAckCount;
-  m_delAckMaxCount = sock.m_delAckMaxCount;
-  m_noDelay = sock.m_noDelay;
-  m_cnRetries = sock.m_cnRetries;
-  m_delAckTimeout = sock.m_delAckTimeout;
-  m_persistTimeout = sock.m_persistTimeout;
-  m_cnTimeout = sock.m_cnTimeout;
-
-  m_node = sock.m_node;
-  m_tcp = sock.m_tcp;
-
-  m_firstTxUnack= sock.m_firstTxUnack;
-  m_nextTxSequence = sock.m_nextTxSequence;
-  m_highTxMark = sock.m_highTxMark;
-  m_state = sock.m_state;
-  m_errno = sock.m_errno;
-  m_closeNotified = sock.m_closeNotified;
-  m_closeOnEmpty = sock.m_closeOnEmpty;
-  m_shutdownSend = sock.m_shutdownSend;
-  m_shutdownRecv = sock.m_shutdownRecv;
-  m_connected = sock.m_connected;
-  m_msl = sock.m_msl;
-  m_maxWinSize = sock.m_maxWinSize;
-  m_rWnd = sock.m_rWnd;
-  m_highRxMark = sock.m_highRxMark;
-  m_highRxAckMark = sock.m_highRxAckMark;
-  m_bytesAckedNotProcessed= 0;
-  m_nullIsn= sock.m_nullIsn;
-  m_localISN= sock.m_localISN;
-  m_peerISN= sock.m_peerISN;
-  m_mptcpEnabled = sock.m_mptcpEnabled;
-  m_mptcpLocalKey = sock.m_mptcpLocalKey;
-  m_mptcpLocalToken = sock.m_mptcpLocalToken;
-  m_winScalingEnabled = sock.m_winScalingEnabled;
-  m_sndScaleFactor = sock.m_sndScaleFactor;
-  m_rcvScaleFactor = sock.m_rcvScaleFactor;
-  m_timestampEnabled = sock.m_timestampEnabled;
-  m_timestampToEcho = sock.m_timestampToEcho;
-  m_retxThresh = sock.m_retxThresh;
-  m_limitedTx = sock.m_limitedTx;
-  m_lostOut = sock.m_lostOut;
-  m_retransOut =sock.m_retransOut;
-
-  m_txBuffer = CopyObject (sock.m_txBuffer);
-  m_rxBuffer = CopyObject (sock.m_rxBuffer);
-
-  if (sock.m_rtt)
-    {
-      m_rtt = sock.m_rtt->Copy ();
-    }
-    
-  // TODO  there should be a way to prevent this from happening when looking to upgrade
-  // TCP socket into an MPTCP one ?
-  // Reset all callbacks to null
-//  ResetUserCallbacks ();
-
-  m_txBuffer = CopyObject (sock.m_txBuffer);
-  m_rxBuffer = CopyObject (sock.m_rxBuffer);
-  
-  // MATT HACK to get around TcpSocketState limitations and let TcpCongestionOps 
-  // get access to MPTCP subflows
-  // 
-  m_tcb = CopyObject (sock.m_tcb);
-  
-  // TODO remove 
-  m_tcb->m_socket = this;
-  
-  if (sock.m_congestionControl)
-    {
-      m_congestionControl = sock.m_congestionControl->Fork ();
-    }
-
-  // MATT HACK to get around TcpSocketState limitations and let TcpCongestionOps 
-  // get access to MPTCP subflows
-  // 
-//  m_tcb = CopyObject (sock.m_tcb);
-//  m_tcb->m_socket = this;
-//  
-//  if (sock.m_congestionControl)
-//    {
-//      m_congestionControl = sock.m_congestionControl->Fork ();
-//    }
-//
-//  bool ok;
-//
-//  ok = m_tcb->TraceConnectWithoutContext ("CongestionWindow",
-//                                          MakeCallback (&TcpSocketBase::UpdateCwnd, this));
-//  NS_ASSERT (ok == true);
-//
-//  ok = m_tcb->TraceConnectWithoutContext ("SlowStartThreshold",
-//                                          MakeCallback (&TcpSocketBase::UpdateSsThresh, this));
-//  NS_ASSERT (ok == true);
-//
-//  ok = m_tcb->TraceConnectWithoutContext ("AckState",
-//                                          MakeCallback (&TcpSocketBase::UpdateAckState, this));
-//  NS_ASSERT (ok == true);
-  return *this;
-}
-
 TcpSocketBase::TcpSocketBase (void)
-  :
-    TcpSocket(),
-    m_dupAckCount (0),
+  : m_dupAckCount (0),
     m_delAckCount (0),
     m_endPoint (0),
     m_endPoint6 (0),
     m_node (0),
     m_tcp (0),
     m_rtt (0),
-    m_firstTxUnack(0),
     m_nextTxSequence (0),
     // Change this for non-zero initial sequence number
     m_highTxMark (0),
@@ -405,14 +251,6 @@ TcpSocketBase::TcpSocketBase (void)
     m_rWnd (0),
     m_highRxMark (0),
     m_highRxAckMark (0),
-    m_bytesAckedNotProcessed(0),
-    m_nullIsn(true),
-    m_localISN(0),
-    m_peerISN(0),
-    m_mptcpEnabled(false),
-    m_mptcpLocalKey (0),
-    m_mptcpLocalToken(0),
-    m_winScalingEnabled(false),
     m_sndScaleFactor (0),
     m_rcvScaleFactor (0),
     m_timestampEnabled (true),
@@ -429,9 +267,6 @@ TcpSocketBase::TcpSocketBase (void)
   m_txBuffer = CreateObject<TcpTxBuffer> ();
   m_tcb      = CreateObject<TcpSocketState> ();
 
-  // HACK MATT, no need anymore, remove
-  m_tcb->m_socket = this;
-  
   bool ok;
 
   ok = m_tcb->TraceConnectWithoutContext ("CongestionWindow",
@@ -463,7 +298,6 @@ TcpSocketBase::TcpSocketBase (const TcpSocketBase& sock)
     m_node (sock.m_node),
     m_tcp (sock.m_tcp),
     m_rtt (0),
-    m_firstTxUnack(sock.m_firstTxUnack),
     m_nextTxSequence (sock.m_nextTxSequence),
     m_highTxMark (sock.m_highTxMark),
     m_state (sock.m_state),
@@ -478,13 +312,6 @@ TcpSocketBase::TcpSocketBase (const TcpSocketBase& sock)
     m_rWnd (sock.m_rWnd),
     m_highRxMark (sock.m_highRxMark),
     m_highRxAckMark (sock.m_highRxAckMark),
-    m_bytesAckedNotProcessed(0),
-    m_nullIsn(sock.m_nullIsn),
-    m_localISN(sock.m_localISN),
-    m_peerISN(sock.m_peerISN),
-    m_mptcpEnabled (sock.m_mptcpEnabled),
-    m_mptcpLocalKey (sock.m_mptcpLocalKey),
-    m_mptcpLocalToken (sock.m_mptcpLocalToken),
     m_winScalingEnabled (sock.m_winScalingEnabled),
     m_sndScaleFactor (sock.m_sndScaleFactor),
     m_rcvScaleFactor (sock.m_rcvScaleFactor),
@@ -502,23 +329,17 @@ TcpSocketBase::TcpSocketBase (const TcpSocketBase& sock)
     {
       m_rtt = sock.m_rtt->Copy ();
     }
-    
-  // TODO  there should be a way to prevent this from happening when looking to upgrade
-  // TCP socket into an MPTCP one ?
   // Reset all callbacks to null
-//  ResetUserCallbacks ();
-
+  Callback<void, Ptr< Socket > > vPS = MakeNullCallback<void, Ptr<Socket> > ();
+  Callback<void, Ptr<Socket>, const Address &> vPSA = MakeNullCallback<void, Ptr<Socket>, const Address &> ();
+  Callback<void, Ptr<Socket>, uint32_t> vPSUI = MakeNullCallback<void, Ptr<Socket>, uint32_t> ();
+  SetConnectCallback (vPS, vPS);
+  SetDataSentCallback (vPSUI);
+  SetSendCallback (vPSUI);
+  SetRecvCallback (vPS);
   m_txBuffer = CopyObject (sock.m_txBuffer);
   m_rxBuffer = CopyObject (sock.m_rxBuffer);
-  
-  // MATT HACK to get around TcpSocketState limitations and let TcpCongestionOps 
-  // get access to MPTCP subflows
-  // 
   m_tcb = CopyObject (sock.m_tcb);
-  
-  // TODO remove 
-  m_tcb->m_socket = this;
-  
   if (sock.m_congestionControl)
     {
       m_congestionControl = sock.m_congestionControl->Fork ();
@@ -568,21 +389,6 @@ TcpSocketBase::~TcpSocketBase (void)
   CancelAllTimers ();
 }
 
-
-/* Associate a node with this TCP socket */
-void
-TcpSocketBase::ResetUserCallbacks (void)
-{
-
-  Callback<void, Ptr< Socket > > vPS = MakeNullCallback<void, Ptr<Socket> > ();
-  Callback<void, Ptr<Socket>, const Address &> vPSA = MakeNullCallback<void, Ptr<Socket>, const Address &> ();
-  Callback<void, Ptr<Socket>, uint32_t> vPSUI = MakeNullCallback<void, Ptr<Socket>, uint32_t> ();
-  SetConnectCallback (vPS, vPS);
-  SetDataSentCallback (vPSUI);
-  SetSendCallback (vPSUI);
-  SetRecvCallback (vPS);
-}
-
 /* Associate a node with this TCP socket */
 void
 TcpSocketBase::SetNode (Ptr<Node> node)
@@ -626,12 +432,6 @@ TcpSocketBase::GetNode (void) const
   return m_node;
 }
 
-SequenceNumber32
-TcpSocketBase::FirstUnackedSeq() const
-{
-  return m_firstTxUnack.Get();
-}
-
 /* Inherit from Socket class: Bind socket to an end-point in TcpL4Protocol */
 int
 TcpSocketBase::Bind (void)
@@ -665,40 +465,15 @@ TcpSocketBase::Bind6 (void)
   return SetupCallback ();
 }
 
-Ptr<NetDevice>
-TcpSocketBase::MapIpToInterface(Ipv4Address addr) const
-{
-    NS_LOG_DEBUG(addr);
-      Ptr<Ipv4> ipv4client = m_node->GetObject<Ipv4>();
-      for( uint32_t n =0; n < ipv4client->GetNInterfaces(); n++){
-        for( uint32_t a=0; a < ipv4client->GetNAddresses(n); a++){
-            NS_LOG_UNCOND( "Client addr " << n <<"/" << a << "=" << ipv4client->GetAddress(n,a));
-            if(addr ==ipv4client->GetAddress(n,a).GetLocal()) {
-                NS_LOG_UNCOND("EUREKA same ip=" << addr);
-                // That function is buggy
-//                BindToNetDevice();
-                return m_node->GetDevice(n);
-//                m_endPoint->BindToNetDevice();
-////                m_boundnetdevice = m_endPoint->GetBoundNetDevice();
-//                break;
-            }
-        }
-      }
-    return 0;
-}
-
 /* Inherit from Socket class: Bind socket (with specific address) to an end-point in TcpL4Protocol */
 int
 TcpSocketBase::Bind (const Address &address)
 {
   NS_LOG_FUNCTION (this << address);
-
   if (InetSocketAddress::IsMatchingType (address))
     {
-
       InetSocketAddress transport = InetSocketAddress::ConvertFrom (address);
       Ipv4Address ipv4 = transport.GetIpv4 ();
-      NS_LOG_DEBUG(ipv4 );
       uint16_t port = transport.GetPort ();
       if (ipv4 == Ipv4Address::GetAny () && port == 0)
         {
@@ -716,41 +491,11 @@ TcpSocketBase::Bind (const Address &address)
         {
           m_endPoint = m_tcp->Allocate (ipv4, port);
         }
-
-      NS_LOG_UNCOND("TATA" );
       if (0 == m_endPoint)
         {
           m_errno = port ? ERROR_ADDRINUSE : ERROR_ADDRNOTAVAIL;
           return -1;
         }
-
-      Ptr<NetDevice> dev = MapIpToInterface(m_endPoint->GetLocalAddress());
-
-      if(dev) {
-                m_endPoint->BindToNetDevice(dev);
-                m_boundnetdevice = m_endPoint->GetBoundNetDevice();
-      }
-      #if 0
-      Ptr<Ipv4> ipv4client = m_node->GetObject<Ipv4>();
-      for( uint32_t n =0; n < ipv4client->GetNInterfaces(); n++){
-        for( uint32_t a=0; a < ipv4client->GetNAddresses(n); a++){
-            NS_LOG_UNCOND( "Client addr " << n <<"/" << a << "=" << ipv4client->GetAddress(n,a));
-            if(m_endPoint->GetLocalAddress() ==ipv4client->GetAddress(n,a).GetLocal()) {
-                NS_LOG_UNCOND("EUREKA same ip=" << m_endPoint->GetLocalAddress());
-                // That function is buggy
-//                BindToNetDevice();
-                m_endPoint->BindToNetDevice(m_node->GetDevice(n));
-//                m_boundnetdevice = m_node->GetDevice(n);
-                m_boundnetdevice = m_endPoint->GetBoundNetDevice();
-                break;
-            }
-        }
-      }
-      #endif
-      NS_LOG_UNCOND("BOUND NETDEV=" << m_boundnetdevice );
-//      BindToNetDevice(
-//      m_endPoint->GetBoundNetDevice();
-
     }
   else if (Inet6SocketAddress::IsMatchingType (address))
     {
@@ -788,7 +533,6 @@ TcpSocketBase::Bind (const Address &address)
   m_tcp->AddSocket(this);
 
   NS_LOG_LOGIC ("TcpSocketBase " << this << " got an endpoint: " << m_endPoint);
-  m_endPoint->Print(std::cout);
 
   return SetupCallback ();
 }
@@ -796,14 +540,14 @@ TcpSocketBase::Bind (const Address &address)
 void
 TcpSocketBase::InitializeCwnd (void)
 {
-  m_tcb->m_cWnd = GetInitialCwnd() * GetSegSize();
-  m_tcb->m_ssThresh = GetInitialSSThresh();
+  m_tcb->m_cWnd = m_tcb->m_initialCWnd * m_tcb->m_segmentSize;
+  m_tcb->m_ssThresh = m_tcb->m_initialSsThresh;
 }
 
 void
 TcpSocketBase::SetInitialSSThresh (uint32_t threshold)
 {
-  NS_ABORT_MSG_UNLESS ( (m_state == CLOSED) || threshold == m_tcb->m_initialSsThresh,
+  NS_ABORT_MSG_UNLESS (m_state == CLOSED,
     "TcpSocketBase::SetSSThresh() cannot change initial ssThresh after connection started.");
 
   m_tcb->m_initialSsThresh = threshold;
@@ -818,7 +562,7 @@ TcpSocketBase::GetInitialSSThresh (void) const
 void
 TcpSocketBase::SetInitialCwnd (uint32_t cwnd)
 {
-  NS_ABORT_MSG_UNLESS ( (m_state == CLOSED) || cwnd == m_tcb->m_initialCWnd,
+  NS_ABORT_MSG_UNLESS (m_state == CLOSED,
     "TcpSocketBase::SetInitialCwnd() cannot change initial cwnd after connection started.");
 
   m_tcb->m_initialCWnd = cwnd;
@@ -843,7 +587,6 @@ TcpSocketBase::Connect (const Address & address)
   NS_LOG_FUNCTION (this << address);
 
   InitializeCwnd ();
-  GenerateUniqueMpTcpKey();
 
   // If haven't do so, Bind() this socket first
   if (InetSocketAddress::IsMatchingType (address) && m_endPoint6 == 0)
@@ -863,8 +606,7 @@ TcpSocketBase::Connect (const Address & address)
 
       // Get the appropriate local address and port number from the routing protocol and set up endpoint
       if (SetupEndpoint () != 0)
-        {
-          NS_LOG_ERROR("Route to destination does not exist ?!");
+        { // Route to destination does not exist
           return -1;
         }
     }
@@ -908,9 +650,6 @@ TcpSocketBase::Connect (const Address & address)
   m_rtt->Reset ();
   m_cnCount = m_cnRetries;
 
-  // TODO remove regenerate ISN
-//   InitLocalISN();
-
   // DoConnect() will do state-checking and send a SYN packet
   return DoConnect ();
 }
@@ -939,7 +678,7 @@ TcpSocketBase::Listen (void)
 int
 TcpSocketBase::Close (void)
 {
-  NS_LOG_FUNCTION (this << TcpStateName[m_state]);
+  NS_LOG_FUNCTION (this);
   /// \internal
   /// First we check to see if there is any unread rx data.
   /// \bugid{426} claims we should send reset in this case.
@@ -949,18 +688,13 @@ TcpSocketBase::Close (void)
       SendRST ();
       return 0;
     }
-
-  uint32_t unackedTx = m_txBuffer->SizeFromSequence (m_nextTxSequence);
-  
-  NS_LOG_DEBUG (unackedTx << " more bytes to send");
-  if (unackedTx > 0)
-    { 
-//      NS_LOG_DEBUG ("");
-      // App close with pending data must wait until all data transmitted
+ 
+  if (m_txBuffer->SizeFromSequence (m_nextTxSequence) > 0)
+    { // App close with pending data must wait until all data transmitted
       if (m_closeOnEmpty == false)
         {
           m_closeOnEmpty = true;
-          NS_LOG_INFO ("Socket " << this << " deferring close to send " << unackedTx << " more bytes, state " << TcpStateName[m_state]);
+          NS_LOG_INFO ("Socket " << this << " deferring close, state " << TcpStateName[m_state]);
         }
       return 0;
     }
@@ -972,7 +706,7 @@ int
 TcpSocketBase::ShutdownSend (void)
 {
   NS_LOG_FUNCTION (this);
-
+  
   //this prevents data from being added to the buffer
   m_shutdownSend = true;
   m_closeOnEmpty = true;
@@ -983,7 +717,7 @@ TcpSocketBase::ShutdownSend (void)
       if (m_state == ESTABLISHED || m_state == CLOSE_WAIT)
         {
           NS_LOG_INFO("Emtpy tx buffer, send fin");
-          SendEmptyPacket (TcpHeader::FIN);
+          SendEmptyPacket (TcpHeader::FIN);  
 
           if (m_state == ESTABLISHED)
             { // On active close: I am the first one to send FIN
@@ -994,10 +728,10 @@ TcpSocketBase::ShutdownSend (void)
             { // On passive close: Peer sent me FIN already
               NS_LOG_INFO ("CLOSE_WAIT -> LAST_ACK");
               m_state = LAST_ACK;
-            }
+            }  
         }
     }
-
+ 
   return 0;
 }
 
@@ -1039,7 +773,6 @@ TcpSocketBase::Send (Ptr<Packet> p, uint32_t flags)
               m_sendPendingDataEvent = Simulator::Schedule ( TimeStep (1), &TcpSocketBase::SendPendingData, this, m_connected);
             }
         }
-      // This does not match the return type uint32_t != int
       return p->GetSize ();
     }
   else
@@ -1161,9 +894,10 @@ TcpSocketBase::BindToNetDevice (Ptr<NetDevice> netdevice)
           return;
         }
       NS_ASSERT (m_endPoint != 0);
-      m_endPoint->BindToNetDevice (netdevice);
     }
-  else if (m_endPoint6 == 0)
+  m_endPoint->BindToNetDevice (netdevice);
+
+  if (m_endPoint6 == 0)
     {
       if (Bind6 () == -1)
         {
@@ -1171,11 +905,8 @@ TcpSocketBase::BindToNetDevice (Ptr<NetDevice> netdevice)
           return;
         }
       NS_ASSERT (m_endPoint6 != 0);
-      m_endPoint6->BindToNetDevice (netdevice);
     }
-  else {
-    NS_FATAL_ERROR("What the hell happened ?");
-  }
+  m_endPoint6->BindToNetDevice (netdevice);
 
   return;
 }
@@ -1196,7 +927,7 @@ TcpSocketBase::SetupCallback (void)
       m_endPoint->SetIcmpCallback (MakeCallback (&TcpSocketBase::ForwardIcmp, Ptr<TcpSocketBase> (this)));
       m_endPoint->SetDestroyCallback (MakeCallback (&TcpSocketBase::Destroy, Ptr<TcpSocketBase> (this)));
     }
-  else if (m_endPoint6 != 0)
+  if (m_endPoint6 != 0)
     {
       m_endPoint6->SetRxCallback (MakeCallback (&TcpSocketBase::ForwardUp6, Ptr<TcpSocketBase> (this)));
       m_endPoint6->SetIcmpCallback (MakeCallback (&TcpSocketBase::ForwardIcmp6, Ptr<TcpSocketBase> (this)));
@@ -1285,7 +1016,7 @@ TcpSocketBase::CloseAndNotify (void)
 
   NS_LOG_INFO (TcpStateName[m_state] << " -> CLOSED");
   m_state = CLOSED;
-  DeallocateEndPoint ();
+  DeallocateEndPoint ();  
 }
 
 
@@ -1383,18 +1114,8 @@ TcpSocketBase::DoForwardUp (Ptr<Packet> packet, const Address &fromAddress,
       NS_LOG_ERROR ("Bytes removed: " << bytesRemoved << " invalid");
       return; // Discard invalid packet
     }
-    
-
-   m_receivedHeader = tcpHeader;
-   // We should call a function that does validity cheking here and that could be 
-   // overriden by MPTCP meta
-   // Might cause pb when meta is not set
 
-//  NS_LOG_UNCOND("TOTO=" << packet->GetSize ());
-    // TODO bad idea to put it here.
-    // should first check that packet is in range
-    // + processing should be state dependant
-//  ReadOptions (tcpHeader);
+  ReadOptions (tcpHeader);
 
   if (tcpHeader.GetFlags () & TcpHeader::ACK)
     {
@@ -1419,12 +1140,11 @@ TcpSocketBase::DoForwardUp (Ptr<Packet> packet, const Address &fromAddress,
     }
 
   // Update Rx window size, i.e. the flow control window
-  if (GetRwnd () == 0 && tcpHeader.GetWindowSize () != 0 && m_persistEvent.IsRunning ())
+  if (m_rWnd.Get () == 0 && tcpHeader.GetWindowSize () != 0 && m_persistEvent.IsRunning ())
     { // persist probes end
       NS_LOG_LOGIC (this << " Leaving zerowindow persist state");
       m_persistEvent.Cancel ();
     }
-
   if (tcpHeader.GetFlags () & TcpHeader::ACK)
     {
       UpdateWindowSize (tcpHeader);
@@ -1448,16 +1168,14 @@ TcpSocketBase::DoForwardUp (Ptr<Packet> packet, const Address &fromAddress,
       if ((tcpHeader.GetFlags () & ~(TcpHeader::PSH | TcpHeader::URG)) != TcpHeader::RST)
         { // Since m_endPoint is not configured yet, we cannot use SendRST here
           TcpHeader h;
-          GenerateEmptyPacketHeader(h, TcpHeader::RST);
-//          h.SetSequenceNumber (m_nextTxSequence);
-//          h.SetAckNumber (m_rxBuffer->NextRxSequence ());
+          h.SetFlags (TcpHeader::RST);
+          h.SetSequenceNumber (m_nextTxSequence);
+          h.SetAckNumber (m_rxBuffer->NextRxSequence ());
           h.SetSourcePort (tcpHeader.GetDestinationPort ());
           h.SetDestinationPort (tcpHeader.GetSourcePort ());
-//          h.SetWindowSize (AdvertisedWindowSize ());
-          // Do we really need that in a RST ?
-//          AddOptions (h);
-          SendPacket(h, Create<Packet> ());
-//          m_tcp->SendPacket (Create<Packet> (), h, toAddress, fromAddress, m_boundnetdevice);
+          h.SetWindowSize (AdvertisedWindowSize ());
+          AddOptions (h);
+          m_tcp->SendPacket (Create<Packet> (), h, toAddress, fromAddress, m_boundnetdevice);
         }
       break;
     case SYN_SENT:
@@ -1495,8 +1213,7 @@ TcpSocketBase::ProcessEstablished (Ptr<Packet> packet, const TcpHeader& tcpHeade
   // Different flags are different events
   if (tcpflags == TcpHeader::ACK)
     {
-      ProcessTcpOptions(tcpHeader);
-      if (tcpHeader.GetAckNumber () < FirstUnackedSeq())
+      if (tcpHeader.GetAckNumber () < m_txBuffer->HeadSequence ())
         {
           // Case 1:  If the ACK is a duplicate (SEG.ACK < SND.UNA), it can be ignored.
           // Pag. 72 RFC 793
@@ -1534,7 +1251,6 @@ TcpSocketBase::ProcessEstablished (Ptr<Packet> packet, const TcpHeader& tcpHeade
     }
   else if (tcpflags == 0)
     { // No flags means there is only data
-      ProcessTcpOptions(tcpHeader);
       ReceivedData (packet, tcpHeader);
       if (m_rxBuffer->Finished ())
         {
@@ -1552,33 +1268,16 @@ TcpSocketBase::ProcessEstablished (Ptr<Packet> packet, const TcpHeader& tcpHeade
     }
 }
 
-
-// TODO this function should be removed
-void
-TcpSocketBase::ReceivedAck (Ptr<Packet> packet,
-                            const TcpHeader& tcpHeader
-                            )
-{
-  // If there is any data piggybacked, store it into m_rxBuffer
-  NS_LOG_FUNCTION(this << packet << tcpHeader);
-  NS_ASSERT (0 != (tcpHeader.GetFlags () & TcpHeader::ACK));
-  ReceivedAck(tcpHeader.GetAckNumber());
-  if (packet->GetSize () > 0)
-    {
-      ReceivedData (packet, tcpHeader);
-    }
-}
-
 /* Process the newly received ACK */
 void
-TcpSocketBase::ReceivedAck (SequenceNumber32 ack)
+TcpSocketBase::ReceivedAck (Ptr<Packet> packet, const TcpHeader& tcpHeader)
 {
-  NS_LOG_FUNCTION (this << ack);
+  NS_LOG_FUNCTION (this << tcpHeader);
 
+  NS_ASSERT (0 != (tcpHeader.GetFlags () & TcpHeader::ACK));
   NS_ASSERT (m_tcb->m_segmentSize > 0);
-//  SequenceNumber32 ack = tcpHeader.GetAckNumber ();
 
-  uint32_t bytesAcked = ack - FirstUnackedSeq();
+  uint32_t bytesAcked = tcpHeader.GetAckNumber () - m_txBuffer->HeadSequence ();
   uint32_t segsAcked  = bytesAcked / m_tcb->m_segmentSize;
   m_bytesAckedNotProcessed += bytesAcked % m_tcb->m_segmentSize;
 
@@ -1591,8 +1290,8 @@ TcpSocketBase::ReceivedAck (SequenceNumber32 ack)
   NS_LOG_LOGIC ("Segments acked: " << segsAcked <<
                 " bytes left: " << m_bytesAckedNotProcessed);
 
-  if (ack == FirstUnackedSeq() &&
-      ack < m_nextTxSequence)
+  if (tcpHeader.GetAckNumber () == m_txBuffer->HeadSequence () &&
+      tcpHeader.GetAckNumber () < m_nextTxSequence)
     {
       // There is a DupAck
       ++m_dupAckCount;
@@ -1610,14 +1309,10 @@ TcpSocketBase::ReceivedAck (SequenceNumber32 ack)
             {
               // RFC3042 Limited transmit: Send a new packet for each duplicated ACK before fast retransmit
               NS_LOG_INFO ("Limited transmit");
-              NS_LOG_UNCOND("Limited transmit removed");
-              uint32_t sz = 0;
-//              uint32_t sz = SendDataPacket (m_nextTxSequence, GetSegSize(), true);
+              uint32_t sz = SendDataPacket (m_nextTxSequence, m_tcb->m_segmentSize, true);
               m_nextTxSequence += sz;
             }
-          // origina l version is ==
           else if (m_dupAckCount == m_retxThresh)
-//          else if (m_dupAckCount >= m_retxThresh)
             {
               // triple duplicate ack triggers fast retransmit (RFC2582 sec.3 bullet #1)
               uint32_t oldSsThresh = m_tcb->m_ssThresh;
@@ -1638,8 +1333,7 @@ TcpSocketBase::ReceivedAck (SequenceNumber32 ack)
             }
           else
             {
-                NS_LOG_UNCOND("m_retxThresh=" << m_retxThresh << " m_dupAckCount=" << m_dupAckCount);
-//              NS_FATAL_ERROR ("m_dupAckCount > m_retxThresh and we still are in DISORDER state");
+              NS_FATAL_ERROR ("m_dupAckCount > m_retxThresh and we still are in DISORDER state");
             }
         }
       else if (m_tcb->m_ackState == TcpSocketState::RECOVERY)
@@ -1652,19 +1346,19 @@ TcpSocketBase::ReceivedAck (SequenceNumber32 ack)
         }
       else if (m_tcb->m_ackState == TcpSocketState::LOSS)
         {
-          // What happens if we are in loss state and a DUPack is received?
+          // What happen if we are in loss state and a DUPack is received?
         }
 
       m_congestionControl->PktsAcked (m_tcb, 1, m_lastRtt);
     }
-  else if (ack == FirstUnackedSeq() &&
-           ack == m_nextTxSequence)
+  else if (tcpHeader.GetAckNumber () == m_txBuffer->HeadSequence () &&
+           tcpHeader.GetAckNumber () == m_nextTxSequence)
     {
       // Dupack, but the ACK is precisely equal to the nextTxSequence
     }
-  else if (ack > FirstUnackedSeq())
+  else if (tcpHeader.GetAckNumber () > m_txBuffer->HeadSequence ())
     { // Case 3: New ACK, reset m_dupAckCount and update m_txBuffer
-      NS_LOG_LOGIC ("New ack of " << ack);
+      NS_LOG_LOGIC ("New ack of " << tcpHeader.GetAckNumber ());
 
       if (m_tcb->m_ackState == TcpSocketState::DISORDER)
         {
@@ -1675,20 +1369,19 @@ TcpSocketBase::ReceivedAck (SequenceNumber32 ack)
         }
       else if (m_tcb->m_ackState == TcpSocketState::RECOVERY)
         {
-          if (ack < m_recover)
+          if (tcpHeader.GetAckNumber () < m_recover)
             {
-              NS_LOG_INFO ("Partial ACK for seq " << ack << " in fast recovery");
-              m_firstTxUnack = ack;
-              UpdateTxBuffer();  //Bug 1850:  retransmit before newack
+              NS_LOG_INFO ("Partial ACK for seq " << tcpHeader.GetAckNumber () << " in fast recovery");
+              m_txBuffer->DiscardUpTo(tcpHeader.GetAckNumber ());  //Bug 1850:  retransmit before newack
               m_retransOut--;
               DoRetransmit (); // Assume the next seq is lost. Retransmit lost packet
             }
-          else if (ack >= m_recover)
+          else if (tcpHeader.GetAckNumber () >= m_recover)
             {
               m_tcb->m_ackState = TcpSocketState::OPEN;
               m_retransOut = 0;
               m_lostOut = 0;
-              NS_LOG_INFO ("Received full ACK for seq " << ack <<". Leaving fast recovery with cwnd set to " << m_tcb->m_cWnd);
+              NS_LOG_INFO ("Received full ACK for seq " << tcpHeader.GetAckNumber () <<". Leaving fast recovery with cwnd set to " << m_tcb->m_cWnd);
             }
         }
       else if (m_tcb->m_ackState == TcpSocketState::LOSS)
@@ -1704,16 +1397,22 @@ TcpSocketBase::ReceivedAck (SequenceNumber32 ack)
 
       for (uint32_t i=0; i<segsAcked; ++i)
         {
-          m_congestionControl->IncreaseWindow (this, m_tcb);
+          m_congestionControl->IncreaseWindow (m_tcb);
         }
 
       NS_LOG_LOGIC ("Congestion control called: " <<
                     " cWnd: " << m_tcb->m_cWnd <<
                     " ssTh: " << m_tcb->m_ssThresh);
 
-      NewAck (ack);
+      NewAck (tcpHeader.GetAckNumber ());
       m_dupAckCount = 0;
     }
+
+  // If there is any data piggybacked, store it into m_rxBuffer
+  if (packet->GetSize () > 0)
+    {
+      ReceivedData (packet, tcpHeader);
+    }
 }
 
 /* Received a packet upon LISTEN state. */
@@ -1739,288 +1438,19 @@ TcpSocketBase::ProcessListen (Ptr<Packet> packet, const TcpHeader& tcpHeader,
     {
       return;
     }
-
-   /**
-    we first forked here, socket is not registered into TCPL4Protocol yet
-   **/
-   Ptr<TcpSocketBase> newSock = Fork ();
-   newSock->ResetUserCallbacks ();
-
-   Ptr<const TcpOptionMpTcpCapable> mpc;
-
-   if (GetTcpOption (tcpHeader, mpc))
-    {
-      NS_ASSERT_MSG (!mpc->HasReceiverKey(), "Should not be the case");
-      NS_LOG_LOGIC ("Fork & Upgrade to meta " << this);
-      
-      // TODO is it possible to move these to CompleteFork
-      // would clutter less TcpSocketBase
-      uint64_t localKey = this->GenerateUniqueMpTcpKey () ;
-      Ptr<MpTcpSubflow> master = newSock->UpgradeToMeta (false, localKey, mpc->GetSenderKey());
-     
-      
-      // TODO Move part of it to UpgradeToMeta 
-      // HACK matt otherwise the new subflow sends the packet on the wroing interface
-      // Now useless remove ?
-      master->m_boundnetdevice = this->m_boundnetdevice;
-
-      // Not even needed
-      Ptr<MpTcpSocketBase> meta = DynamicCast<MpTcpSocketBase>(newSock);
-
-      // We add the socket after initial parameters are correctly set so that
-      // tracing doesn't contain strange values that mess up plotting
-      bool result = m_tcp->AddSocket (meta);
-      NS_ASSERT_MSG (result, "could not register meta");
-
-      Simulator::ScheduleNow (&MpTcpSubflow::CompleteFork, master,
-                          packet, tcpHeader, fromAddress, toAddress);
-
-      return;
-    }
-
+  // Clone the socket, simulate fork
+  Ptr<TcpSocketBase> newSock = Fork ();
   NS_LOG_LOGIC ("Cloned a TcpSocketBase " << newSock);
   Simulator::ScheduleNow (&TcpSocketBase::CompleteFork, newSock,
                           packet, tcpHeader, fromAddress, toAddress);
 }
 
-
-Ptr<MpTcpSubflow>
-TcpSocketBase::UpgradeToMeta (bool connecting, uint64_t localKey, uint64_t peerKey)
-{
-  NS_LOG_FUNCTION("Upgrading to meta " << this);
-  uint32_t refCount = this->GetReferenceCount();
-//  NS_LOG_DEBUG( "refcount=" << this->GetReferenceCount() << " before upgrade" );
-  /**
-   TODO here we should find a way to call CompleteConstruct else some plots are wrong since
-   TcpXxBuffers were not setup correctly (rWnd for instance)
-  
-   Also we don't necessarely want to create a MpTcpSubflow but maybe a subclass.
-   The default subflow typeid is an attribute of meta socket which is not practical since subflow is created
-   before meta. Hence move that type id to TcpL4Protocol
-   */
-//  MpTcpSubflow *subflow = new MpTcpSubflow (*this);
-  Ptr<TcpSocketBase> temp =  this->Fork();
-//  Ptr<TcpSocketBase> temp =  CopyObject<TcpSocketBase>(this);
-
-
-  // TODO cancel only for forks, not when client gets upgraded Otherwise timers
-  this->CancelAllTimers();
-//  Ptr<MpTcpSocketBase> meta2 = DynamicCast<MpTcpSocketBase>(
-//        m_tcp->CreateSocket(ns3::MpTcpSocketBase::GetTypeId())
-//  );
-
-//  *meta2 = *this;
- 
-  // TODO retrieve
-//  Ptr<MpTcpSubflow> master = DynamicCast<MpTcpSubflow>(m_tcp->CreateSocket( ns3::MpTcpSubflow::GetTypeId() ) );
- 
- 
-//  std::swap (*meta2, *this);
-//  meta->CreateSubflow();
-  
-  // TODO could do sthg like CopyObject<MpTcpSubflow>(this) ?
-  // Otherwise uncoimment CompleteConstruct
-  // TODO first do completeConstruct, then call operator=(
-//  Ptr<MpTcpSubflow> master (subflow, true);
-  // CompletConstruct doit etre
-//  Ptr<MpTcpSubflow> master = DynamicCast <MpTcpSubflow>(CompleteConstruct ( (TcpSocketBase*)subflow) );
-
-
-
-
-//  Ipv4EndPoint *endPoint = m_endPoint;
-
-
-//  this->~TcpSocketBase();
-  // MpTcpSocketBase(*this) ?
-//  MpTcpSocketBase* temp = new MpTcpSocketBase(*this);
-//  std::memcpy (this, temp, sizeof(std::aligned_storage<sizeof(MpTcpSocketBase)>::type) ); // dest/src/size
-
-  // I don't want the destructor to be called in that moment
-
-  // TODO here we should be able to choose the typeid of the meta 
-  MpTcpSocketBase* meta = new (this) MpTcpSocketBase();
-  // update attributes with default
-  CompleteConstruct (meta);
-//  meta->SetCongestionControlAlgorithm( );
-
-  while (this->GetReferenceCount() < refCount) 
-  {
-    this->Ref();
-  }
-  meta->CreateScheduler (); // meta->m_schedulerTypeId
-  // Once typeids are ok, one can setup scheduler
-//  temp->m_tcp->DumpSockets();
-
-  meta->SetNode (temp->GetNode());
-  
-  
-  // This setups tx/rx buffers, congestion control, rtt, tcp, (node ?)
-  *meta = *temp;
-//  meta->SetTcp (temp->m_tcp);
-
-  meta->SetLocalKey (localKey);
-  meta->SetPeerKey (peerKey);
-  
-  Ptr<MpTcpSubflow> master = meta->CreateSubflow (true);
-//  master.Acquire();
-  *master = *temp;
-  NS_LOG_UNCOND (master->m_rWnd.Get () << " rwnd to compare with temp rwnd=" << temp->m_rWnd.Get ());
-  if(connecting)
-  {
-      //! then we update
-//      m_state = sf->GetState ();
-//      m_mptcpLocalKey = sf->m_mptcpLocalKey;
-//      m_mptcpLocalToken = sf->m_mptcpLocalToken;
-//      NS_LOG_DEBUG("Set master key/token to "<< m_mptcpLocalKey << "/" << m_mptcpLocalToken);
-
-      // Those may be overriden later
-//      m_endPoint = endPoint;
-//      m_endPoint6 = sf->m_endPoint6;
-
-//      InetSocketAddress addr (endPoint->GetLocalAddress(), endPoint->GetLocalPort());
-//      uint8_t id = 0;
-//      bool ok = meta->AddLocalId(&id, addr);
-//      NS_ASSERT_MSG (ok, "Master subflow has mptcp id " << (int) id);
-//      NS_LOG_DEBUG ("Master subflow has mptcp id " << (int) id);
-
-//      GetMeta ()->AddLocalId ();
-  }
-
-//InitLocalISN
-  // we add it to tcp so that it can be freed and used for token lookup
-
-//  MpTcpSocketBase* meta = new (this) MpTcpSocketBase();
-//  meta->m_sendCb =sf->m_sendCb;
-  meta->AddSubflow (master);
-
-  // the master is always a new socket, hence we should register it
-  // We can only do it when meta is set
-//  bool result = m_tcp->AddSocket (master);
-//  NS_ASSERT_MSG (result, "Could not register master");
-
-  // TODO destroy and rebind
-//  temp->Destroy();
-//  m_tcp->AddSocket (meta);
-  return master;
-  
-//  return 0;
-}
-
-
-int
-TcpSocketBase::ProcessTcpOptions (const TcpHeader& header)
-{
-  NS_LOG_FUNCTION (this << header);
-
-  TcpHeader::TcpOptionList options;
-  header.GetOptions (options);
-
-  for(TcpHeader::TcpOptionList::const_iterator it(options.begin()); it != options.end(); ++it)
-  {
-      //!
-      Ptr<const TcpOption> option = *it;
-      switch(option->GetKind())
-      {
-        case TcpOption::WINSCALE:
-          if ((header.GetFlags () & TcpHeader::SYN) && m_winScalingEnabled && m_state < ESTABLISHED)
-            {
-              ProcessOptionWScale (option);
-              ScaleSsThresh (m_sndScaleFactor);
-            }
-            break;
-        case TcpOption::MPTCP:
-            //! this will interrupt option processing but this function will be scheduled again
-            //! thus some options may be processed twice, it should not trigger errors
-            if(ProcessOptionMpTcp (option) != 0)
-            {
-                return 1;   //Means
-            }
-            break;
-        case TcpOption::TS:
-            if (m_timestampEnabled)
-            {
-                ProcessOptionTimestamp (option);
-            }
-            break;
-        // Ignore those
-        case TcpOption::NOP:
-        case TcpOption::END:
-            break;
-        default:
-            NS_LOG_WARN("Unsupported option [" << (int)option->GetKind() << "]");
-            break;
-      };
-  }
-  return 0;
-}
-
-
-
-void
-TcpSocketBase::InitLocalISN ()
-{
-  NS_LOG_FUNCTION (this);
-  SequenceNumber32 isn (0);
-  if(!m_nullIsn)
-  {
-    NS_LOG_INFO("Generating Initial Sequence Number");
-    isn = rand();
-  }
-  InitLocalISN (isn);
-}
-
-void
-TcpSocketBase::InitLocalISN (const SequenceNumber32& localIsn)
-{
-  NS_LOG_FUNCTION (this << localIsn);
-
-    NS_LOG_INFO ("Setting local ISN to " );
-    // TODO check it was not initialized already ?
-//    m_rxBuffer->SetNextRxSequence (peerIsn + SequenceNumber32 (1));
-    m_nextTxSequence = localIsn;
-    m_firstTxUnack = m_nextTxSequence;
-    m_highTxMark = m_nextTxSequence;
-    m_txBuffer->SetHeadSequence (m_nextTxSequence);
-    m_localISN = m_nextTxSequence;
-}
-
-void
-TcpSocketBase::InitPeerISN (const SequenceNumber32& peerIsn)
-{
-    NS_LOG_INFO("Setting peer ISN=" << peerIsn << " " << GetInstanceTypeId());
-    // TODO check it was not initialized already ?
-    m_rxBuffer->SetNextRxSequence (peerIsn + SequenceNumber32 (1));
-    m_peerISN = peerIsn;
-}
-
-
-SequenceNumber32
-TcpSocketBase::GetPeerIsn (void) const
-{
-    // TODO check it's connected
-//    NS_ASSERT(m_connected);
-    return m_peerISN;
-}
-
-
-
-SequenceNumber32
-TcpSocketBase::GetLocalIsn(void) const
-{
-    // TODO check it's connected
-//    NS_ASSERT(m_connected);
-    return m_localISN;
-}
-
-
 /* Received a packet upon SYN_SENT */
 void
 TcpSocketBase::ProcessSynSent (Ptr<Packet> packet, const TcpHeader& tcpHeader)
 {
   NS_LOG_FUNCTION (this << tcpHeader);
-uint64_t idsn;
-uint32_t localToken;
+
   // Extract the flags. PSH and URG are not honoured.
   uint8_t tcpflags = tcpHeader.GetFlags () & ~(TcpHeader::PSH | TcpHeader::URG);
 
@@ -2042,83 +1472,19 @@ uint32_t localToken;
       NS_LOG_INFO ("SYN_SENT -> SYN_RCVD");
       m_state = SYN_RCVD;
       m_cnCount = m_cnRetries;
-//      m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
-      InitPeerISN (tcpHeader.GetSequenceNumber ());
+      m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
       SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);
     }
   else if (tcpflags == (TcpHeader::SYN | TcpHeader::ACK)
            && m_nextTxSequence + SequenceNumber32 (1) == tcpHeader.GetAckNumber ())
     { // Handshake completed
-
-
-      Ptr<const TcpOptionMpTcpCapable> mpc;
-      
-      // Process the MP_CAPABLE only once, i.e., if we are not a subflow already
-      // else, we end up processing ad vitam aeternam
-//      NS_LOG_DEBUG ("Child of subflow ? instance typeid=" << GetInstanceTypeId()
-//          << " to compare with " << MpTcpSubflow::GetTypeId() );
-        
-      if( !GetInstanceTypeId().IsChildOf(MpTcpSubflow::GetTypeId(), false) 
-        && GetTcpOption(tcpHeader, mpc))
-      {
-        // save endpoint because its value is destroyed while upgrading to meta
-        // these are backupo variables
-        Ipv4EndPoint* endPoint = m_endPoint;
-        Ptr<NetDevice> boundDev = m_boundnetdevice;
-        
-        
-        NS_LOG_DEBUG("MATT " << this << " "<< GetInstanceTypeId());
-        NS_LOG_DEBUG( "refcount=" << this->GetReferenceCount() << " before upgrade" );
-       
-        // master = first subflow
-        Ptr<MpTcpSubflow> master = UpgradeToMeta (true, m_mptcpLocalKey, mpc->GetSenderKey() );
-        master->ResetUserCallbacks ();
-
-          // Subflow now created with m_tcp->CreateSocket=> already registered
-//        bool result = m_tcp->AddSocket (master);
-//        NS_ASSERT_MSG (result, "Could not register master");
-
-        // Hack to retrigger the tcpL4protocol::OnNewSocket callback
-        m_tcp->NotifyNewSocket (this);
-
-        // Need to register an id
-        InetSocketAddress addr (endPoint->GetLocalAddress(), endPoint->GetLocalPort());
-        MpTcpSocketBase* meta = (MpTcpSocketBase*)this;
-        uint8_t id = 0;
-        bool ok = meta->AddLocalId (&id, addr);
-        NS_ASSERT_MSG (ok, "Master subflow has mptcp id " << (int) id);
-        NS_LOG_DEBUG ("Master subflow has mptcp id " << (int) id);
-
-        // HACK matt otherwise the new subflow sends the packet to the wrong socket, i.e., its previous
-        // owner, which has now become the meta
-        master->m_boundnetdevice = boundDev;
-        master->m_endPoint = endPoint;
-        master->SetupCallback();
-
-//        NS_LOG_DEBUG("MATT2 end of upgrade " << this << " "<< GetInstanceTypeId());
-        NS_LOG_DEBUG("Local/peer ISNs: " << this->GetLocalIsn() << "/"<< this->GetPeerIsn()
-            << "(peer isn set later by processSynSent)");
-        NS_LOG_DEBUG( "refcount=" << this->GetReferenceCount() << " after upgrade" );
-//        this->Ref();
-//        master->Bind();
-
-        // Carr√©ment le renvoyer √† forwardUp pour forcer la relecture de la windowsize
-        
-        Simulator::ScheduleNow ( &MpTcpSubflow::ProcessSynSent, master, packet, tcpHeader);
-        return;
-      }
-
+      NS_LOG_INFO ("SYN_SENT -> ESTABLISHED");
+      m_state = ESTABLISHED;
       m_connected = true;
       m_retxEvent.Cancel ();
-      InitPeerISN (tcpHeader.GetSequenceNumber ());
-//      m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
+      m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
       m_highTxMark = ++m_nextTxSequence;
       m_txBuffer->SetHeadSequence (m_nextTxSequence);
-      m_firstTxUnack = m_nextTxSequence;
-
-      NS_LOG_INFO ("SYN_SENT -> ESTABLISHED");
-      m_state = ESTABLISHED;
-
       SendEmptyPacket (TcpHeader::ACK);
       SendPendingData (m_connected);
       Simulator::ScheduleNow (&TcpSocketBase::ConnectionSucceeded, this);
@@ -2138,7 +1504,6 @@ uint32_t localToken;
     }
 }
 
-
 /* Received a packet upon SYN_RCVD */
 void
 TcpSocketBase::ProcessSynRcvd (Ptr<Packet> packet, const TcpHeader& tcpHeader,
@@ -2160,11 +1525,7 @@ TcpSocketBase::ProcessSynRcvd (Ptr<Packet> packet, const TcpHeader& tcpHeader,
       m_connected = true;
       m_retxEvent.Cancel ();
       m_highTxMark = ++m_nextTxSequence;
-//      SetTxHead()
       m_txBuffer->SetHeadSequence (m_nextTxSequence);
-      m_firstTxUnack = m_nextTxSequence;
-
-
       if (m_endPoint)
         {
           m_endPoint->SetPeer (InetSocketAddress::ConvertFrom (fromAddress).GetIpv4 (),
@@ -2178,22 +1539,8 @@ TcpSocketBase::ProcessSynRcvd (Ptr<Packet> packet, const TcpHeader& tcpHeader,
       // Always respond to first data packet to speed up the connection.
       // Remove to get the behaviour of old NS-3 code.
       m_delAckCount = m_delAckMaxCount;
-
-      ProcessTcpOptions (tcpHeader);
-//      if(){
-//        return;
-//      }
-      // TODO copy this socket into a subflow
-      // or create
-//      Ptr<MpTcpSubflow> sf = CopyObject<MpTcpSubflow>();
-      // TODO check a faire dans Listen aussi
-
-      // TODO do it afterwards, schedule it for instance ?
       ReceivedAck (packet, tcpHeader);
-
-
       NotifyNewConnectionCreated (this, fromAddress);
-
       // As this connection is established, the socket is available to send data now
       if (GetTxAvailable () > 0)
         {
@@ -2202,8 +1549,7 @@ TcpSocketBase::ProcessSynRcvd (Ptr<Packet> packet, const TcpHeader& tcpHeader,
     }
   else if (tcpflags == TcpHeader::SYN)
     { // Probably the peer lost my SYN+ACK
-      InitPeerISN (tcpHeader.GetSequenceNumber ());
-//      m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
+      m_rxBuffer->SetNextRxSequence (tcpHeader.GetSequenceNumber () + SequenceNumber32 (1));
       SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);
     }
   else if (tcpflags == (TcpHeader::FIN | TcpHeader::ACK))
@@ -2214,7 +1560,6 @@ TcpSocketBase::ProcessSynRcvd (Ptr<Packet> packet, const TcpHeader& tcpHeader,
           m_retxEvent.Cancel ();
           m_highTxMark = ++m_nextTxSequence;
           m_txBuffer->SetHeadSequence (m_nextTxSequence);
-          m_firstTxUnack =  m_nextTxSequence;
           if (m_endPoint)
             {
               m_endPoint->SetPeer (InetSocketAddress::ConvertFrom (fromAddress).GetIpv4 (),
@@ -2335,7 +1680,6 @@ TcpSocketBase::ProcessClosing (Ptr<Packet> packet, const TcpHeader& tcpHeader)
     {
       if (tcpHeader.GetSequenceNumber () == m_rxBuffer->NextRxSequence ())
         { // This ACK corresponds to the FIN sent
-          ProcessTcpOptions (tcpHeader);
           TimeWait ();
         }
     }
@@ -2344,7 +1688,6 @@ TcpSocketBase::ProcessClosing (Ptr<Packet> packet, const TcpHeader& tcpHeader)
       // anyone. If anything other than ACK is received, respond with a reset.
       if (tcpflags == TcpHeader::FIN || tcpflags == (TcpHeader::FIN | TcpHeader::ACK))
         { // FIN from the peer as well. We can close immediately.
-          ProcessTcpOptions(tcpHeader);
           SendEmptyPacket (TcpHeader::ACK);
         }
       else if (tcpflags != TcpHeader::RST)
@@ -2367,25 +1710,21 @@ TcpSocketBase::ProcessLastAck (Ptr<Packet> packet, const TcpHeader& tcpHeader)
 
   if (tcpflags == 0)
     {
-      ProcessTcpOptions(tcpHeader);
       ReceivedData (packet, tcpHeader);
     }
   else if (tcpflags == TcpHeader::ACK)
     {
       if (tcpHeader.GetSequenceNumber () == m_rxBuffer->NextRxSequence ())
         { // This ACK corresponds to the FIN sent. This socket closed peacefully.
-          ProcessTcpOptions(tcpHeader);
           CloseAndNotify ();
         }
     }
   else if (tcpflags == TcpHeader::FIN)
     { // Received FIN again, the peer probably lost the FIN+ACK
-      ProcessTcpOptions(tcpHeader);
       SendEmptyPacket (TcpHeader::FIN | TcpHeader::ACK);
     }
   else if (tcpflags == (TcpHeader::FIN | TcpHeader::ACK) || tcpflags == TcpHeader::RST)
     {
-      ProcessTcpOptions(tcpHeader);
       CloseAndNotify ();
     }
   else
@@ -2503,61 +1842,15 @@ TcpSocketBase::Destroy6 (void)
   CancelAllTimers ();
 }
 
+/* Send an empty packet with specified TCP flags */
 void
-TcpSocketBase::GenerateEmptyPacketHeader(TcpHeader& header, uint8_t flags)
+TcpSocketBase::SendEmptyPacket (uint8_t flags)
 {
-  NS_LOG_FUNCTION (this << TcpHeader::FlagsToString(flags));
-
+  NS_LOG_FUNCTION (this << (uint32_t)flags);
+  Ptr<Packet> p = Create<Packet> ();
+  TcpHeader header;
   SequenceNumber32 s = m_nextTxSequence;
 
-  if (flags & TcpHeader::FIN)
-    {
-      flags |= TcpHeader::ACK;
-    }
-  //!
-  else if (m_state == FIN_WAIT_1 || m_state == LAST_ACK || m_state == CLOSING)
-    {
-      ++s;
-    }
-
-
-  header.SetFlags (flags);
-  header.SetSequenceNumber (s);
-
-  if(flags & TcpHeader::ACK)
-  {
-        header.SetAckNumber (m_rxBuffer->NextRxSequence ());
-  }
-
-//  header.SetAckNumber (m_rxBuffer->NextRxSequence ());
-  NS_LOG_DEBUG(this << " endpoint=" << m_endPoint);
-  if (m_endPoint != 0)
-    {
-      header.SetSourcePort (m_endPoint->GetLocalPort ());
-      header.SetDestinationPort (m_endPoint->GetPeerPort ());
-    }
-  else
-    {
-      NS_ASSERT(m_endPoint6 != 0);
-      header.SetSourcePort (m_endPoint6->GetLocalPort ());
-      header.SetDestinationPort (m_endPoint6->GetPeerPort ());
-    }
-//  AddOptions (header);
-  header.SetWindowSize (AdvertisedWindowSize ());
-}
-
-
-void
-TcpSocketBase::SendPacket(TcpHeader header, Ptr<Packet> p)
-{
-  NS_LOG_LOGIC ("Send packet via TcpL4Protocol with flags"
-//                << TcpHeader::FlagsToString (flags)
-                );
-
-  // Matt this might be a problem later on
-  NS_ASSERT (header.GetWindowSize() == AdvertisedWindowSize ());
-
-
   /*
    * Add tags for each socket option.
    * Note that currently the socket adds both IPv4 tag and IPv6 tag
@@ -2592,57 +1885,39 @@ TcpSocketBase::SendPacket(TcpHeader header, Ptr<Packet> p)
       p->AddPacketTag (ipHopLimitTag);
     }
 
-  AddOptions (header);
-
-  if (m_endPoint != 0)
+  if (m_endPoint == 0 && m_endPoint6 == 0)
     {
-      m_tcp->SendPacket (p, header, m_endPoint->GetLocalAddress (),
-                         m_endPoint->GetPeerAddress (), m_boundnetdevice);
+      NS_LOG_WARN ("Failed to send empty packet due to null endpoint");
+      return;
     }
-  else
+  if (flags & TcpHeader::FIN)
     {
-      NS_ASSERT(m_endPoint6 != 0);
-      m_tcp->SendPacket (p, header, m_endPoint6->GetLocalAddress (),
-                         m_endPoint6->GetPeerAddress (), m_boundnetdevice);
+      flags |= TcpHeader::ACK;
     }
-
-
-  if (header.GetFlags() & TcpHeader::ACK)
-    { // If sending an ACK, cancel the delay ACK as well
-      m_delAckEvent.Cancel ();
-      m_delAckCount = 0;
+  else if (m_state == FIN_WAIT_1 || m_state == LAST_ACK || m_state == CLOSING)
+    {
+      ++s;
     }
-}
-
-/* Send an empty packet with specified TCP flags
-TODO pass on a sequence number ?
-*/
-void
-TcpSocketBase::SendEmptyPacket (uint8_t flags)
-{
-    TcpHeader header;
-    GenerateEmptyPacketHeader(header, flags);
-    SendEmptyPacket(header);
-}
-
-void
-TcpSocketBase::SendEmptyPacket (TcpHeader& header)
-{
-//  NS_LOG_FUNCTION (this << (uint32_t)flags);
-  NS_LOG_FUNCTION (this << header);
-  Ptr<Packet> p = Create<Packet> ();
-
 
-  if (m_endPoint == 0 && m_endPoint6 == 0)
+  header.SetFlags (flags);
+  header.SetSequenceNumber (s);
+  header.SetAckNumber (m_rxBuffer->NextRxSequence ());
+  if (m_endPoint != 0)
     {
-      NS_LOG_WARN ("Failed to send empty packet due to null endpoint");
-      return;
+      header.SetSourcePort (m_endPoint->GetLocalPort ());
+      header.SetDestinationPort (m_endPoint->GetPeerPort ());
+    }
+  else
+    {
+      header.SetSourcePort (m_endPoint6->GetLocalPort ());
+      header.SetDestinationPort (m_endPoint6->GetPeerPort ());
     }
+  AddOptions (header);
+  header.SetWindowSize (AdvertisedWindowSize ());
 
   // RFC 6298, clause 2.4
-  // TODO GetRTO
   m_rto = Max (m_rtt->GetEstimate () + Max (m_clockGranularity, m_rtt->GetVariation ()*4), m_minRto);
-  uint8_t flags = header.GetFlags();
+
   bool hasSyn = flags & TcpHeader::SYN;
   bool hasFin = flags & TcpHeader::FIN;
   bool isAck = flags == TcpHeader::ACK;
@@ -2662,14 +1937,27 @@ TcpSocketBase::SendEmptyPacket (TcpHeader& header)
           m_cnCount--;
         }
     }
-    SendPacket(header, p);
-
+  if (m_endPoint != 0)
+    {
+      m_tcp->SendPacket (p, header, m_endPoint->GetLocalAddress (),
+                         m_endPoint->GetPeerAddress (), m_boundnetdevice);
+    }
+  else
+    {
+      m_tcp->SendPacket (p, header, m_endPoint6->GetLocalAddress (),
+                         m_endPoint6->GetPeerAddress (), m_boundnetdevice);
+    }
+  if (flags & TcpHeader::ACK)
+    { // If sending an ACK, cancel the delay ACK as well
+      m_delAckEvent.Cancel ();
+      m_delAckCount = 0;
+    }
   if (m_retxEvent.IsExpired () && (hasSyn || hasFin) && !isAck )
     { // Retransmit SYN / SYN+ACK / FIN / FIN+ACK to guard against lost
       NS_LOG_LOGIC ("Schedule retransmission timeout at time "
                     << Simulator::Now ().GetSeconds () << " to expire at time "
                     << (Simulator::Now () + m_rto.Get ()).GetSeconds ());
-      m_retxEvent = Simulator::Schedule (m_rto, (void (TcpSocketBase::*)(uint8_t ))&TcpSocketBase::SendEmptyPacket, this, header.GetFlags());
+      m_retxEvent = Simulator::Schedule (m_rto, &TcpSocketBase::SendEmptyPacket, this, flags);
     }
 }
 
@@ -2770,11 +2058,9 @@ TcpSocketBase::SetupEndpoint6 ()
    TcpSocketBase cloned, allocate a new end point to handle the incoming
    connection and send a SYN+ACK to complete the handshake. */
 void
-TcpSocketBase::CompleteFork (Ptr<const Packet> p, const TcpHeader& h,
+TcpSocketBase::CompleteFork (Ptr<Packet> p, const TcpHeader& h,
                              const Address& fromAddress, const Address& toAddress)
 {
-  NS_LOG_FUNCTION (this);
-
   // Get port and address from peer (connecting host)
   if (InetSocketAddress::IsMatchingType (toAddress))
     {
@@ -2782,17 +2068,7 @@ TcpSocketBase::CompleteFork (Ptr<const Packet> p, const TcpHeader& h,
                                     InetSocketAddress::ConvertFrom (toAddress).GetPort (),
                                     InetSocketAddress::ConvertFrom (fromAddress).GetIpv4 (),
                                     InetSocketAddress::ConvertFrom (fromAddress).GetPort ());
-
-      Ptr<NetDevice> dev = MapIpToInterface(InetSocketAddress::ConvertFrom (toAddress).GetIpv4 ());
-      if(dev) {
-        NS_LOG_UNCOND("device found; binding to it");
-        m_endPoint->BindToNetDevice(dev);
-        m_boundnetdevice = m_endPoint->GetBoundNetDevice();
-      }
-
-      /* la il faut chercher */
       m_endPoint6 = 0;
-      NS_ASSERT(m_endPoint);
     }
   else if (Inet6SocketAddress::IsMatchingType (toAddress))
     {
@@ -2801,28 +2077,16 @@ TcpSocketBase::CompleteFork (Ptr<const Packet> p, const TcpHeader& h,
                                       Inet6SocketAddress::ConvertFrom (fromAddress).GetIpv6 (),
                                       Inet6SocketAddress::ConvertFrom (fromAddress).GetPort ());
       m_endPoint = 0;
-      NS_ASSERT(m_endPoint6);
     }
-    
+  m_tcp->AddSocket(this);
+
   // Change the cloned socket from LISTEN state to SYN_RCVD
   NS_LOG_INFO ("LISTEN -> SYN_RCVD");
   m_state = SYN_RCVD;
   m_cnCount = m_cnRetries;
   SetupCallback ();
-  
-  // TODO move out
   // Set the sequence number and send SYN+ACK
-  InitLocalISN ();
-  InitPeerISN (h.GetSequenceNumber ());
-  // No need for UpdateWindowSize here ?!
-  m_rWnd = h.GetWindowSize();
-  
-  // Call addsocket after setting up initial parameters to get nice plots
-  bool result = m_tcp->AddSocket(this);
-  if(!result)
-  {
-    NS_LOG_WARN ("Can't add socket: already registered ? Can be because of mptcp");
-  }
+  m_rxBuffer->SetNextRxSequence (h.GetSequenceNumber () + SequenceNumber32 (1));
 
   SendEmptyPacket (TcpHeader::SYN | TcpHeader::ACK);
 }
@@ -2846,31 +2110,62 @@ TcpSocketBase::ConnectionSucceeded ()
 uint32_t
 TcpSocketBase::SendDataPacket (SequenceNumber32 seq, uint32_t maxSize, bool withAck)
 {
-    //!<
-    TcpHeader header;
-    GenerateEmptyPacketHeader(header, withAck ? TcpHeader::ACK : 0);
-    return SendDataPacket(header, seq, maxSize);
-}
-
-
-uint32_t
-TcpSocketBase::SendDataPacket (TcpHeader& header, SequenceNumber32 seq, uint32_t maxSize)
-{
-  NS_LOG_FUNCTION (this << seq << maxSize);
+  NS_LOG_FUNCTION (this << seq << maxSize << withAck);
 
   bool isRetransmission = false;
-  if ( seq == FirstUnackedSeq() )
+  if ( seq == m_txBuffer->HeadSequence () )
     {
       isRetransmission = true;
     }
 
   Ptr<Packet> p = m_txBuffer->CopyFromSequence (maxSize, seq);
   uint32_t sz = p->GetSize (); // Size of packet
+  uint8_t flags = withAck ? TcpHeader::ACK : 0;
   uint32_t remainingData = m_txBuffer->SizeFromSequence (seq + SequenceNumber32 (sz));
 
+  if (withAck)
+    {
+      m_delAckEvent.Cancel ();
+      m_delAckCount = 0;
+    }
+
+  /*
+   * Add tags for each socket option.
+   * Note that currently the socket adds both IPv4 tag and IPv6 tag
+   * if both options are set. Once the packet got to layer three, only
+   * the corresponding tags will be read.
+   */
+  if (IsManualIpTos ())
+    {
+      SocketIpTosTag ipTosTag;
+      ipTosTag.SetTos (GetIpTos ());
+      p->AddPacketTag (ipTosTag);
+    }
+
+  if (IsManualIpv6Tclass ())
+    {
+      SocketIpv6TclassTag ipTclassTag;
+      ipTclassTag.SetTclass (GetIpv6Tclass ());
+      p->AddPacketTag (ipTclassTag);
+    }
+
+  if (IsManualIpTtl ())
+    {
+      SocketIpTtlTag ipTtlTag;
+      ipTtlTag.SetTtl (GetIpTtl ());
+      p->AddPacketTag (ipTtlTag);
+    }
+
+  if (IsManualIpv6HopLimit ())
+    {
+      SocketIpv6HopLimitTag ipHopLimitTag;
+      ipHopLimitTag.SetHopLimit (GetIpv6HopLimit ());
+      p->AddPacketTag (ipHopLimitTag);
+    }
+
   if (m_closeOnEmpty && (remainingData == 0))
     {
-      header.SetFlags(TcpHeader::FIN | header.GetFlags());
+      flags |= TcpHeader::FIN;
       if (m_state == ESTABLISHED)
         { // On active close: I am the first one to send FIN
           NS_LOG_INFO ("ESTABLISHED -> FIN_WAIT_1");
@@ -2882,9 +2177,22 @@ TcpSocketBase::SendDataPacket (TcpHeader& header, SequenceNumber32 seq, uint32_t
           m_state = LAST_ACK;
         }
     }
-
+  TcpHeader header;
+  header.SetFlags (flags);
   header.SetSequenceNumber (seq);
-//  AddOptions (header);
+  header.SetAckNumber (m_rxBuffer->NextRxSequence ());
+  if (m_endPoint)
+    {
+      header.SetSourcePort (m_endPoint->GetLocalPort ());
+      header.SetDestinationPort (m_endPoint->GetPeerPort ());
+    }
+  else
+    {
+      header.SetSourcePort (m_endPoint6->GetLocalPort ());
+      header.SetDestinationPort (m_endPoint6->GetPeerPort ());
+    }
+  header.SetWindowSize (AdvertisedWindowSize ());
+  AddOptions (header);
 
   if (m_retxEvent.IsExpired () )
     {
@@ -2899,9 +2207,18 @@ TcpSocketBase::SendDataPacket (TcpHeader& header, SequenceNumber32 seq, uint32_t
                     (Simulator::Now () + m_rto.Get ()).GetSeconds () );
       m_retxEvent = Simulator::Schedule (m_rto, &TcpSocketBase::ReTxTimeout, this);
     }
-
-
-  SendPacket(header, p);
+  NS_LOG_LOGIC ("Send packet via TcpL4Protocol with flags" <<
+                TcpHeader::FlagsToString (flags));
+  if (m_endPoint)
+    {
+      m_tcp->SendPacket (p, header, m_endPoint->GetLocalAddress (),
+                         m_endPoint->GetPeerAddress (), m_boundnetdevice);
+    }
+  else
+    {
+      m_tcp->SendPacket (p, header, m_endPoint6->GetLocalAddress (),
+                         m_endPoint6->GetPeerAddress (), m_boundnetdevice);
+    }
 
   // update the history of sequence numbers used to calculate the RTT
   if (isRetransmission == false)
@@ -2937,10 +2254,9 @@ TcpSocketBase::SendDataPacket (TcpHeader& header, SequenceNumber32 seq, uint32_t
 bool
 TcpSocketBase::SendPendingData (bool withAck)
 {
-  NS_LOG_FUNCTION (this << withAck << " in state " << TcpStateName[m_state]);
+  NS_LOG_FUNCTION (this << withAck);
   if (m_txBuffer->Size () == 0)
     {
-      NS_LOG_DEBUG("Nothing to send");
       return false;                           // Nothing to send
     }
   if (m_endPoint == 0 && m_endPoint6 == 0)
@@ -2968,13 +2284,12 @@ TcpSocketBase::SendPendingData (bool withAck)
         }
       NS_LOG_LOGIC ("TcpSocketBase " << this << " SendPendingData" <<
                     " w " << w <<
-                    " rxwin " << GetRwnd () <<
+                    " rxwin " << m_rWnd <<
                     " segsize " << m_tcb->m_segmentSize <<
-//                    " nextTxSeq " <<  <<
-                    " highestRxAck " << FirstUnackedSeq() <<
-                    " TxBufferSize=" << m_txBuffer->Size () <<
-                    " pd->SizeFromSequence( " << m_nextTxSequence << ")="
-                    << m_txBuffer->SizeFromSequence (m_nextTxSequence));
+                    " nextTxSeq " << m_nextTxSequence <<
+                    " highestRxAck " << m_txBuffer->HeadSequence () <<
+                    " pd->Size " << m_txBuffer->Size () <<
+                    " pd->SFS " << m_txBuffer->SizeFromSequence (m_nextTxSequence));
       uint32_t s = std::min (w, m_tcb->m_segmentSize);  // Send no more than window
       uint32_t sz = SendDataPacket (m_nextTxSequence, s, withAck);
       nPacketsSent++;                             // Count sent this loop
@@ -2988,34 +2303,21 @@ uint32_t
 TcpSocketBase::UnAckDataCount ()
 {
   NS_LOG_FUNCTION (this);
-  return m_nextTxSequence.Get () - FirstUnackedSeq();
+  return m_nextTxSequence.Get () - m_txBuffer->HeadSequence ();
 }
 
 uint32_t
 TcpSocketBase::BytesInFlight ()
 {
   NS_LOG_FUNCTION (this);
-  return m_highTxMark.Get () - FirstUnackedSeq();
+  return m_highTxMark.Get () - m_txBuffer->HeadSequence ();
 }
 
-
 uint32_t
-TcpSocketBase::GetRwnd() const
-{
-  return m_rWnd.Get();
-}
-
-uint32_t
-TcpSocketBase::Window (void) 
+TcpSocketBase::Window (void)
 {
   NS_LOG_FUNCTION (this);
-//  return std::min (m_rWnd.Get (), m_tcb->m_cWnd.Get ());
-
-  return std::min (
-    GetRwnd(), 
-    m_tcb->m_cWnd.Get ()
-    
-  );
+  return std::min (m_rWnd.Get (), m_tcb->m_cWnd.Get ());
 }
 
 /*
@@ -3082,7 +2384,6 @@ TcpSocketBase::AdvertisedWindowSize ()
   if (w > m_maxWinSize)
     {
       NS_LOG_WARN ("There is a loss in the adv win size, wrt buffer size");
-      NS_LOG_WARN ("Loss=" << w - m_maxWinSize);
       w = m_maxWinSize;
     }
 
@@ -3100,7 +2401,7 @@ TcpSocketBase::ReceivedData (Ptr<Packet> p, const TcpHeader& tcpHeader)
 
   // Put into Rx buffer
   SequenceNumber32 expectedSeq = m_rxBuffer->NextRxSequence ();
-  if (!m_rxBuffer->Add (p, tcpHeader.GetSequenceNumber ()))
+  if (!m_rxBuffer->Add (p, tcpHeader))
     { // Insert failed: No data or RX buffer full
       SendEmptyPacket (TcpHeader::ACK);
       return;
@@ -3169,10 +2470,9 @@ TcpSocketBase::EstimateRtt (const TcpHeader& tcpHeader)
         { // Ok to use this sample
           if (m_timestampEnabled && tcpHeader.HasOption (TcpOption::TS))
             {
-                NS_LOG_WARN("Reenable that");
-//              Ptr<TcpOptionTS> ts;
-//              ts = DynamicCast<TcpOptionTS> (tcpHeader.GetOption (TcpOption::TS));
-//              m = TcpOptionTS::ElapsedTimeFromTsValue (ts->GetEcho ());
+              Ptr<TcpOptionTS> ts;
+              ts = DynamicCast<TcpOptionTS> (tcpHeader.GetOption (TcpOption::TS));
+              m = TcpOptionTS::ElapsedTimeFromTsValue (ts->GetEcho ());
             }
           else
             {
@@ -3199,19 +2499,6 @@ TcpSocketBase::EstimateRtt (const TcpHeader& tcpHeader)
     }
 }
 
-Ptr<const RttEstimator>
-TcpSocketBase::GetRttEstimator()
-{
-    //!
-    return m_rtt;
-}
-
-Time
-TcpSocketBase::ComputeRTO() const
-{
-    return Max (m_rtt->GetEstimate () + Max (m_clockGranularity, m_rtt->GetVariation ()*4), m_minRto);
-}
-
 // Called by the ReceivedAck() when new ACK received and by ProcessSynRcvd()
 // when the three-way handshake completed. This cancels retransmission timer
 // and advances Tx window
@@ -3227,14 +2514,14 @@ TcpSocketBase::NewAck (SequenceNumber32 const& ack)
       m_retxEvent.Cancel ();
       // On receiving a "New" ack we restart retransmission timer .. RFC 6298
       // RFC 6298, clause 2.4
-      m_rto = ComputeRTO();
+      m_rto = Max (m_rtt->GetEstimate () + Max (m_clockGranularity, m_rtt->GetVariation ()*4), m_minRto);
 
       NS_LOG_LOGIC (this << " Schedule ReTxTimeout at time " <<
                     Simulator::Now ().GetSeconds () << " to expire at time " <<
                     (Simulator::Now () + m_rto.Get ()).GetSeconds ());
       m_retxEvent = Simulator::Schedule (m_rto, &TcpSocketBase::ReTxTimeout, this);
     }
-  if (GetRwnd () == 0 && m_persistEvent.IsExpired ())
+  if (m_rWnd.Get () == 0 && m_persistEvent.IsExpired ())
     { // Zero window: Enter persist state to send 1 byte to probe
       NS_LOG_LOGIC (this << "Enter zerowindow persist state");
       NS_LOG_LOGIC (this << "Cancelled ReTxTimeout event which was set to expire at " <<
@@ -3248,19 +2535,15 @@ TcpSocketBase::NewAck (SequenceNumber32 const& ack)
     }
   // Note the highest ACK and tell app to send more
   NS_LOG_LOGIC ("TCP " << this << " NewAck " << ack <<
-                " numberAck " << (ack - FirstUnackedSeq())); // Number bytes ack'ed
-
-//  m_firstTxUnack = std::min(ack, m_txBuffer->TailSequence());
-  m_firstTxUnack = ack;
-  UpdateTxBuffer ();
-
+                " numberAck " << (ack - m_txBuffer->HeadSequence ())); // Number bytes ack'ed
+  m_txBuffer->DiscardUpTo (ack);
   if (GetTxAvailable () > 0)
     {
       NotifySend (GetTxAvailable ());
     }
   if (ack > m_nextTxSequence)
     {
-      m_nextTxSequence = m_firstTxUnack; // If advanced
+      m_nextTxSequence = ack; // If advanced
     }
   if (m_txBuffer->Size () == 0 && m_state != FIN_WAIT_1 && m_state != CLOSING)
     { // No retransmit timer if no data to retransmit
@@ -3275,33 +2558,20 @@ TcpSocketBase::NewAck (SequenceNumber32 const& ack)
     }
 }
 
-void
-TcpSocketBase::UpdateTxBuffer()
-{
-  NS_LOG_FUNCTION(this);
-  m_txBuffer->DiscardUpTo (m_firstTxUnack);
-}
-
 // Retransmit timeout
 void
 TcpSocketBase::ReTxTimeout ()
 {
   NS_LOG_FUNCTION (this);
   NS_LOG_LOGIC (this << " ReTxTimeout Expired at time " << Simulator::Now ().GetSeconds ());
-  
-  // duplicated code here with Retransmit()
   // If erroneous timeout in closed/timed-wait state, just return
   if (m_state == CLOSED || m_state == TIME_WAIT)
     {
-      NS_LOG_WARN ("Retransmit while state=" <<  TcpSocket::TcpStateName[GetState()] );
       return;
     }
   // If all data are received (non-closing socket and nothing to send), just return
-  // used to be FirstUnackedSeq() >= m_highTxMark
-  if (m_state <= ESTABLISHED && FirstUnackedSeq() > m_highTxMark)
+  if (m_state <= ESTABLISHED && m_txBuffer->HeadSequence () >= m_highTxMark)
     {
-      NS_LOG_WARN ("Retransmit while state=" <<  TcpSocket::TcpStateName[GetState()] 
-        << "Check " << FirstUnackedSeq() << ">= " << m_highTxMark );
       return;
     }
 
@@ -3341,10 +2611,31 @@ TcpSocketBase::PersistTimeout ()
   m_persistTimeout = std::min (Seconds (60), Time (2 * m_persistTimeout)); // max persist timeout = 60s
   Ptr<Packet> p = m_txBuffer->CopyFromSequence (1, m_nextTxSequence);
   TcpHeader tcpHeader;
-  GenerateEmptyPacketHeader(tcpHeader, 0);
-//  AddOptions (tcpHeader);
-  SendPacket(tcpHeader,p);
+  tcpHeader.SetSequenceNumber (m_nextTxSequence);
+  tcpHeader.SetAckNumber (m_rxBuffer->NextRxSequence ());
+  tcpHeader.SetWindowSize (AdvertisedWindowSize ());
+  if (m_endPoint != 0)
+    {
+      tcpHeader.SetSourcePort (m_endPoint->GetLocalPort ());
+      tcpHeader.SetDestinationPort (m_endPoint->GetPeerPort ());
+    }
+  else
+    {
+      tcpHeader.SetSourcePort (m_endPoint6->GetLocalPort ());
+      tcpHeader.SetDestinationPort (m_endPoint6->GetPeerPort ());
+    }
+  AddOptions (tcpHeader);
 
+  if (m_endPoint != 0)
+    {
+      m_tcp->SendPacket (p, tcpHeader, m_endPoint->GetLocalAddress (),
+                         m_endPoint->GetPeerAddress (), m_boundnetdevice);
+    }
+  else
+    {
+      m_tcp->SendPacket (p, tcpHeader, m_endPoint6->GetLocalAddress (),
+                         m_endPoint6->GetPeerAddress (), m_boundnetdevice);
+    }
   NS_LOG_LOGIC ("Schedule persist timeout at time "
                 << Simulator::Now ().GetSeconds () << " to expire at time "
                 << (Simulator::Now () + m_persistTimeout).GetSeconds ());
@@ -3354,16 +2645,10 @@ TcpSocketBase::PersistTimeout ()
 void
 TcpSocketBase::Retransmit ()
 {
-  // BOTH CHECKS already done in ReTxTimeout
   // If erroneous timeout in closed/timed-wait state, just return
   if (m_state == CLOSED || m_state == TIME_WAIT) return;
-  
   // If all data are received (non-closing socket and nothing to send), just return
-  // TODO uncommenting this makes test fail
-//  if (m_state <= ESTABLISHED && FirstUnackedSeq() >= m_highTxMark) {
-//    NS_LOG_WARN("WARN");
-//    return;
-//  }
+  if (m_state <= ESTABLISHED && m_txBuffer->HeadSequence () >= m_highTxMark) return;
 
   /*
    * When a TCP sender detects segment loss using the retransmission timer
@@ -3388,7 +2673,7 @@ TcpSocketBase::Retransmit ()
       m_tcb->m_cWnd = m_tcb->m_segmentSize;
     }
 
-  m_nextTxSequence = FirstUnackedSeq (); // Restart from highest Ack
+  m_nextTxSequence = m_txBuffer->HeadSequence (); // Restart from highest Ack
   m_dupAckCount = 0;
   m_tcb->m_ackState = TcpSocketState::LOSS;
   NS_LOG_INFO ("RTO. Reset cwnd to " << m_tcb->m_cWnd <<
@@ -3419,16 +2704,14 @@ TcpSocketBase::DoRetransmit ()
       if (m_state == FIN_WAIT_1 || m_state == CLOSING)
         { // Must have lost FIN, re-send
           SendEmptyPacket (TcpHeader::FIN);
-          // TODO write a member called SendFin
-//          SendFin();
         }
       return;
     }
   // Retransmit a data packet: Call SendDataPacket
-  NS_LOG_LOGIC ("TcpSocketBase " << this << " retxing seq " << FirstUnackedSeq());
-  uint32_t sz = SendDataPacket (FirstUnackedSeq(), GetSegSize(), true);
+  NS_LOG_LOGIC ("TcpSocketBase " << this << " retxing seq " << m_txBuffer->HeadSequence ());
+  uint32_t sz = SendDataPacket (m_txBuffer->HeadSequence (), m_tcb->m_segmentSize, true);
   // In case of RTO, advance m_nextTxSequence
-  m_nextTxSequence = std::max (m_nextTxSequence.Get (), FirstUnackedSeq() + sz);
+  m_nextTxSequence = std::max (m_nextTxSequence.Get (), m_txBuffer->HeadSequence () + sz);
 
   // Increment the retransmit count.
   m_retransOut++;
@@ -3437,7 +2720,6 @@ TcpSocketBase::DoRetransmit ()
 void
 TcpSocketBase::CancelAllTimers ()
 {
-  NS_LOG_FUNCTION_NOARGS();
   m_retxEvent.Cancel ();
   m_persistEvent.Cancel ();
   m_delAckEvent.Cancel ();
@@ -3488,9 +2770,8 @@ TcpSocketBase::GetRcvBufSize (void) const
 void
 TcpSocketBase::SetSegSize (uint32_t size)
 {
-  NS_ABORT_MSG_UNLESS ( (m_state == CLOSED) || (m_tcb->m_segmentSize == size), "Cannot change segment size dynamically.");
   m_tcb->m_segmentSize = size;
-
+  NS_ABORT_MSG_UNLESS (m_state == CLOSED, "Cannot change segment size dynamically.");
 }
 
 uint32_t
@@ -3584,136 +2865,32 @@ TcpSocketBase::GetAllowBroadcast (void) const
   return false;
 }
 
-#if 0
 void
 TcpSocketBase::ReadOptions (const TcpHeader& header)
 {
   NS_LOG_FUNCTION (this << header);
 
-  TcpHeader::TcpOptionList options;
-  header.GetOptions (options);
-
-  for(TcpHeader::TcpOptionList::const_iterator it(options.begin()); it != options.end(); ++it)
-  {
-      //!
-      Ptr<const TcpOption> option = *it;
-      switch(option->GetKind())
-      {
-        case TcpOption::WINSCALE:
-          if ((header.GetFlags () & TcpHeader::SYN) && m_winScalingEnabled && m_state < ESTABLISHED)
+  if ((header.GetFlags () & TcpHeader::SYN))
+    {
+      if (m_winScalingEnabled)
+        {
+          m_winScalingEnabled = false;
+
+          if (header.HasOption (TcpOption::WINSCALE))
             {
-              ProcessOptionWScale (option);
+              m_winScalingEnabled = true;
+              ProcessOptionWScale (header.GetOption (TcpOption::WINSCALE));
               ScaleSsThresh (m_sndScaleFactor);
             }
-            break;
-        case TcpOption::MPTCP:
-            {
-                ProcessOptionMpTcp(option);
-            }
-            break;
-        case TcpOption::TS:
-            if (m_timestampEnabled)
-            {
-                ProcessOptionTimestamp (option);
-            }
-            break;
-        case TcpOption::NOP:
-            {
-
-            }
-            break;
-        default:
-            NS_LOG_WARN("Unsupported option [" << (int)option->GetKind() << "]");
-            break;
-      };
-  }
-
-}
-#endif
-
-// TODO add
-//IsTcpOptionEnabled()
-//{
-//
-//}
-bool
-TcpSocketBase::IsTcpOptionAllowed (uint8_t kind) const
-{
-    NS_LOG_FUNCTION(this << (int)kind);
-
-    switch(kind)
-    {
-    case TcpOption::TS:
-        return m_timestampEnabled;
-    case TcpOption::WINSCALE:
-        return m_winScalingEnabled;
-    case TcpOption::MPTCP:
-        NS_LOG_INFO("MpTcp activ√©=" << m_mptcpEnabled);
-        return m_mptcpEnabled;
-    default:
-        break;
-    };
-    return false;
-}
-
-//bool
-//TcpSocketBase::IsTcpOptionEnabled(uint8_t kind) const
-//{
-//    switch(kind)
-//    {
-//    case TcpOption::TS:
-//        return m_timestampEnabled;
-//    case TcpOption::WINSCALE:
-//        return m_winScalingEnabled;
-//    case TcpOption::MPTCP:
-//        return m_mptcpEnabled;
-//    default:
-//        return false;
-//    };
-//}
-
-uint64_t
-TcpSocketBase::GenerateUniqueMpTcpKey () const
-{
-  NS_LOG_FUNCTION ("Generating key");
-  NS_ASSERT(m_tcp);
-  // TODO rather use NS3 random generator
-//  NS_ASSERT_MSG( m_mptcpLocalKey != 0, "Key already generated");
-
-  uint64_t localKey, idsn;
-  uint32_t localToken;
-
-  do
-  {
-    //! arbitrary function, TODO replace with ns3 random gneerator
-    localKey = (rand() % 1000 + 1);
-    GenerateTokenForKey ( HMAC_SHA1, localKey, &localToken, &idsn );
-  }
-  while (m_tcp->LookupMpTcpToken (localToken));
-
-  return localKey;
-}
-
+        }
+    }
 
-void
-TcpSocketBase::AddMpTcpOptions (TcpHeader& header)
-{
-    NS_LOG_FUNCTION(this);
-    // If key not genereated yet
-//    if (m_mptcpLocalKey == 0)
-//    {
-//      // for the sake of simplicity, we generate a key even if unused
-//      GenerateUniqueMpTcpKey();
-//      NS_LOG_DEBUG("Key/token set to " << m_mptcpLocalKey << "/" << m_mptcpLocalToken);
-//    }
+  m_timestampEnabled = false;
 
-    if((header.GetFlags () == TcpHeader::SYN))
+  if (header.HasOption (TcpOption::TS))
     {
-        // Append the MPTCP capable option
-        Ptr<TcpOptionMpTcpCapable> mpc = CreateObject<TcpOptionMpTcpCapable>();
-        mpc->SetSenderKey (m_mptcpLocalKey);
-        bool res = header.AppendOption (mpc);
-        NS_ASSERT (res);
+      m_timestampEnabled = true;
+      ProcessOptionTimestamp (header.GetOption (TcpOption::TS));
     }
 }
 
@@ -3722,15 +2899,8 @@ TcpSocketBase::AddOptions (TcpHeader& header)
 {
   NS_LOG_FUNCTION (this << header);
 
-  //GetState()
-  if(IsTcpOptionAllowed (TcpOption::MPTCP))
-  {
-    NS_LOG_DEBUG("MPTCP enabled");
-    AddMpTcpOptions(header);
-  }
-
   // The window scaling option is set only on SYN packets
-  if (IsTcpOptionAllowed (TcpOption::WINSCALE) && (header.GetFlags () & TcpHeader::SYN))
+  if (m_winScalingEnabled && (header.GetFlags () & TcpHeader::SYN))
     {
       AddOptionWScale (header);
     }
@@ -3741,23 +2911,6 @@ TcpSocketBase::AddOptions (TcpHeader& header)
     }
 }
 
-int
-TcpSocketBase::ProcessOptionMpTcp ( const Ptr<const TcpOption> option)
-{
-    //!
-//    NS_LOG_DEBUG("Does nothing");
-  Ptr<const TcpOptionMpTcpCapable> mpc = DynamicCast<const TcpOptionMpTcpCapable>(option);
-
-//  if(!GetTcpOption(header, mpc))
-  if (!mpc)
-  {
-      NS_LOG_WARN("Invalid option " << option);
-      return 0;
-  }
-  // else save peerKey ?
-  return 1;
-}
-
 void
 TcpSocketBase::ProcessOptionWScale (const Ptr<const TcpOption> option)
 {
@@ -3765,21 +2918,6 @@ TcpSocketBase::ProcessOptionWScale (const Ptr<const TcpOption> option)
 
   Ptr<const TcpOptionWinScale> ws = DynamicCast<const TcpOptionWinScale> (option);
 
-//   // TODO inverser pr que cela retourne avant de finir
-//  if ((header.GetFlags () & TcpHeader::SYN))
-//    {
-//      if (m_winScalingEnabled)
-//        {
-//          m_winScalingEnabled = false;
-//
-//          if (header.HasOption (TcpOption::WINSCALE))
-//            {
-//              m_winScalingEnabled = true;
-
-//            }
-//        }
-//    }
-
   // In naming, we do the contrary of RFC 1323. The received scaling factor
   // is Rcv.Wind.Scale (and not Snd.Wind.Scale)
   m_rcvScaleFactor = ws->GetScale ();
@@ -3794,7 +2932,6 @@ TcpSocketBase::ProcessOptionWScale (const Ptr<const TcpOption> option)
                  static_cast<int> (m_rcvScaleFactor));
 }
 
-// TODO this should be a static function with params maxBufferSize
 uint8_t
 TcpSocketBase::CalculateWScale () const
 {
@@ -3833,8 +2970,7 @@ TcpSocketBase::AddOptionWScale (TcpHeader &header)
   m_sndScaleFactor = CalculateWScale ();
   option->SetScale (m_sndScaleFactor);
 
-  bool res = header.AppendOption (option);
-  NS_ASSERT (res);
+  header.AppendOption (option);
 
   NS_LOG_INFO (m_node->GetId () << " Send a scaling factor of " <<
                  static_cast<int> (m_sndScaleFactor));
@@ -3848,18 +2984,10 @@ TcpSocketBase::ProcessOptionTimestamp (const Ptr<const TcpOption> option)
   Ptr<const TcpOptionTS> ts = DynamicCast<const TcpOptionTS> (option);
   m_timestampToEcho = ts->GetTimestamp ();
 
-  // TODO move (part of) EstimateRtt here
   NS_LOG_INFO (m_node->GetId () << " Got timestamp=" <<
                m_timestampToEcho << " and Echo="     << ts->GetEcho ());
 }
 
-
-TcpSocket::TcpStates_t
-TcpSocketBase::GetState() const
-{
-    return m_state;
-}
-
 void
 TcpSocketBase::AddOptionTimestamp (TcpHeader& header)
 {
@@ -3870,69 +2998,46 @@ TcpSocketBase::AddOptionTimestamp (TcpHeader& header)
   option->SetTimestamp (TcpOptionTS::NowToTsValue ());
   option->SetEcho (m_timestampToEcho);
 
-  bool res = header.AppendOption (option);
-  NS_ASSERT (res);
+  header.AppendOption (option);
   NS_LOG_INFO (m_node->GetId () << " Add option TS, ts=" <<
                option->GetTimestamp () << " echo=" << m_timestampToEcho);
 }
 
-
-bool
-TcpSocketBase::UpdateWindowSize (const TcpHeader &tcpHeader)
-{
-  NS_LOG_FUNCTION (this << tcpHeader);
-  return UpdateWindowSize (
-    tcpHeader.GetWindowSize (),
-    tcpHeader.GetSequenceNumber (),
-    tcpHeader.GetAckNumber ()
-  );
-}
-
-/**
- * TODO should split those in various functions, really not practical, what if no 
- */
-bool
-TcpSocketBase::UpdateWindowSize (
-  uint32_t receivedUnscaledWindow,
-  SequenceNumber32 sequenceNumber,
-  SequenceNumber32 ackNumber
-)
+void TcpSocketBase::UpdateWindowSize (const TcpHeader &header)
 {
-  NS_LOG_FUNCTION (this << receivedUnscaledWindow << sequenceNumber << ackNumber);
+  NS_LOG_FUNCTION (this << header);
   //  If the connection is not established, the window size is always
   //  updated
-  uint32_t receivedWindow = receivedUnscaledWindow;
+  uint32_t receivedWindow = header.GetWindowSize ();
   receivedWindow <<= m_rcvScaleFactor;
   NS_LOG_DEBUG ("Received (scaled) window is " << receivedWindow << " bytes");
   if (m_state < ESTABLISHED)
     {
       m_rWnd = receivedWindow;
       NS_LOG_DEBUG ("State less than ESTABLISHED; updating rWnd to " << m_rWnd);
-      return true;
+      return;
     }
 
   // Test for conditions that allow updating of the window
-  // 1) segment contains new data (advancing the right edge of the receive
-  // buffer),
-  // 2) segment does not contain new data but the segment acks new data
+  // 1) segment contains new data (advancing the right edge of the receive 
+  // buffer), 
+  // 2) segment does not contain new data but the segment acks new data 
   // (highest sequence number acked advances), or
   // 3) the advertised window is larger than the current send window
   bool update = false;
-  if (ackNumber == m_highRxAckMark && receivedWindow > m_rWnd)
+  if (header.GetAckNumber () == m_highRxAckMark && receivedWindow > m_rWnd)
     {
       // right edge of the send window is increased (window update)
       update = true;
     }
-  if (ackNumber > m_highRxAckMark)
+  if (header.GetAckNumber () > m_highRxAckMark)
     {
-      m_highRxAckMark = ackNumber;
+      m_highRxAckMark = header.GetAckNumber ();
       update = true;
     }
-  
-  // TODO check it's within bounds or is it done elsewhere ? where ?
-  if (sequenceNumber > m_highRxMark)
+  if (header.GetSequenceNumber () > m_highRxMark)
     {
-      m_highRxMark = sequenceNumber;
+      m_highRxMark = header.GetSequenceNumber ();
       update = true;
     }
   if (update == true)
@@ -3940,7 +3045,6 @@ TcpSocketBase::UpdateWindowSize (
       m_rWnd = receivedWindow;
       NS_LOG_DEBUG ("updating rWnd to " << m_rWnd);
     }
-  return update;
 }
 
 void
@@ -3988,24 +3092,6 @@ TcpSocketBase::UpdateCwnd (uint32_t oldValue, uint32_t newValue)
 }
 
 void
-TcpSocketBase::Dump (std::ostream &os) const
-{
-
-  //! TODO assuming it's ipv4
-  if (m_endPoint) {
-    os << m_endPoint->GetLocalAddress () << ":" << m_endPoint->GetLocalPort () << std::endl;
-    os << m_endPoint->GetPeerAddress () << ":" << m_endPoint->GetPeerPort () << std::endl;
-  }
-  os << " TCB:" << std::endl;
-  DumpSocketState (os, m_tcb);
-  os << std::endl;
-  os << "SND.NXT=" << m_nextTxSequence
-     << " SND.UNA=" << FirstUnackedSeq()
-     << " SND.HIGH=" << m_highTxMark
-     << std::endl;
-}
-
-void
 TcpSocketBase::UpdateSsThresh (uint32_t oldValue, uint32_t newValue)
 {
   m_ssThTrace (oldValue, newValue);
@@ -4021,17 +3107,14 @@ TcpSocketBase::UpdateAckState (TcpSocketState::TcpAckState_t oldValue,
 void
 TcpSocketBase::SetCongestionControlAlgorithm (Ptr<TcpCongestionOps> algo)
 {
-  NS_LOG_FUNCTION (this << algo << algo->GetInstanceTypeId());
+  NS_LOG_FUNCTION (this << algo);
   m_congestionControl = algo;
 }
 
 Ptr<TcpSocketBase>
 TcpSocketBase::Fork (void)
 {
-//  return CopyObject<TcpSocketBase> (this);
-  char *addr = new char[sizeof(std::aligned_storage<sizeof(MpTcpSocketBase)>::type)];
-  Ptr<TcpSocketBase> p = Ptr<TcpSocketBase> (new (addr) TcpSocketBase(*this), false);
-  return p;
+  return CopyObject<TcpSocketBase> (this);
 }
 
 //RttHistory methods
diff --git a/src/internet/model/tcp-socket-base.h b/src/internet/model/tcp-socket-base.h
index 964b76e..24b36a9 100644
--- a/src/internet/model/tcp-socket-base.h
+++ b/src/internet/model/tcp-socket-base.h
@@ -40,23 +40,12 @@
 
 namespace ns3 {
 
-
-#define DISABLE_MEMBER(retType,member) retType \
-                                        MpTcpSubflow::member(void) {\
-                                            NS_FATAL_ERROR("This should never be called. The meta will make the subflow pass from LISTEN to ESTABLISHED."); \
-                                        }
-
-
 class Ipv4EndPoint;
 class Ipv6EndPoint;
 class Node;
 class Packet;
 class TcpL4Protocol;
 class TcpHeader;
-class MpTcpSubflow;
-class TcpTraceHelper;
-
-class TcpSocketBase;
 
 /**
  * \ingroup tcp
@@ -133,17 +122,8 @@ public:
 
   // Ack state
   TracedValue<TcpAckState_t> m_ackState; //!< State in the ACK state machine
-
-
-  // MATT HACK to get around TcpSocketState limitations and let TcpCongestionOps 
-  // get access to MPTCP subflows
-  Ptr<TcpSocketBase> m_socket;
-  
 };
 
-
-void DumpSocketState (std::ostream& os, Ptr<TcpSocketState> tcb );
-
 /**
  * \ingroup socket
  * \ingroup tcp
@@ -166,8 +146,6 @@ public:
    * \return the object TypeId
    */
   static TypeId GetTypeId (void);
-  virtual TypeId GetInstanceTypeId() const;
-
   /**
    * Create an unbound TCP socket
    */
@@ -183,10 +161,6 @@ public:
 
   // Set associated Node, TcpL4Protocol, RttEstimator to this socket
 
-
-  Ptr<NetDevice>
-  MapIpToInterface(Ipv4Address) const;
-
   /**
    * \brief Set the associated node.
    * \param node the node
@@ -205,23 +179,6 @@ public:
    */
   virtual void SetRtt (Ptr<RttEstimator> rtt);
 
-
-  virtual Ptr<const RttEstimator> GetRttEstimator();
-
-  /**
-   * \brief Set the first Tx byte not acknowledged yet
-   * \param seq First byte unacknowledged
-   */
-//  virtual void SetTxHead(const SequenceNumber32& seq);
-  virtual void InitPeerISN(const SequenceNumber32& seq);
-  virtual void InitLocalISN();
-  virtual void InitLocalISN(const SequenceNumber32& seq);
-
-
-  virtual SequenceNumber32 FirstUnackedSeq() const;
-
-  virtual TcpSocket::TcpStates_t GetState() const;
-
   /**
    * \brief Sets the Minimum RTO.
    * \param minRto The minimum RTO.
@@ -302,23 +259,6 @@ public:
    */
   void SetCongestionControlAlgorithm (Ptr<TcpCongestionOps> algo);
 
-  // HACK MATT TODO remove, just have a headerMember
-  virtual void GenerateEmptyPacketHeader (TcpHeader& header, uint8_t flags);
-
-  virtual uint32_t GetRwnd() const;
-  // TODO pass on data
-  /**
-  SendPacket should be called straightaway
-  uint8_t flags,
-  **/
-//  virtual void
-//  GenerateDataPacketHeader(TcpHeader& header, SequenceNumber32 seq, bool withAck);
-
-
-  // this one should be private
-//private:
-  // pacekt can be null ?
-//  virtual void SendPacket(TcpHeader header, Ptr<Packet> p);
 
   // Necessary implementations of null functions from ns3::Socket
   virtual enum SocketErrno GetErrno (void) const;    // returns m_errno
@@ -341,45 +281,35 @@ public:
   virtual int GetSockName (Address &address) const; // Return local addr:port in address
   virtual void BindToNetDevice (Ptr<NetDevice> netdevice); // NetDevice with my m_endPoint
 
-  // Return Peer ISN
-  virtual SequenceNumber32 GetLocalIsn(void) const;
-  virtual SequenceNumber32 GetPeerIsn(void) const;
-
-  // Implementing ns3::TcpSocket -- Attribute get/set
-  // inherited, no need to doc
-  virtual uint32_t GetSndBufSize (void) const;
-  virtual uint32_t GetRcvBufSize (void) const;
-  virtual uint32_t GetSegSize (void) const;
-  virtual uint32_t GetInitialSSThresh (void) const;
-  virtual uint32_t GetInitialCwnd (void) const;
-  virtual Time     GetConnTimeout (void) const;
-  virtual uint32_t GetConnCount (void) const;
-  virtual Time     GetDelAckTimeout (void) const;
-  virtual uint32_t GetDelAckMaxCount (void) const;
-  virtual bool     GetTcpNoDelay (void) const;
-  virtual Time     GetPersistTimeout (void) const;
-  virtual bool     GetAllowBroadcast (void) const;
-
 protected:
   // Implementing ns3::TcpSocket -- Attribute get/set
   // inherited, no need to doc
 
   virtual void     SetSndBufSize (uint32_t size);
+  virtual uint32_t GetSndBufSize (void) const;
   virtual void     SetRcvBufSize (uint32_t size);
+  virtual uint32_t GetRcvBufSize (void) const;
   virtual void     SetSegSize (uint32_t size);
+  virtual uint32_t GetSegSize (void) const;
   virtual void     SetInitialSSThresh (uint32_t threshold);
+  virtual uint32_t GetInitialSSThresh (void) const;
   virtual void     SetInitialCwnd (uint32_t cwnd);
-
-//  virtual void     SetLocalISN (SequenceNumber32 seq);
-
-
+  virtual uint32_t GetInitialCwnd (void) const;
   virtual void     SetConnTimeout (Time timeout);
+  virtual Time     GetConnTimeout (void) const;
   virtual void     SetConnCount (uint32_t count);
+  virtual uint32_t GetConnCount (void) const;
   virtual void     SetDelAckTimeout (Time timeout);
+  virtual Time     GetDelAckTimeout (void) const;
   virtual void     SetDelAckMaxCount (uint32_t count);
+  virtual uint32_t GetDelAckMaxCount (void) const;
   virtual void     SetTcpNoDelay (bool noDelay);
+  virtual bool     GetTcpNoDelay (void) const;
   virtual void     SetPersistTimeout (Time timeout);
+  virtual Time     GetPersistTimeout (void) const;
   virtual bool     SetAllowBroadcast (bool allowBroadcast);
+  virtual bool     GetAllowBroadcast (void) const;
+
 
 
   // Helper functions: Connection set up
@@ -429,7 +359,7 @@ protected:
    * \param fromAddress the address of the remote host
    * \param toAddress the address the connection is directed to
    */
-  void CompleteFork (Ptr<const Packet> p, const TcpHeader& tcpHeader, const Address& fromAddress, const Address& toAddress);
+  void CompleteFork (Ptr<Packet> p, const TcpHeader& tcpHeader, const Address& fromAddress, const Address& toAddress);
 
 
 
@@ -443,7 +373,7 @@ protected:
    * \param port the remote port
    * \param incomingInterface the incoming interface
    */
-  virtual void ForwardUp (Ptr<Packet> packet, Ipv4Header header, uint16_t port, Ptr<Ipv4Interface> incomingInterface);
+  void ForwardUp (Ptr<Packet> packet, Ipv4Header header, uint16_t port, Ptr<Ipv4Interface> incomingInterface);
 
   /**
    * \brief Called by the L3 protocol when it received a packet to pass on to TCP.
@@ -493,22 +423,14 @@ protected:
   void ForwardIcmp6 (Ipv6Address icmpSource, uint8_t icmpTtl, uint8_t icmpType, uint8_t icmpCode, uint32_t icmpInfo);
 
   /**
-   * \brief Send as much pending data as possible according to the Tx
-   .
+   * \brief Send as much pending data as possible according to the Tx window.
    *
    * Note that this function did not implement the PSH flag.
    *
    * \param withAck forces an ACK to be sent
    * \returns true if some data have been sent
    */
-  virtual bool SendPendingData (bool withAck = false);
-
-  /**
-   * \Brief Will generate the header and forward it to its overload.
-   *
-   * \see SendDataPacket
-   */
-  virtual uint32_t SendDataPacket (SequenceNumber32 seq, uint32_t maxSize, bool withAck);
+  bool SendPendingData (bool withAck = false);
 
   /**
    * \brief Extract at most maxSize bytes from the TxBuffer at sequence seq, add the
@@ -519,34 +441,19 @@ protected:
    * \param withAck forces an ACK to be sent
    * \returns the number of bytes sent
    */
-  virtual uint32_t SendDataPacket (TcpHeader& header, SequenceNumber32 seq, uint32_t maxSize);
-
-  /**
-   * \brief Generates the header and calls its overload
-   *
-   * \see SendEmptyPacket
-   */
-  virtual void SendEmptyPacket (uint8_t flags);
+  uint32_t SendDataPacket (SequenceNumber32 seq, uint32_t maxSize, bool withAck);
 
   /**
    * \brief Send a empty packet that carries a flag, e.g. ACK
    *
    * \param flags the packet's flags
    */
-  virtual void SendEmptyPacket (TcpHeader& header);
-
-  /**
-   * \brief
-   *
-   * \param header A valid TCP header
-   * \param p Packet to send. May be empty.
-   */
-  virtual void SendPacket(TcpHeader header, Ptr<Packet> p);
+  void SendEmptyPacket (uint8_t flags);
 
   /**
    * \brief Send reset and tear down this socket
    */
-  virtual void SendRST (void);
+  void SendRST (void);
 
   /**
    * \brief Check if a sequence number range is within the rx window
@@ -555,7 +462,7 @@ protected:
    * \param tail end of the Sequence window
    * \returns true if it is in range
    */
-  virtual bool OutOfRange (SequenceNumber32 head, SequenceNumber32 tail) const;
+  bool OutOfRange (SequenceNumber32 head, SequenceNumber32 tail) const;
 
 
   // Helper functions: Connection close
@@ -565,12 +472,12 @@ protected:
    *
    * \returns 0 on success
    */
-  virtual int DoClose (void);
+  int DoClose (void);
 
   /**
    * \brief Peacefully close the socket by notifying the upper layer and deallocate end point
    */
-  virtual void CloseAndNotify (void);
+  void CloseAndNotify (void);
 
   /**
    * \brief Kill this socket by zeroing its attributes (IPv4)
@@ -578,7 +485,7 @@ protected:
    * This is a callback function configured to m_endpoint in
    * SetupCallback(), invoked when the endpoint is destroyed.
    */
-  virtual void Destroy (void);
+  void Destroy (void);
 
   /**
    * \brief Kill this socket by zeroing its attributes (IPv6)
@@ -586,12 +493,12 @@ protected:
    * This is a callback function configured to m_endpoint in
    * SetupCallback(), invoked when the endpoint is destroyed.
    */
-  virtual void Destroy6 (void);
+  void Destroy6 (void);
 
   /**
    * \brief Deallocate m_endPoint and m_endPoint6
    */
-  virtual void DeallocateEndPoint (void);
+  void DeallocateEndPoint (void);
 
   /**
    * \brief Received a FIN from peer, notify rx buffer
@@ -599,22 +506,22 @@ protected:
    * \param p the packet
    * \param tcpHeader the packet's TCP header
    */
-  virtual void PeerClose (Ptr<Packet> p, const TcpHeader& tcpHeader);
+  void PeerClose (Ptr<Packet> p, const TcpHeader& tcpHeader);
 
   /**
    * \brief FIN is in sequence, notify app and respond with a FIN
    */
-  virtual void DoPeerClose (void);
+  void DoPeerClose (void);
 
   /**
    * \brief Cancel all timer when endpoint is deleted
    */
-  virtual void CancelAllTimers (void);
+  void CancelAllTimers (void);
 
   /**
    * \brief Move from CLOSING or FIN_WAIT_2 to TIME_WAIT state
    */
-  virtual void TimeWait (void);
+  void TimeWait (void);
 
   // State transition functions
 
@@ -626,7 +533,7 @@ protected:
    * \param packet the packet
    * \param tcpHeader the packet's TCP header
    */
-  virtual void ProcessEstablished (Ptr<Packet> packet, const TcpHeader& tcpHeader); // Received a packet upon ESTABLISHED state
+  void ProcessEstablished (Ptr<Packet> packet, const TcpHeader& tcpHeader); // Received a packet upon ESTABLISHED state
 
   /**
    * \brief Received a packet upon LISTEN state.
@@ -636,7 +543,7 @@ protected:
    * \param fromAddress the source address
    * \param toAddress the destination address
    */
-  virtual void ProcessListen (Ptr<Packet> packet, const TcpHeader& tcpHeader,
+  void ProcessListen (Ptr<Packet> packet, const TcpHeader& tcpHeader,
                       const Address& fromAddress, const Address& toAddress);
 
   /**
@@ -645,7 +552,7 @@ protected:
    * \param packet the packet
    * \param tcpHeader the packet's TCP header
    */
-  virtual void ProcessSynSent (Ptr<Packet> packet, const TcpHeader& tcpHeader);
+  void ProcessSynSent (Ptr<Packet> packet, const TcpHeader& tcpHeader);
 
   /**
    * \brief Received a packet upon SYN_RCVD.
@@ -655,7 +562,7 @@ protected:
    * \param fromAddress the source address
    * \param toAddress the destination address
    */
-  virtual void ProcessSynRcvd (Ptr<Packet> packet, const TcpHeader& tcpHeader,
+  void ProcessSynRcvd (Ptr<Packet> packet, const TcpHeader& tcpHeader,
                        const Address& fromAddress, const Address& toAddress);
 
   /**
@@ -664,7 +571,7 @@ protected:
    * \param packet the packet
    * \param tcpHeader the packet's TCP header
    */
-  virtual void ProcessWait (Ptr<Packet> packet, const TcpHeader& tcpHeader);
+  void ProcessWait (Ptr<Packet> packet, const TcpHeader& tcpHeader);
 
   /**
    * \brief Received a packet upon CLOSING
@@ -672,7 +579,7 @@ protected:
    * \param packet the packet
    * \param tcpHeader the packet's TCP header
    */
-  virtual void ProcessClosing (Ptr<Packet> packet, const TcpHeader& tcpHeader);
+  void ProcessClosing (Ptr<Packet> packet, const TcpHeader& tcpHeader);
 
   /**
    * \brief Received a packet upon LAST_ACK
@@ -680,7 +587,7 @@ protected:
    * \param packet the packet
    * \param tcpHeader the packet's TCP header
    */
-  virtual void ProcessLastAck (Ptr<Packet> packet, const TcpHeader& tcpHeader);
+  void ProcessLastAck (Ptr<Packet> packet, const TcpHeader& tcpHeader);
 
   // Window management
 
@@ -715,24 +622,19 @@ protected:
   virtual uint16_t AdvertisedWindowSize (void);
 
   /**
-   * \brief Update the receiver window (RWND) based on the value of the
+   * \brief Update the receiver window (RWND) based on the value of the 
    * window field in the header.
    *
-   * This method suppresses updates unless one of the following three
+   * This method suppresses updates unless one of the following three 
    * conditions holds:  1) segment contains new data (advancing the right
    * edge of the receive buffer), 2) segment does not contain new data
    * but the segment acks new data (highest sequence number acked advances),
    * or 3) the advertised window is larger than the current send window
    *
    * \param header TcpHeader from which to extract the new window value
-   * \return true if receiver window got updated
    */
-  virtual bool UpdateWindowSize (const TcpHeader& header);
-  virtual bool UpdateWindowSize (
-    uint32_t receivedUnscaledWindow, 
-    SequenceNumber32 sequenceNumber, 
-    SequenceNumber32 ackNumber
-  );
+  void UpdateWindowSize (const TcpHeader& header);
+
 
   // Manage data tx/rx
 
@@ -747,10 +649,6 @@ protected:
    * \param packet the packet
    * \param tcpHeader the packet's TCP header
    */
-  virtual void ReceivedAck (SequenceNumber32 ack);
-
-  // TODO remove this function
-  // use ReceivedAck (SequenceNumber32 ack); instead and dispatch the packet inspection somewhere else
   virtual void ReceivedAck (Ptr<Packet> packet, const TcpHeader& tcpHeader);
 
   /**
@@ -758,10 +656,7 @@ protected:
    * \param packet the packet
    * \param tcpHeader the packet's TCP header
    */
-  virtual void ReceivedData (Ptr<Packet> packet,
-                             const TcpHeader& tcpHeader
-
-                             );
+  virtual void ReceivedData (Ptr<Packet> packet, const TcpHeader& tcpHeader);
 
   /**
    * \brief Take into account the packet for RTT estimation
@@ -806,100 +701,27 @@ protected:
   virtual void DoRetransmit (void);
 
   /**
-   * \brief Called when a new ack arrvied
-   */
-  virtual void UpdateTxBuffer();
-  /**
    * \brief Read TCP options from incoming packets
-   *
+   *  
    * This method sequentially checks each kind of option, and if it
    * is present in the header, starts its processing.
    *
-   * \note tcp_parse_options in the linux kernel
+   * To deal with hosts which don't have the option enabled (or
+   * implemented) we disable all options, and then re-enable them
+   * if in the packet there is the option itself.
    *
    * \param tcpHeader the packet's TCP header
-   * TODO remove
    */
-//  virtual void ReadOptions (const TcpHeader& tcpHeader);
+  virtual void ReadOptions (const TcpHeader& tcpHeader);
 
   /** \brief Add options to TcpHeader
    *
    * Test each option, and if it is enabled on our side, add it
    * to the header
    *
-   * In linux, options are first enabled ,
-   * then they are generated in tcp_options_write.
-   *
    * \param tcpHeader TcpHeader to add options to
    */
   virtual void AddOptions (TcpHeader& tcpHeader);
-//  virtual void AddOptionsSyn (TcpHeader& tcpHeader);
-
-  /**
-   * This function first generates a copy of the current socket as an MpTcpSubflow.
-   * Then it upgrades the current socket to an MpTcpSocketBase via the use of
-   * "placement new", i.e. it does not allocate new memory but reuse the memory at "this"
-   * address to instantiate MpTcpSocketBase.
-   * Finally the master socket is associated to the meta.
-   *
-   * It is critical that enough memory was allocated beforehand to contain MpTcpSocketBase
-   * (see how it's done for now in TcpL4Protocol).
-   * Ideally MpTcoSocketBase would take less memory than TcpSocketBase, so one of the goal should be to let
-   * MpTcpSocketBase inherit directly from TcpSocket rather than TcpSocketBase.
-   *
-   * The function does not register 
-   * the new subflow in m_tcp->AddSocket, or the meta
-   * this should be taken care
-   * of afterwards.
-   *
-   * TODO might be best in TcpL4Protocol ?
-   *
-   * @param connecting Set to true for the client
-   * \param master
-   * \return master subflow. It is not associated to the meta at this point
-   */
-  virtual Ptr<MpTcpSubflow> UpgradeToMeta(
-    bool connecting,
-    uint64_t locallKey, 
-    uint64_t peerKey
-    );
-
-  void ResetUserCallbacks (void);
-  /**
-   * TODO replace all of them by ProcessTcpOptions ?
-   * than just override processMpTcp depending on the state ?
-   *
-   *
-   * \return if it returns 1, we need to upgrade the meta socket
-   * if negative then it should discard the packet ?
-   */
-  virtual int ProcessTcpOptions(const TcpHeader& header);
-//  virtual int ProcessTcpOptionsSynSent(const TcpHeader& header);
-//  virtual int ProcessTcpOptionsListen(const TcpHeader& header);
-//  virtual int ProcessTcpOptionsSynRcvd(const TcpHeader& header);
-//  virtual int ProcessTcpOptionsEstablished(const TcpHeader& header);
-//  virtual int ProcessTcpOptionsClosing(const TcpHeader& header);
-//  virtual int ProcessTcpOptionsLastAck(const TcpHeader& header);
-//  virtual int ProcessTcpOptionsTimeWait(const TcpHeader& header);
-//  virtual void ProcessSynRcvdOptions(const TcpHeader& hdr);
-
-  /**
-   *
-   */
-//  virtual int ProcessTcpOption(const Ptr<const TcpOption> option);
-  // TODO this should be removed and Tcp Options done in a better way
-//  virtual int ProcessOptionMpTcpEstablished(const Ptr<const TcpOption> option);
-  /**
-   *
-   * \return 1
-   */
-//  virtual int ProcessOptionMpTcpSynSent(const Ptr<const TcpOption> option);
-
-  /**
-   * In this baseclass, this only deals with MpTcpCapable options in order to know if the socket
-   * should be converted to an MPTCP meta socket.
-   */
-  virtual int ProcessOptionMpTcp(const Ptr<const TcpOption> option);
 
   /**
    * \brief Read and parse the Window scale option
@@ -909,13 +731,7 @@ protected:
    *
    * \param option Window scale option read from the header
    */
-  virtual void ProcessOptionWScale (const Ptr<const TcpOption> option);
-
-  /**
-   * Does nothing
-   */
-//  virtual void ProcessOptionMpTcp (const Ptr<const TcpOption> option);
-
+  void ProcessOptionWScale (const Ptr<const TcpOption> option);
   /**
    * \brief Add the window scale option to the header
    *
@@ -924,12 +740,7 @@ protected:
    *
    * \param header TcpHeader where the method should add the window scale option
    */
-  virtual void AddOptionWScale (TcpHeader& header);
-
-  /**
-   *
-   */
-  virtual void AddMpTcpOptions (TcpHeader& header);
+  void AddOptionWScale (TcpHeader& header);
 
   /**
    * \brief Calculate window scale value based on receive buffer space
@@ -979,51 +790,7 @@ protected:
    */
   virtual void InitializeCwnd ();
 
-  /**
-   *
-   */
-  virtual Time ComputeRTO() const;
-
-  /**
-   *
-   */
-  virtual bool IsTcpOptionAllowed (uint8_t  kind) const;
-
-  /**
-   *
-   */
-//  bool IsTcpOptionEnabled(TcpOption::Kind kind) const;
-
-  /**
-   * Generate a unique key for this host
-   * TODO split move it to TcpL4 protocol
-   * or rename into something like SetupLocalKey
-   * \see mptcp_set_key_sk
-   */
-  virtual uint64_t GenerateUniqueMpTcpKey() const;
-
-public:
-  
-  virtual void Dump (std::ostream &os) const;
-  TcpSocketBase& operator =(const TcpSocketBase& s);
-protected:
-//  
-//  //SetupTracingIfEnabled
-//  bool
-//  IsTracingEnabled() const;
-////  bool EnableTracing();
-//  std::string m_tracePrefix;      //!< help naming csv files, TODO should be removed
-////  int m_prefixCounter;      //!< TODO remove and put in a helper
- /****** END TRACING *****/
-
-
 protected:
-  //!< TODO try to remove some friends
-  friend class MpTcpSubflow;
-  friend class MpTcpSchedulerRoundRobin;
-  friend class MpTcpSchedulerDeltaOWD;
-  friend class TcpTraceHelper;
-
   // Counters and events
   EventId           m_retxEvent;       //!< Retransmission event
   EventId           m_lastAckEvent;    //!< Last ACK timeout event
@@ -1056,7 +823,6 @@ protected:
   Ptr<RttEstimator> m_rtt; //!< Round trip time estimator
 
   // Rx and Tx buffer management
-  TracedValue<SequenceNumber32> m_firstTxUnack;   //!< First unacknowledged seq nb  (SND.UNA)
   TracedValue<SequenceNumber32> m_nextTxSequence; //!< Next seqnum to be sent (SND.NXT), ReTx pushes it back
   TracedValue<SequenceNumber32> m_highTxMark;     //!< Highest seqno ever sent, regardless of ReTx
   Ptr<TcpRxBuffer>              m_rxBuffer;       //!< Rx buffer (reordering buffer)
@@ -1078,22 +844,12 @@ protected:
   TracedValue<SequenceNumber32> m_highRxMark;     //!< Highest seqno received
   TracedValue<SequenceNumber32> m_highRxAckMark;  //!< Highest ack received
   uint32_t                      m_bytesAckedNotProcessed;  //!< Bytes acked, but not processed
-  bool m_nullIsn;       //< Should the ISN be null ?
-  // TODO remove, it exists in TcpXxBuffer
-  SequenceNumber32 m_localISN;       //!< Initial sequence number
-  SequenceNumber32 m_peerISN;       //!< Initial sequence number
 
   // Options
-//  bool    m_mptcpAllow;           //!< Window Scale option enabled
-  bool        m_mptcpEnabled;         //!< Window Scale option enabled
-  uint64_t    m_mptcpLocalKey;        //!< MPTCP key
-  uint32_t    m_mptcpLocalToken;      //!< Hash of the key
-
   bool    m_winScalingEnabled;    //!< Window Scale option enabled
   uint8_t m_sndScaleFactor;       //!< Sent Window Scale (i.e., the one of the node)
   uint8_t m_rcvScaleFactor;       //!< Received Window Scale (i.e., the one of the peer)
 
-  bool     m_acceptTimestamp;     //!< Timestamp option enabled
   bool     m_timestampEnabled;    //!< Timestamp option enabled
   uint32_t m_timestampToEcho;     //!< Timestamp to echo
 
@@ -1106,15 +862,7 @@ protected:
   uint32_t               m_lostOut;      //!< number of bytes lost (estimation)
   uint32_t               m_retransOut;   //!< number of bytes retransmitted and not yet ACKed
 
-public:
   Ptr<TcpSocketState> m_tcb;                  //!< Transmission Control Block
-
-protected:
-  
-  /* MATT kind of hack to access window size from DSS processing without changing protoype,
-    might be a good idea overall though
-  */
-  TcpHeader m_receivedHeader;
   Ptr<TcpCongestionOps>  m_congestionControl; //!< Congestion control
 };
 
@@ -1128,8 +876,6 @@ protected:
 typedef void (* TcpAckStatesTracedValueCallback)(const TcpSocketState::TcpAckState_t oldValue,
                                                  const TcpSocketState::TcpAckState_t newValue);
 
-
-#undef DISABLE_MEMBER
 } // namespace ns3
 
 #endif /* TCP_SOCKET_BASE_H */
diff --git a/src/internet/model/tcp-socket.cc b/src/internet/model/tcp-socket.cc
index 7d59682..71fdf0e 100644
--- a/src/internet/model/tcp-socket.cc
+++ b/src/internet/model/tcp-socket.cc
@@ -39,68 +39,6 @@ TcpSocket::TcpStateName[TcpSocket::LAST_STATE] = { "CLOSED", "LISTEN", "SYN_SENT
                                         "LAST_ACK", "FIN_WAIT_1", "FIN_WAIT_2",
                                         "CLOSING", "TIME_WAIT" };
 
-
-TcpState::TcpState() :
-    m_state(LISTEN)
-{
-
-}
-
-TcpState&
-TcpState::operator=(TcpState& rhs)
-{
-    //!
-    TcpStates_t newState = rhs.m_state;
-    switch(newState)
-    {
-        case LISTEN:
-            if(newState == SYN_SENT || newState == SYN_RCVD || newState == CLOSED){
-                m_state = newState;
-                return *this;
-            }
-            break;
-        case SYN_SENT:
-            if(newState == SYN_RCVD || newState == CLOSED || newState == CLOSED || newState == ESTABLISHED) {
-                m_state = newState;
-                return *this;
-            }
-            break;
-
-        case SYN_RCVD:
-            if(newState == CLOSE_WAIT || newState == FIN_WAIT_1) {
-                m_state = newState;
-                return *this;
-            }
-            break;
-
-        case ESTABLISHED:
-            break;
-
-        case FIN_WAIT_1:
-            if(newState == FIN_WAIT_2) {
-                m_state = newState;
-                return *this;
-            }
-            break;
-
-        case CLOSING:
-            if(newState == TIME_WAIT) {
-                m_state = newState;
-                return *this;
-            }
-            break;
-
-        default:
-            break;
-    };
-    //
-    m_state = newState;
-
-    NS_FATAL_ERROR("Wrong TCP transition");
-    return *this;
-}
-
-
 TypeId
 TcpSocket::GetTypeId (void)
 {
diff --git a/src/internet/model/tcp-socket.h b/src/internet/model/tcp-socket.h
index aed0a04..b7d3a05 100644
--- a/src/internet/model/tcp-socket.h
+++ b/src/internet/model/tcp-socket.h
@@ -35,51 +35,6 @@ namespace ns3 {
 class Node;
 class Packet;
 
-
-/**
- * \rename into FSM ?
- */
-class TcpState
-{
-public:
-  /**
-   * \ingroup tcp
-   * \brief Names of the 11 TCP states
-   *
-   */
-  typedef enum {
-    CLOSED = 0,   /**< Socket is finished                                     */
-    LISTEN,       /**< Listening for a connection                             */
-    SYN_SENT,     /**< Sent a connection request, waiting for ack             */
-    SYN_RCVD,     /**< Received a connection request, sent ack,
-                    *  waiting for final ack in three-way handshake.          */
-    ESTABLISHED,  /**< Connection established                                 */
-    CLOSE_WAIT,   /**< Remote side has shutdown and is waiting for
-                    *  us to finish writing our data and to shutdown
-                    *  (we have to close() to move on to LAST_ACK)            */
-    LAST_ACK,     /**< Our side has shutdown after remote has
-                    *  shutdown.  There may still be data in our
-                    *  buffer that we have to finish sending                  */
-    FIN_WAIT_1,   /**< Our side has shutdown, waiting to complete
-                    *  transmission of remaining buffered data                */
-    FIN_WAIT_2,   /**< All buffered data sent, waiting for remote to shutdown */
-    CLOSING,      /**< Both sides have shutdown but we still have
-                    *  data we have to finish sending                         */
-    TIME_WAIT,    /**< Timeout to catch resent junk before entering
-                    *  closed, can only be entered from FIN_WAIT2
-                    *  or CLOSING.  Required because the other end
-                    *  may not have gotten our last ACK causing it
-                    *  to retransmit the data packet (which we ignore)        */
-    LAST_STATE    /**< Last state, used only in debug messages                */
-  } TcpStates_t;
-
-  TcpState();
-  TcpState& operator=(TcpState& state);
-
-private:
-  TcpStates_t m_state;
-};
-
 /**
  * \ingroup socket
  *
@@ -97,7 +52,7 @@ public:
    * \return the object TypeId
    */
   static TypeId GetTypeId (void);
-
+ 
   TcpSocket (void);
   virtual ~TcpSocket (void);
 
diff --git a/src/internet/model/tcp-tx-buffer.cc b/src/internet/model/tcp-tx-buffer.cc
index 14e8179..38ee485 100644
--- a/src/internet/model/tcp-tx-buffer.cc
+++ b/src/internet/model/tcp-tx-buffer.cc
@@ -128,8 +128,8 @@ TcpTxBuffer::SizeFromSequence (const SequenceNumber32& seq) const
   // Sequence of last byte in buffer
   SequenceNumber32 lastSeq = m_firstByteSeq + SequenceNumber32 (m_size);
   // Non-negative size
-  NS_LOG_LOGIC ("HeadSeq=" << m_firstByteSeq << ", size=" << m_size <<
-                ", returns lastSeq(=" << lastSeq << ")-seq(=" << seq << ")="  << lastSeq - seq);
+  NS_LOG_LOGIC ("HeadSeq=" << m_firstByteSeq << ", lastSeq=" << lastSeq << ", size=" << m_size <<
+                ", returns " << lastSeq - seq);
   return lastSeq - seq;
 }
 
diff --git a/src/internet/model/tcp-tx-buffer.h b/src/internet/model/tcp-tx-buffer.h
index a01f5ea..c738e70 100644
--- a/src/internet/model/tcp-tx-buffer.h
+++ b/src/internet/model/tcp-tx-buffer.h
@@ -55,8 +55,7 @@ public:
   // Accessors
 
   /**
-   * Returns the first byte's sequence number, i.e.
-   * the Initial Sequence Number of the connection
+   * Returns the first byte's sequence number
    * \returns the first byte's sequence number
    */
   SequenceNumber32 HeadSequence (void) const;
diff --git a/src/internet/test/ipv4-forwarding-test.cc b/src/internet/test/ipv4-forwarding-test.cc
index a2a254e..3200572 100644
--- a/src/internet/test/ipv4-forwarding-test.cc
+++ b/src/internet/test/ipv4-forwarding-test.cc
@@ -21,7 +21,6 @@
 #include "ns3/test.h"
 #include "ns3/socket-factory.h"
 #include "ns3/udp-socket-factory.h"
-#include "ns3/tcp-socket-factory.h"
 #include "ns3/simulator.h"
 #include "ns3/simple-channel.h"
 #include "ns3/simple-net-device.h"
@@ -37,19 +36,13 @@
 #include "ns3/ipv4-l3-protocol.h"
 #include "ns3/icmpv4-l4-protocol.h"
 #include "ns3/udp-l4-protocol.h"
-#include "ns3/tcp-l4-protocol.h"
 #include "ns3/ipv4-static-routing.h"
-#include "ns3/tcp-socket.h"
-#include "ns3/ipv4-address.h"
-#include "ns3/internet-module.h"  //TODO remove along with PopulateRoutingTables
 
 #include <string>
 #include <limits>
 
 using namespace ns3;
 
-NS_LOG_COMPONENT_DEFINE ("Ipv4ForwardingTest");
-
 static void
 AddInternetStack (Ptr<Node> node)
 {
@@ -69,9 +62,6 @@ AddInternetStack (Ptr<Node> node)
   //UDP
   Ptr<UdpL4Protocol> udp = CreateObject<UdpL4Protocol> ();
   node->AggregateObject (udp);
-  //UDP
-  Ptr<TcpL4Protocol> tcp = CreateObject<TcpL4Protocol> ();
-  node->AggregateObject (tcp);
 }
 
 
@@ -112,6 +102,7 @@ Ipv4ForwardingTest::DoSendData (Ptr<Socket> socket, std::string to)
 void
 Ipv4ForwardingTest::SendData (Ptr<Socket> socket, std::string to)
 {
+  m_receivedPacket = Create<Packet> ();
   Simulator::ScheduleWithContext (socket->GetNode ()->GetId (), Seconds (0),
                                   &Ipv4ForwardingTest::DoSendData, this, socket, to);
   Simulator::Run ();
@@ -190,19 +181,19 @@ Ipv4ForwardingTest::DoRun (void)
   txDev->SetChannel (channel2);
 
   // Create the UDP sockets
-  Ptr<SocketFactory> udpRxSocketFactory = rxNode->GetObject<UdpSocketFactory> ();
-  Ptr<Socket> udpRxSocket = udpRxSocketFactory->CreateSocket ();
-  NS_TEST_EXPECT_MSG_EQ (udpRxSocket->Bind (InetSocketAddress (Ipv4Address ("10.0.0.2"), 1234)), 0, "trivial");
-  udpRxSocket->SetRecvCallback (MakeCallback (&Ipv4ForwardingTest::ReceivePkt, this));
+  Ptr<SocketFactory> rxSocketFactory = rxNode->GetObject<UdpSocketFactory> ();
+  Ptr<Socket> rxSocket = rxSocketFactory->CreateSocket ();
+  NS_TEST_EXPECT_MSG_EQ (rxSocket->Bind (InetSocketAddress (Ipv4Address ("10.0.0.2"), 1234)), 0, "trivial");
+  rxSocket->SetRecvCallback (MakeCallback (&Ipv4ForwardingTest::ReceivePkt, this));
 
-  Ptr<SocketFactory> udpTxSocketFactory = txNode->GetObject<UdpSocketFactory> ();
-  Ptr<Socket> udpTxSocket = udpTxSocketFactory->CreateSocket ();
-  udpTxSocket->SetAllowBroadcast (true);
+  Ptr<SocketFactory> txSocketFactory = txNode->GetObject<UdpSocketFactory> ();
+  Ptr<Socket> txSocket = txSocketFactory->CreateSocket ();
+  txSocket->SetAllowBroadcast (true);
 
   // ------ Now the tests ------------
 
   // Unicast test
-  SendData (udpTxSocket, "10.0.0.2");
+  SendData (txSocket, "10.0.0.2");
   NS_TEST_EXPECT_MSG_EQ (m_receivedPacket->GetSize (), 123, "IPv4 Forwarding on");
 
   m_receivedPacket->RemoveAllByteTags ();
@@ -210,318 +201,9 @@ Ipv4ForwardingTest::DoRun (void)
 
   Ptr<Ipv4> ipv4 = fwNode->GetObject<Ipv4> ();
   ipv4->SetAttribute("IpForward", BooleanValue (false));
-  SendData (udpTxSocket, "10.0.0.2");
-  NS_TEST_EXPECT_MSG_EQ (m_receivedPacket, 0, "IPv4 Forwarding off; no received packet");
-
-  Simulator::Destroy ();
-
-}
-
-class Ipv4BindToNetDeviceTest : public TestCase
-{
-  Ptr<Packet> m_receivedPacket;
-  void DoSendData (Ptr<Socket> socket, std::string to, int expectedReturnValue);
-  void SendData (Ptr<Socket> socket, std::string to, int expectedReturnValue);
-  //, std::string to, int expectedReturnValue
-  void OnConnection (Ptr<Socket> socket
-//                     , const ns3::Address&
-                     );
-  void 
-  HandleAccept (Ptr<Socket> s, const Address& from);
-
-public:
-  virtual void DoRun (void);
-  Ipv4BindToNetDeviceTest ();
-
-  void ReceivePkt (Ptr<Socket> socket);
-};
-
-Ipv4BindToNetDeviceTest::Ipv4BindToNetDeviceTest ()
-  : TestCase ("Test that Socket::BindToNetDevice () works")
-{
-//protected:
-
-}
-
-void Ipv4BindToNetDeviceTest::ReceivePkt (Ptr<Socket> socket)
-{
-  NS_LOG_DEBUG ("Recv cb from " << socket->GetInstanceTypeId().GetName());
-  uint32_t availableData;
-  availableData = socket->GetRxAvailable ();
-//  NS_LOG_UNCOND (" available data " << availableData);
-  m_receivedPacket = socket->Recv (std::numeric_limits<uint32_t>::max (), 0);
-  NS_LOG_UNCOND (" m_receivedPacket=" << m_receivedPacket);
-  NS_ASSERT (availableData == m_receivedPacket->GetSize ());
-}
-
-void
-Ipv4BindToNetDeviceTest::DoSendData (Ptr<Socket> socket, std::string to, int expectedReturnValue)
-{
-  Address realTo = InetSocketAddress (Ipv4Address (to.c_str ()), 1234);
-  NS_TEST_EXPECT_MSG_EQ (socket->SendTo (Create<Packet> (123), 0, realTo),
-                         expectedReturnValue, "SendTo failure");
-}
-
-void
-Ipv4BindToNetDeviceTest::SendData (Ptr<Socket> socket, std::string to, int expectedReturnValue)
-{
-  Simulator::ScheduleWithContext (socket->GetNode ()->GetId (), Seconds (0),
-                                  &Ipv4BindToNetDeviceTest::DoSendData, this, socket, to, expectedReturnValue);
-}
-
-
-void
-Ipv4BindToNetDeviceTest::OnConnection (Ptr<Socket> socket
-//                                       , const ns3::Address&
-                                       )
-{
-    NS_LOG_INFO ("Send connection");
-    Simulator::Schedule (Seconds (0), &TcpSocketBase::Send, DynamicCast<TcpSocketBase>(socket), Create<Packet> (123), 0);
-//    int ret = socket->Send (Create<Packet> (123));
-//    NS_TEST_EXPECT_MSG_EQ ( ret, 0, "Could not send packet" << ret);
-}
-
-void 
-Ipv4BindToNetDeviceTest::HandleAccept (Ptr<Socket> s, const Address& from)
-{
-  NS_LOG_FUNCTION (this << s << from);
-  s->SetRecvCallback (MakeCallback (&Ipv4BindToNetDeviceTest::ReceivePkt, this));
-//  s->SetRecvCallback (MakeCallback (&PacketSink::HandleRead, this));
-//  m_socketList.push_back (s);
-}
-
-void
-Ipv4BindToNetDeviceTest::DoRun (void)
-{
-  /** Create topology
-  ________________________________________
-  |      txNode                           |
-  | txDev1 (10.0.0.1) | txDev2 (11.0.0.1) |
-  |___________________|___________________|
-          |                    |
-          |                    |
-          |                    |
-          |                    |
-  ________________________________________
-  |      rxNode                           |
-  | rxDev1 (10.0.0.2) | rxDev2 (11.0.0.2) |
-  |___________________|___________________|
-  **/
-  Ipv4Address receiverIP[2], senderIP[2];
-  receiverIP[0] = Ipv4Address ("10.0.0.2");
-  receiverIP[1] = Ipv4Address ("11.0.0.2");
-
-  senderIP[0] = Ipv4Address ("10.0.0.1");
-  senderIP[1] = Ipv4Address ("11.0.0.1");
-
-  // Receiver Node
-  Ptr<Node> rxNode = CreateObject<Node> ();
-  NS_LOG_UNCOND ("rxNode" << rxNode->GetSystemId());
-  AddInternetStack (rxNode);
-  Ptr<SimpleNetDevice> rxDev1;
-  Ptr<SimpleNetDevice> rxDev2;
-  { // first interface
-    rxDev1 = CreateObject<SimpleNetDevice> ();
-    rxDev1->SetAddress (Mac48Address::ConvertFrom (Mac48Address::Allocate ()));
-    rxNode->AddDevice (rxDev1);
-    Ptr<Ipv4> ipv4 = rxNode->GetObject<Ipv4> ();
-    uint32_t netdev_idx = ipv4->AddInterface (rxDev1);
-    Ipv4InterfaceAddress ipv4Addr = Ipv4InterfaceAddress ( receiverIP[0], Ipv4Mask (0xffff0000U));
-    ipv4->AddAddress (netdev_idx, ipv4Addr);
-    ipv4->SetUp (netdev_idx);
-  }
-  { // second interface
-    rxDev2 = CreateObject<SimpleNetDevice> ();
-    rxDev2->SetAddress (Mac48Address::ConvertFrom (Mac48Address::Allocate ()));
-    rxNode->AddDevice (rxDev2);
-    Ptr<Ipv4> ipv4 = rxNode->GetObject<Ipv4> ();
-    uint32_t netdev_idx = ipv4->AddInterface (rxDev2);
-    Ipv4InterfaceAddress ipv4Addr = Ipv4InterfaceAddress (receiverIP[1], Ipv4Mask (0xffff0000U));
-    ipv4->AddAddress (netdev_idx, ipv4Addr);
-    ipv4->SetUp (netdev_idx);
-  }
-
-  // Sender Node
-  Ptr<Node> txNode = CreateObject<Node> ();
-  AddInternetStack (txNode);
-  Ptr<SimpleNetDevice> txDev1;
-  Ptr<SimpleNetDevice> txDev2;
-  {
-    // first interface
-    txDev1 = CreateObject<SimpleNetDevice> ();
-    txDev1->SetAddress (Mac48Address::ConvertFrom (Mac48Address::Allocate ()));
-    txNode->AddDevice (txDev1);
-    Ptr<Ipv4> ipv4 = txNode->GetObject<Ipv4> ();
-    uint32_t netdev_idx = ipv4->AddInterface (txDev1);
-    Ipv4InterfaceAddress ipv4Addr = Ipv4InterfaceAddress (senderIP[0], Ipv4Mask (0xffff0000U));
-    ipv4->AddAddress (netdev_idx, ipv4Addr);
-    ipv4->SetUp (netdev_idx);
-  }
-  {
-    // second interface
-    txDev2 = CreateObject<SimpleNetDevice> ();
-    txDev2->SetAddress (Mac48Address::ConvertFrom (Mac48Address::Allocate ()));
-    txNode->AddDevice (txDev2);
-    Ptr<Ipv4> ipv4 = txNode->GetObject<Ipv4> ();
-    uint32_t netdev_idx = ipv4->AddInterface (txDev2);
-    Ipv4InterfaceAddress ipv4Addr = Ipv4InterfaceAddress (senderIP[1], Ipv4Mask (0xffff0000U));
-    ipv4->AddAddress (netdev_idx, ipv4Addr);
-    ipv4->SetUp (netdev_idx);
-  }
-
-  // link the two nodes
-  Ptr<SimpleChannel> channel1 = CreateObject<SimpleChannel> ();
-  rxDev1->SetChannel (channel1);
-  txDev1->SetChannel (channel1);
-
-  Ptr<SimpleChannel> channel2 = CreateObject<SimpleChannel> ();
-  rxDev2->SetChannel (channel2);
-  txDev2->SetChannel (channel2);
-
-  // Create the UDP sockets
-  Ptr<SocketFactory> udpRxSocketFactory = rxNode->GetObject<UdpSocketFactory> ();
-  Ptr<Socket> udpRxSocket = udpRxSocketFactory->CreateSocket ();
-  NS_TEST_EXPECT_MSG_EQ (udpRxSocket->Bind (InetSocketAddress ( receiverIP[0], 1234)), 0, "Successful call to Bind.");
-  // Must call BindToNetDevice() after Bind()
-  udpRxSocket->SetRecvCallback (MakeCallback (&Ipv4BindToNetDeviceTest::ReceivePkt, this));
-
-  Ptr<SocketFactory> udpTxSocketFactory = txNode->GetObject<UdpSocketFactory> ();
-  Ptr<Socket> udpTxSocket = udpTxSocketFactory->CreateSocket ();
-  udpTxSocket->SetAllowBroadcast (true);
-
-  
-
-  // ------ Now the UDP tests ------------
-
-  // Test that data is successful when RxNode binds to rxDev1 and TxNode binds
-  // to txDev1
-  NS_LOG_DEBUG ("Bind test case 1");
-  udpRxSocket->BindToNetDevice (rxDev1);
-  udpTxSocket->BindToNetDevice (txDev1);
-  SendData (udpTxSocket, "10.0.0.2", 123);  // 123 is the expected Send() return value
-  Simulator::Run ();
-  NS_TEST_EXPECT_MSG_NE (m_receivedPacket, 0, "Incorrectly bound NetDevices");
-//  NS_TEST_EXPECT_MSG_EQ (m_receivedPacket->GetSize (), 123, "Correctly bound NetDevices");
-  m_receivedPacket = 0;
-
-  // All three other bind combinations should fail 
-  
-  NS_LOG_DEBUG ("Bind test case 2");
-  udpTxSocket = udpTxSocketFactory->CreateSocket ();
-  udpRxSocket->BindToNetDevice (rxDev1);
-  udpTxSocket->BindToNetDevice (txDev2);
-  SendData (udpTxSocket, "10.0.0.2", -1);
-  Simulator::Run ();
-  NS_TEST_EXPECT_MSG_EQ (m_receivedPacket, 0, "No received packet");
-  m_receivedPacket = 0;
-
-  NS_LOG_DEBUG ("Bind test case 3");
-  udpTxSocket = udpTxSocketFactory->CreateSocket ();
-  udpRxSocket->BindToNetDevice (rxDev2);
-  udpTxSocket->BindToNetDevice (txDev2);
-  SendData (udpTxSocket, "10.0.0.2", -1);
-  Simulator::Run ();
-  NS_TEST_EXPECT_MSG_EQ (m_receivedPacket, 0, "No received packet");
-  m_receivedPacket = 0;
-
-  NS_LOG_DEBUG ("Bind test case 4");
-  udpTxSocket = udpTxSocketFactory->CreateSocket ();
-  udpRxSocket->BindToNetDevice (rxDev2);
-  udpTxSocket->BindToNetDevice (txDev1);
-  SendData (udpTxSocket, "10.0.0.2", 123);
-  Simulator::Run ();
-  NS_TEST_EXPECT_MSG_EQ (m_receivedPacket, 0, "No received packet");
-  m_receivedPacket = 0;
-
-
-  // ------ Now the TCP tests ------------
-  // ERROR == No route found for forwarding packet.  Drop.¬†
-  // Launched via ./waf --run test-runner --command-template="gdb -ex 'run --suite=ipv4-forwarding --verbose' --args %s"
-
-    
-  // Create the TCP sockets
-  /////////
-  Ptr<SocketFactory> tcpRxSocketFactory = rxNode->GetObject<TcpSocketFactory> ();
-  Ptr<Socket> tcpRxSocket = tcpRxSocketFactory->CreateSocket ();
-  NS_TEST_EXPECT_MSG_EQ (tcpRxSocket->Bind (InetSocketAddress (receiverIP[1], 1234)), 0, "Successful call to Bind.");
-  // Must call BindToNetDevice() after Bind()
-//  Callback<Ptr, const Address&>connectionRequest, Callback, Ptr, const Address&>newConnectionCreated
-  tcpRxSocket->SetAcceptCallback( MakeNullCallback<bool, Ptr<Socket>, const Address &> (),
-    MakeCallback (&Ipv4BindToNetDeviceTest::HandleAccept, this));
-
-//  (MakeCallback (&Ipv4BindToNetDeviceTest::ReceivePkt, this));
-  tcpRxSocket->SetRecvCallback (MakeCallback (&Ipv4BindToNetDeviceTest::ReceivePkt, this));
-  tcpRxSocket->Listen ();
-  Ptr<SocketFactory> tcpTxSocketFactory = txNode->GetObject<TcpSocketFactory> ();
-//  Ptr<TcpSocket> tcpTxSocket = DynamicCast<TcpSocket>(tcpTxSocketFactory->CreateSocket () );
-  Ptr<Socket> tcpTxSocket = tcpTxSocketFactory->CreateSocket ();
-//  tcpTxSocket->SetAllowBroadcast (true);
-
-
-  // Create router nodes, initialize routing database and set up the routing
-  // tables in the nodes.  We excuse the bridge nodes from having to serve as
-  // routers, since they don't even have internet stacks on them.
-  //
-//  Ipv4GlobalRoutingHelper::PopulateRoutingTables ();
-
-  // Test that data is successful when RxNode binds to rxDev1 and TxNode binds
-  // to txDev1
-  NS_LOG_DEBUG ("TCP Bind test case 1");
-  InetSocketAddress serverAddr (receiverIP[1], 1234 );
-  InetSocketAddress senderAddr (senderIP[1],   4321 );
-
-//  tcpRxSocket->BindToNetDevice (rxDev1);
-//  tcpTxSocket->BindToNetDevice (txDev1);
-  // MATT bind must be automatic, without any custom call to BindToNetDevice
-  NS_TEST_EXPECT_MSG_EQ (tcpTxSocket->Bind (senderAddr), 0, "TCP bind failed" );
-//  tcpRxSocket->SetAcceptCallback( MakeNullCallback<bool, Ptr<Socket>, const ns3::Address& > (),
-//                                 MakeCallback(&Ipv4BindToNetDeviceTest::OnConnection, this) );
-
-  tcpTxSocket->SetConnectCallback ( MakeCallback (&Ipv4BindToNetDeviceTest::OnConnection, this),
-                                   MakeNullCallback<void, Ptr<Socket> > ()
-                                  );
-
-  NS_TEST_EXPECT_MSG_EQ (tcpTxSocket->Connect ( serverAddr ), 0 , "Connect failed");
-
-  //! Make sure packet can only travel through channel2, which should be the logical path
-  channel1->BlackList(txDev1, rxDev1);
-  //  channel2->BlackList(txDev2, rxDev2);
-
-//  SendData (tcpTxSocket, "10.0.0.2", 123);  // 123 is the expected Send() return value
-
-  Simulator::Run ();
-  std::cout << "End of test";
-  NS_TEST_EXPECT_MSG_NE (m_receivedPacket, 0, "A packet should have been received");
-//  NS_TEST_EXPECT_MSG_EQ (m_receivedPacket->GetSize (), 123, "Correctly bound NetDevices");
-  m_receivedPacket = 0;
-
-  // All three other bind combinations should fail 
-  
-//  NS_LOG_DEBUG ("Bind test case 2");
-//  tcpTxSocket = tcpTxSocketFactory->CreateSocket ();
-//  tcpRxSocket->BindToNetDevice (rxDev1);
-//  tcpTxSocket->BindToNetDevice (txDev2);
-//  SendData (tcpTxSocket, "10.0.0.2", -1);
-//  Simulator::Run ();
-//  NS_TEST_EXPECT_MSG_EQ (m_receivedPacket, 0, "No received packet");
-//
-//  NS_LOG_DEBUG ("Bind test case 3");
-//  tcpTxSocket = tcpTxSocketFactory->CreateSocket ();
-//  tcpRxSocket->BindToNetDevice (rxDev2);
-//  tcpTxSocket->BindToNetDevice (txDev2);
-//  SendData (tcpTxSocket, "10.0.0.2", -1);
-//  Simulator::Run ();
-//  NS_TEST_EXPECT_MSG_EQ (m_receivedPacket, 0, "No received packet");
-//
-//  NS_LOG_DEBUG ("Bind test case 4");
-//  tcpTxSocket = tcpTxSocketFactory->CreateSocket ();
-//  tcpRxSocket->BindToNetDevice (rxDev2);
-//  tcpTxSocket->BindToNetDevice (txDev1);
-//  SendData (tcpTxSocket, "10.0.0.2", 123);
-//  Simulator::Run ();
-//  NS_TEST_EXPECT_MSG_EQ (m_receivedPacket, 0, "No received packet");
+  SendData (txSocket, "10.0.0.2");
+  NS_TEST_EXPECT_MSG_EQ (m_receivedPacket->GetSize (), 0, "IPv4 Forwarding off");
 
-  
   Simulator::Destroy ();
 
 }
@@ -535,6 +217,5 @@ public:
   Ipv4ForwardingTestSuite () : TestSuite ("ipv4-forwarding", UNIT)
   {
     AddTestCase (new Ipv4ForwardingTest, TestCase::QUICK);
-    AddTestCase (new Ipv4BindToNetDeviceTest, TestCase::QUICK);
   }
 } g_ipv4forwardingTestSuite;
diff --git a/src/internet/test/mptcp-crypto-test.cc b/src/internet/test/mptcp-crypto-test.cc
deleted file mode 100644
index 3a73f6e..0000000
--- a/src/internet/test/mptcp-crypto-test.cc
+++ /dev/null
@@ -1,135 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2007 Georgia Tech Research Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-
-#include "ns3/log.h"
-#include "ns3/test.h"
-#include "ns3/mptcp-crypto.h"
-
-NS_LOG_COMPONENT_DEFINE ("MpTcpCryptoTest");
-
-namespace ns3 {
-
-/* client initiates connection => SYN */
-typedef struct _crypto_material {
-uint64_t keyClient;
-uint64_t keyServer;
-uint32_t expectedTokenClient;
-uint32_t expectedTokenServer;
-/* it makes little sense to test these but just in case */
-uint32_t nonceSyn;
-uint32_t nonceSynAck;
-uint64_t expectedHmacSynAck;
-uint32_t expectedHmacAck;
-uint64_t expectedIdsnClient;
-uint64_t expectedIdsnServer;
-} crypto_materials_t;
-
-
-/**
-Used to test key/token generation
-**/
-class MpTcpCryptoTest : public TestCase
-{
-public:
-
-  MpTcpCryptoTest(crypto_materials_t t) :
-      TestCase("MPTCP crypto test with values ..."),
-      m_c(t)
-  {
-    NS_LOG_FUNCTION(this);
-  }
-
-  virtual ~MpTcpCryptoTest()
-  {
-      NS_LOG_FUNCTION(this);
-  }
-
-  virtual void DoRun(void)
-  {
-    const mptcp_crypto_alg_t algo = HMAC_SHA1;
-    uint32_t tokenClient = 0, tokenServer = 0;
-    uint64_t idsnClient = 0, idsnServer = 0;
-
-    GenerateTokenForKey( algo, m_c.keyServer, &tokenServer, &idsnServer);
-    GenerateTokenForKey( algo, m_c.keyClient, &tokenClient, &idsnClient);
-//    NS_LOG_INFO( "Client: Generated token "<< tokenClient << ". Expected "<< m_c.expectedTokenClient);
-//    NS_LOG_INFO( "Client: Generated idsn "<< idsnClient << ". Expected "<< m_c.expectedIdsnClient);
-//
-//    NS_LOG_INFO( "Server: Generated token " << tokenServer << ". Expected "<< m_c.expectedTokenServer);
-//    NS_LOG_INFO( "Server: Generated idsn " << idsnServer << ". Expected "<< m_c.expectedIdsnServer);
-    NS_TEST_EXPECT_MSG_EQ( tokenClient, m_c.expectedTokenClient, "Token generated does not match key (Client)");
-    NS_TEST_EXPECT_MSG_EQ( idsnClient, m_c.expectedIdsnClient, "Token generated does not match key (Client)");
-
-    NS_TEST_EXPECT_MSG_EQ( tokenServer, m_c.expectedTokenServer, "Token generated does not match key (Server)");
-    NS_TEST_EXPECT_MSG_EQ( idsnServer, m_c.expectedIdsnServer, "Token generated does not match key (Server)");
-
-  }
-
-protected:
-  crypto_materials_t m_c;
-};
-
-
-static class TcpOptionMpTcpTestSuite : public TestSuite
-{
-public:
- TcpOptionMpTcpTestSuite ()
- : TestSuite ("mptcp-crypto", UNIT)
- {
-
-    const uint64_t keyClient = 17578475652852252522U;
-    const uint64_t keyServer = 4250710109353306436U;
-    // Notice the 'U' suffix at the end of the number . By default compiler
-    // considers int as signed, thus triggering a warning
-    crypto_materials_t c = {
-      .keyClient = keyClient,
-      .keyServer = keyServer,
-      /*expectedTokenClient computed from SynAck key */
-      #ifdef HAVE_CRYPTO
-      .expectedTokenClient = 781076417,
-      .expectedTokenServer = 109896498,
-      #else
-      .expectedTokenClient = (uint32_t)keyClient,
-      .expectedTokenServer = (uint32_t)keyServer,
-      #endif
-      .nonceSyn = 4179070691,
-      .nonceSynAck = 786372555,
-      .expectedHmacSynAck = 17675966670101668951U,
-      .expectedHmacAck = 0,
-      #ifdef HAVE_CRYPTO
-      .expectedIdsnClient = 2027218329290435821U,
-      .expectedIdsnServer = 14296996231892742347U
-      #else
-      .expectedIdsnClient = keyClient,
-      .expectedIdsnServer  = keyServer
-      #endif
-    };
-
-    AddTestCase( new MpTcpCryptoTest(c), QUICK );
-
-
- }
-
-
-
-
-} g_TcpCryptoTestSuite;
-
-}
diff --git a/src/internet/test/mptcp-mapping-test.cc b/src/internet/test/mptcp-mapping-test.cc
deleted file mode 100644
index a007850..0000000
--- a/src/internet/test/mptcp-mapping-test.cc
+++ /dev/null
@@ -1,323 +0,0 @@
-/**
-Should be one testsuite for TcpTxBuffer too
-
-**/
-
-#include "ns3/mptcp-mapping.h"
-#include "ns3/log.h"
-#include "ns3/test.h"
-
-
-NS_LOG_COMPONENT_DEFINE ("MpTcpMappingTestSuite");
-
-using namespace ns3;
-
-
-
-class MpTcpMappingTestCase : public TestCase
-{
-public:
-    MpTcpMappingTestCase (
-      SequenceNumber64 headDSN, SequenceNumber32 mappedToSSN, uint16_t length,
-      SequenceNumber64 headDSNbis, SequenceNumber32 mappedToSSNbis, uint16_t length2,
-      bool overlap
-
-      ) :
-        TestCase("Mptcp mapping testcase"),
-        //posLShd{250, 330, 512, 600, 680} // non static array initializers only available in C++11
-
-
-        m_headDSN(headDSN),
-        m_mappedSSN(mappedToSSN),
-        m_length(length),
-
-        m_headDSNbis(headDSNbis),
-        m_mappedSSNbis(mappedToSSNbis),
-        m_lengthbis(length2),
-
-        m_shouldOverlap(overlap)
-    {
-        NS_LOG_FUNCTION(this);
-//        m_headDSN[0] = headDSN;
-//        m_headDSN[1] = headDSN2;
-    }
-
-    virtual ~MpTcpMappingTestCase ()
-    {
-        NS_LOG_FUNCTION(this);
-    }
-
-    virtual void DoRun(void)
-    {
-      MpTcpMapping map0, map1, map2;
-      MpTcpMappingContainer con0,con1;
-
-//      map0.Configure(m_headDSN, m_length);
-      map0.SetHeadDSN( m_headDSN );
-      map0.SetMappingSize( m_length );
-      NS_TEST_EXPECT_MSG_EQ( map0.HeadDSN(), m_headDSN, "Broken setter or getter");
-      NS_TEST_EXPECT_MSG_EQ( map0.GetLength(), m_length, "Broken setter");
-
-      map0.MapToSSN( m_mappedSSN );
-      map1 = map0;
-
-
-      NS_TEST_EXPECT_MSG_EQ( map0.TailDSN(), m_headDSN + (uint32_t)m_length-1,"Tail DSN in included in the mapping");
-      NS_TEST_EXPECT_MSG_EQ( map0.TailSSN(), m_mappedSSN + (uint32_t)m_length-1, "Tail SSN should be included in the mapping");
-
-
-//      NS_TEST_ASSERT()
-
-      NS_TEST_EXPECT_MSG_EQ(map1, map0, "Mappings have all values in common");
-      map1.MapToSSN(m_headDSN - (uint32_t)m_length);
-      // Not true anymore
-//      NS_TEST_EXPECT_MSG_EQ(map1, map0, "Mappings should be considered equal even if they are mappped to different SSN");
-
-
-      //,""
-      SequenceNumber64 temp;
-
-      NS_TEST_EXPECT_MSG_EQ(map0.TranslateSSNToDSN(map0.HeadSSN()- 4, temp), false, "ssn should not be in range");
-      NS_TEST_EXPECT_MSG_EQ(map0.TranslateSSNToDSN(map0.HeadSSN(), temp), true, "ssn should be in range");
-      NS_TEST_EXPECT_MSG_EQ(temp, map0.HeadDSN(), "HeadSSN must map to HeadDSN");
-
-      NS_TEST_EXPECT_MSG_EQ(map0.TranslateSSNToDSN(map0.TailSSN() + 4, temp), false, "ssn should not be in range");
-      NS_TEST_EXPECT_MSG_EQ(map0.TranslateSSNToDSN(map0.TailSSN(), temp), true, "ssn should be in range");
-      NS_TEST_EXPECT_MSG_EQ(temp, map0.TailDSN(), "TailSSN must map to HeadDSN");
-
-
-
-      /////////////////////////////////////////////////////////
-      /////
-      /////
-      /////////////////////////////////////////////////////////
-
-      ///// Check SSNoverlap
-      ///////////////////////////////////////////
-      NS_TEST_EXPECT_MSG_EQ( map0.OverlapRangeSSN(map0.HeadSSN()-4, 2), false,"starting at -4 with length of 2 does not overlap");
-      NS_TEST_EXPECT_MSG_EQ( map0.OverlapRangeSSN(map0.HeadSSN(), 1), true, "HeadSSN is part of the mapping so it must overlap");
-      NS_TEST_EXPECT_MSG_EQ( map0.OverlapRangeSSN(map0.TailSSN(), 1), true, "TailSSN is part of the mapping so it must overlap");
-      NS_TEST_EXPECT_MSG_EQ( map0.OverlapRangeSSN(map0.TailSSN()+1, 4), false, "Data after the mapping, must not overlap");
-
-      ///// Check DSNoverlap
-      ///////////////////////////////////////////
-      NS_TEST_EXPECT_MSG_EQ( map0.OverlapRangeDSN(map0.HeadDSN()-4, 2), false,"starting at -4 with length of 2 does not overlap");
-      NS_TEST_EXPECT_MSG_EQ( map0.OverlapRangeDSN(map0.HeadDSN()-4, 6), true,"starting at -4 with length of 6 does not overlap");
-      NS_TEST_EXPECT_MSG_EQ( map0.OverlapRangeDSN(map0.HeadDSN(), 1), true, "HeadDSN is part of the mapping so it must overlap");
-      NS_TEST_EXPECT_MSG_EQ( map0.OverlapRangeDSN(map0.TailDSN(), 1), true, "TailDSN is part of the mapping so it must overlap");
-      NS_TEST_EXPECT_MSG_EQ( map0.OverlapRangeDSN(map0.TailDSN()+1, 4), false, "Data after the mapping, must not overlap");
-
-
-      ///// Check DSNInRange
-      ///////////////////////////////////////////
-      NS_TEST_EXPECT_MSG_EQ( map0.IsDSNInRange(map0.HeadDSN()), true, "test ");
-      NS_TEST_EXPECT_MSG_EQ( map0.IsDSNInRange(map0.TailDSN()), true, "");
-      NS_TEST_EXPECT_MSG_EQ( map0.IsDSNInRange(map0.HeadDSN()-1 ), false, "");
-      NS_TEST_EXPECT_MSG_EQ( map0.IsDSNInRange(map0.TailDSN()+1 ), false,"");
-
-      ///// Check SSNInRange
-      ///////////////////////////////////////////
-      // TODO maybe do some of the tests only
-      NS_TEST_EXPECT_MSG_EQ( map0.IsSSNInRange(map0.HeadSSN()), true, "First byte is part of the mapping");
-      NS_TEST_EXPECT_MSG_EQ( map0.IsSSNInRange(map0.TailSSN()), true, "Last byte is part of the mapping");
-      NS_TEST_EXPECT_MSG_EQ( map0.IsSSNInRange(map0.HeadSSN()-1), false, "Byte just before first byte is not part of the mapping");
-      NS_TEST_EXPECT_MSG_EQ( map0.IsSSNInRange(map0.TailSSN()+1), false, "Byte just after last byte is not part of the mapping");
-
-
-
-
-
-
-
-//      con0.AddMapping(map0);
-      MpTcpMapping ret, overlap;
-//      overlap.SetHeadDSN(map0.HeadDSN());
-//      overlap.SetMappingSize(map0.GetLength() + 4);
-      overlap.SetHeadDSN(m_headDSNbis);
-      overlap.SetMappingSize(m_lengthbis);
-      overlap.MapToSSN(m_mappedSSNbis);
-
-      NS_TEST_EXPECT_MSG_EQ(con0.AddMapping(map0), true, "This is the first mapping registered");
-      NS_TEST_EXPECT_MSG_EQ(con1.AddMapping(overlap), true, "This is the first mapping registered");
-
-//      NS_TEST_EXPECT_MSG_EQ(con0.FindOverlappingMapping(map0, false, ret), true, "Don't ignore identical mappings");
-//      NS_TEST_EXPECT_MSG_EQ(ret, map0, "Previous test should have filled ret with mapping equal to map0");
-
-//      NS_TEST_EXPECT_MSG_EQ(con0.FindOverlappingMapping(overlap, false, ret), m_shouldOverlap, "Ignore identical mappings so it should find none");
-//      NS_TEST_EXPECT_MSG_EQ(con1.FindOverlappingMapping(map0, false, ret), m_shouldOverlap, "Ignore identical mappings so it should find none");
-
-
-
-
-      //! Now we add an overlapping mapping
-
-//      NS_TEST_EXPECT_MSG_EQ(con0.AddMapping(map0), false, "They should intersect");
-
-//        TestSerialize();
-//        TestDeserialize();
-    }
-protected:
-  const SequenceNumber64 m_headDSN;
-  const SequenceNumber32 m_mappedSSN;
-  const uint16_t m_length;
-
-  const SequenceNumber64 m_headDSNbis;
-  const SequenceNumber32 m_mappedSSNbis;
-  const uint16_t m_lengthbis;
-
-
-  const bool m_shouldOverlap;
-};
-
-/**
-
-*/
-class MpTcpMappingContainerTestCase : public TestCase
-{
-public:
-    MpTcpMappingContainerTestCase () : TestCase("Mptcp mapping testcase")
-    {
-        NS_LOG_FUNCTION(this);
-    }
-
-    virtual ~MpTcpMappingContainerTestCase ()
-    {
-        NS_LOG_FUNCTION(this);
-    }
-
-    virtual void DoRun(void);
-};
-
-void
-MpTcpMappingContainerTestCase::DoRun()
-{
-  MpTcpMapping map0, map1, map2;
-  MpTcpMappingContainer con0,con1;
-
-  map0.SetHeadDSN( SequenceNumber64(40));
-  map0.SetMappingSize(10);
-  map0.MapToSSN( SequenceNumber32(32));
-
-  map1.SetHeadDSN( SequenceNumber64(50) );
-  map1.SetMappingSize(10);
-  map1.MapToSSN( map0.TailSSN()+1);
-
-
-  map2.SetHeadDSN( SequenceNumber64(60) );
-  map2.SetMappingSize(10);
-  map2.MapToSSN( map0.TailSSN()+ map1.GetLength());
-
-//      con0.AddMapping(map0);
-  MpTcpMapping ret, overlap;
-//      overlap.SetHeadDSN(map0.HeadDSN());
-//      overlap.SetMappingSize(map0.GetLength() + 4);
-//  overlap.SetHeadDSN(m_headDSNbis);
-//  overlap.SetMappingSize(m_lengthbis);
-//  overlap.MapToSSN(m_mappedSSNbis);
-
-  SequenceNumber32 ssn;
-
-  // Test on empty container
-  NS_TEST_EXPECT_MSG_EQ(con0.FirstUnmappedSSN(ssn), false, "An empty container can't return the unmapped ssn");
-  NS_TEST_EXPECT_MSG_EQ(con0.GetMappingForSSN(map0.HeadSSN(), ret), false, "An empty container can't find a mapping.");
-
-  // Tests with one mapping
-  NS_TEST_EXPECT_MSG_EQ(con0.AddMapping(map0), true, "This is the first mapping registered");
-//  NS_TEST_EXPECT_MSG_EQ(con0.AddMapping(map0), , "This is the first mapping registered");
-
-  NS_TEST_EXPECT_MSG_EQ(con0.FirstUnmappedSSN(ssn), true, "An empty container can't return the unmapped ssn");
-  NS_TEST_EXPECT_MSG_EQ(ssn, map0.TailSSN()+1, "Now that there is a mapping, it should be able to return a result");
-
-//  for(SequenceNumber32 i(0); i < map0.TailSSN(); ++i)
-//  {
-    NS_TEST_EXPECT_MSG_EQ(con0.GetMappingForSSN(map0.TailSSN(), ret), true, "Now that there is a mapping, it should be able to return a result");
-    NS_TEST_EXPECT_MSG_EQ(ret, map0, "The returnd mapping should be equal to the one inserted");
-//  }
-
-  NS_TEST_EXPECT_MSG_EQ(con0.DiscardMapping(map1), false, "This mapping was not registered");
-  NS_TEST_EXPECT_MSG_EQ(con0.DiscardMapping(map0), true, "This mapping was registered");
-
-  NS_TEST_EXPECT_MSG_EQ(con0.GetMappingForSSN(map0.HeadSSN(), ret), false, "An empty container can't find a mapping.");
-
-//  NS_TEST_EXPECT_MSG_EQ(con0.GetMappingForSSN(map0.HeadSSN(), ret), true, "Now that there is a mapping, it should be able to return a result");
-  // TODO do a test to check that we get all
-
-  // tests with 2 non contiguous mappings
-  NS_TEST_EXPECT_MSG_EQ(con1.AddMapping(map0), true, "");
-  NS_TEST_EXPECT_MSG_EQ(con1.AddMapping(map2), true, "");
-
-  NS_TEST_EXPECT_MSG_EQ(con1.GetMappingForSSN(map0.TailSSN() , ret), true, "This ssn should exist in the container");
-  NS_TEST_EXPECT_MSG_EQ(con1.GetMappingForSSN(map1.HeadSSN(), ret), false, "This ssn should not exist in the container");
-//  NS_TEST_EXPECT_MSG_EQ(con1.AddMapping(map1), true, "");
-//  con1.AddMapping(map0);
-
-
-
-  //!
-
-//  NS_TEST_EXPECT_MSG_EQ(con0.AddMapping(map0), true, "This is the first mapping registered");
-//  NS_TEST_EXPECT_MSG_EQ(con1.AddMapping(overlap), true, "This is the first mapping registered");
-//
-//  NS_TEST_EXPECT_MSG_EQ(con0.FindOverlappingMapping(map0, false, ret), true, "Don't ignore identical mappings");
-//  NS_TEST_EXPECT_MSG_EQ(ret, map0, "Previous test should have filled ret with mapping equal to map0");
-//
-////      NS_TEST_EXPECT_MSG_EQ(con0.FindOverlappingMapping(overlap, false, ret), m_shouldOverlap, "Ignore identical mappings so it should find none");
-//  NS_TEST_EXPECT_MSG_EQ(con1.FindOverlappingMapping(map0, false, ret), m_shouldOverlap, "Ignore identical mappings so it should find none");
-
-  // GetMappingFor SSN
-
-
-  //! Now we add an overlapping mapping
-
-//      NS_TEST_EXPECT_MSG_EQ(con0.AddMapping(map0), false, "They should intersect");
-
-//        TestSerialize();
-//        TestDeserialize();
-}
-
-
-
-static class MpTcpMappingTestSuite : public TestSuite
-{
-public:
- MpTcpMappingTestSuite ()
- : TestSuite ("mptcp-mapping", UNIT)
- {
-//    for (uint8_t i=0; i< 40; i += 10)
-//    {
-
-        ////////////////////////////////////////////////
-        //// HeadDSN/headSSN/Length x 2  / shouldoverlap
-
-        AddTestCase(new MpTcpMappingTestCase(
-                SequenceNumber64(10), SequenceNumber32(60),40,
-                SequenceNumber64(10), SequenceNumber32(60),40,
-                true), QUICK);
-
-        AddTestCase(new MpTcpMappingTestCase(
-            SequenceNumber64(50), SequenceNumber32(1), 80,
-            SequenceNumber64(100), SequenceNumber32(10),800,
-            true), QUICK);
-
-        AddTestCase(new MpTcpMappingTestCase(
-            SequenceNumber64(50), SequenceNumber32(1), 40,
-            SequenceNumber64(90), SequenceNumber32(80), 1000,
-            false), QUICK);
-
-//  Mapping DSN [6560-6659] mapped to SSN [6561-6660]
-//     with DSN [6660-6759] mapped to SSN [6661-6760]
-        AddTestCase(new MpTcpMappingTestCase(
-          SequenceNumber64(6560), SequenceNumber32(6561), 100,
-          SequenceNumber64(6660), SequenceNumber32(6661), 100,
-          false), QUICK);
-
-          // Mapping container tests
-        AddTestCase(new MpTcpMappingContainerTestCase(
-
-          ), QUICK);
- }
-
-//
-//
-//
-} g_MpTcpMappingTestSuite;
diff --git a/src/internet/test/mptcp-pm-test.cc b/src/internet/test/mptcp-pm-test.cc
deleted file mode 100644
index 76d5159..0000000
--- a/src/internet/test/mptcp-pm-test.cc
+++ /dev/null
@@ -1,186 +0,0 @@
-
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2007 Georgia Tech Research Corporation
- * Copyright (c) 2009 INRIA
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Authors: Matthieu Coudron 
- */
-
-#include "ns3/test.h"
-#include "ns3/socket-factory.h"
-#include "ns3/tcp-socket-factory.h"
-#include "ns3/simulator.h"
-#include "ns3/simple-channel.h"
-#include "ns3/simple-net-device.h"
-#include "ns3/drop-tail-queue.h"
-#include "ns3/config.h"
-//#include "ns3/ipv4-static-routing.h"
-//#include "ns3/ipv4-list-routing.h"
-//#include "ns3/ipv6-static-routing.h"
-//#include "ns3/ipv6-list-routing.h"
-//#include "ns3/node.h"
-#include "ns3/inet-socket-address.h"
-#include "ns3/inet6-socket-address.h"
-//#include "ns3/uinteger.h"
-//#include "ns3/log.h"
-
-#include "ns3/ipv4-end-point.h"
-#include "ns3/arp-l3-protocol.h"
-#include "ns3/ipv4-l3-protocol.h"
-#include "ns3/ipv6-l3-protocol.h"
-//#include "ns3/icmpv4-l4-protocol.h"
-//#include "ns3/icmpv6-l4-protocol.h"
-//#include "ns3/udp-l4-protocol.h"
-#include "ns3/tcp-l4-protocol.h"
-
-#include "ns3/core-module.h"
-//#include "ns3/point-to-point-helper.h"
-#include "ns3/internet-stack-helper.h"
-//#include "ns3/applications-module.h"
-#include "ns3/network-module.h"
-//#include "ns3/mp-tcp-socket-factory-impl.h"
-#include "ns3/internet-module.h"
-//#include "ns3/applications-module.h"
-#include "ns3/network-module.h"
-#include <string>
-
-//NS_LOG_COMPONENT_DEFINE ("MpTcpIdTest");
-
-using namespace ns3;
-
-
-/**
-To run with
-NS_LOG="MpTcpTestSuite" ./waf --run "test-runner --suite=mptcp"
-we should try not to add to internet dependancies ['bridge', 'mpi', 'network', 'core']
-**/
-
-
-
-
-/**
-Number of interfaces per node
-**/
-class MpTcpIdManagerTestCase : public TestCase
-{
-public:
-
-  MpTcpIdManagerTestCase (Ptr<MpTcpPathIdManager>);
-  virtual ~MpTcpIdManagerTestCase () {};
-
-protected:
-//  virtual void DoSetup ();
-  virtual void DoTeardown ();
-
-//  virtual Ptr<Node> CreateMonohomedNode(uint8_t nbOfInterfaces);
-//  virtual Ptr<Node> CreateNode(uint8_t nbOfInterfaces);
-
-//  void AdvertiseAllAvailableAddresses();
-//  void AdvertiseThenRemoveAllAdvertisedAddresses();
-//  void AdvertiseThenCreateRemoveAllAdvertisedAddresses();
-//  void CreateNsubflows();
-//  void CreateFullmesh();
-
-private:
-  virtual void DoRun(void);
-  Ptr<MpTcpPathIdManager> m_mgr;
-};
-
-MpTcpIdManagerTestCase::MpTcpIdManagerTestCase (Ptr<MpTcpPathIdManager> mgr) :
-  TestCase("Id management for mptcp"),
-  m_mgr (mgr)
-{
-  //!
-  NS_ASSERT (m_mgr);
-}
-
-
-void
-MpTcpIdManagerTestCase::DoTeardown (void)
-{
-  Simulator::Destroy ();
-}
-
-
-
-void
-MpTcpIdManagerTestCase::DoRun (void)
-{
-//  NS_LOG_LOGIC ("Doing run in MpTcpIdManagerTestCase");
-
-
-  InetSocketAddress addr0 ("192.168.1.0", 42 );
-  InetSocketAddress addr1 ("192.168.1.1", 42 );
-  InetSocketAddress addr2 ("192.168.1.2");
-//  Inet6SocketAddress addr0 ( )
-
-  std::set<Address> localAddresses;
-  std::set<Address> remoteAddresses;
-
-
-//  NS_LOG_LOGIC("Simulation ended");
-//  m_mgr->AddLocalId ();
-  uint8_t addrId0_0, addrId0_1, result;
-  NS_TEST_EXPECT_MSG_EQ (m_mgr->AddLocalId (&addrId0_0, addr0), true, 
-    "Could not add localId even though the list is empty");
-
-  NS_TEST_EXPECT_MSG_EQ (m_mgr->AddLocalId (&addrId0_1, addr0), false, 
-    "It should not be possible to register twice the same id");
-
-  NS_TEST_EXPECT_MSG_EQ (m_mgr->AddId (4, addr1), true, 
-    "First added remote id, should succeed !");
-  NS_TEST_EXPECT_MSG_EQ (m_mgr->AddId ( 4, addr2), false, 
-    "This test must fail (a similar id has been registered just before)");
-//  NS_TEST_EXPECT_MSG_EQ (m_mgr->AddLocalId (&addrId0_1, addr1), false, 
-//    "addr1 already registered (maybe return true instead for exact match ?)");
-//  NS_TEST_ASSERT_MSG_EQ (true, true, "true doesn't equal true for some reason");
-
-  NS_TEST_EXPECT_MSG_EQ (m_mgr->GetMatch(&result, addr0), true, 
-    "Must find it");
-
-  NS_TEST_EXPECT_MSG_EQ (m_mgr->RemoveId (addrId0_0), true, 
-    "Just registered so it should be possible to remove it");
-//  
-//  m_mgr->GetIds (localAddresses);
-//
-//  //! Now I need to check that alls id are made available
-//  NS_TEST_EXPECT_MSG_EQ (localAddresses.size(), 2, "We have added 2 addresses");
-
-  NS_TEST_EXPECT_MSG_EQ (m_mgr->GetMatch(&result, addr0), false, 
-    "It was just removed");
-  std::cout << "Comparing " << result << "and " << addrId0_0;
-  NS_TEST_EXPECT_MSG_EQ (result, addrId0_0, "Ids must be the same");
-//  m_mgr->GetRemoteIds (remoteAddresses);
-}
-
-
-
-static class MpTcpIdTestSuite : public TestSuite
-{
-public:
-  MpTcpIdTestSuite ()
-    : TestSuite ("mptcp-pm", UNIT)
-  {
-    Ptr<MpTcpPathIdManager> mgr = CreateObject<MpTcpPathIdManagerImpl> ();
-    AddTestCase (new MpTcpIdManagerTestCase (mgr), TestCase::QUICK);
-//    AddTestCase (new MpTcpIdManagerTestCase(), TestCase::QUICK);
-
-  }
-
-} g_MpTcpPmTestSuite;
-
-
diff --git a/src/internet/test/mptcp-tcp-multi.cc b/src/internet/test/mptcp-tcp-multi.cc
deleted file mode 100644
index bc9f399..0000000
--- a/src/internet/test/mptcp-tcp-multi.cc
+++ /dev/null
@@ -1,944 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- *
- */
-
-#include "ns3/test.h"
-#include "ns3/socket-factory.h"
-#include "ns3/tcp-socket-factory.h"
-#include "ns3/simulator.h"
-#include "ns3/simple-channel.h"
-#include "ns3/simple-net-device.h"
-#include "ns3/drop-tail-queue.h"
-#include "ns3/config.h"
-#include "ns3/ipv4-static-routing.h"
-#include "ns3/ipv4-list-routing.h"
-#include "ns3/ipv6-static-routing.h"
-#include "ns3/ipv6-list-routing.h"
-#include "ns3/node.h"
-#include "ns3/inet-socket-address.h"
-#include "ns3/inet6-socket-address.h"
-#include "ns3/uinteger.h"
-#include "ns3/log.h"
-#include "ns3/string.h"
-#include "ns3/tcp-socket-base.h"
-#include "ns3/mptcp-socket-base.h"
-#include "ns3/mptcp-subflow.h"
-
-// Test to get netanim working
-#include "ns3/netanim-module.h"
-#include "ns3/constant-position-mobility-model.h"
-
-#include "ns3/ipv4-end-point.h"
-#include "ns3/arp-l3-protocol.h"
-#include "ns3/ipv4-l3-protocol.h"
-#include "ns3/ipv6-l3-protocol.h"
-#include "ns3/icmpv4-l4-protocol.h"
-#include "ns3/icmpv6-l4-protocol.h"
-#include "ns3/udp-l4-protocol.h"
-#include "ns3/tcp-l4-protocol.h"
-#include "ns3/trace-helper.h"
-#include "ns3/point-to-point-helper.h"
-#include "ns3/ipv4-address-helper.h"
-#include "ns3/sequence-number.h"
-#include "ns3/trace-helper.h"
-#include "ns3/global-route-manager.h"
-#include "ns3/abort.h"
-#include "ns3/tcp-trace-helper.h"
-
-#include <string>
-#include <fstream>
-
-
-
-/**
-
-
-Connects directly one client to its server with as many links as devices 
-(different configuration for each test)
-
- __________                          __________
-| Client   |________________________| Server   |
-| (node 1) |                        | (node 0) |
-|          |________________________|          |
-|__________|                        |__________|
-
-192.168.<Device>.1 <------------> 192.168.<Device>.2
-
-Scenario is:
-Source starts sending data that the receiver echoes back to the source.
-Once the server received everything, it closes the socket (which is likely to be 
-deferred until all the data has been acknowledged by the source).
-
-Once the source received everything, it closes the connection as well.
-
-
-
-
-
-**/
-NS_LOG_COMPONENT_DEFINE ("MpTcpMultiSuite");
-
-using namespace ns3;
-
-//std::ofstream source_f;
-//std::ofstream server_f;
-
-// rename to serverPort
-const uint16_t serverPort = 50000;
-
-
-// Check dce-iperf-mptcp
-void setPos (Ptr<Node> n, int x, int y, int z)
-{
-  Ptr<ConstantPositionMobilityModel> loc = CreateObject<ConstantPositionMobilityModel> ();
-  n->AggregateObject (loc);
-  Vector locVec2 (x, y, z);
-  loc->SetPosition (locVec2);
-}
-
-
-static const Ipv4Mask g_netmask = Ipv4Mask(0xffffff00);
-/**
- *
- */
-class MpTcpMultihomedTestCase : public TestCase
-{
-public:
-  MpTcpMultihomedTestCase (uint32_t totalStreamSize,
-               uint32_t sourceWriteSize,
-               uint32_t sourceReadSize,
-               uint32_t serverWriteSize,
-               uint32_t serverReadSize,
-               uint8_t nb_of_devices,
-               uint8_t nb_of_subflows_per_device,
-               bool useIpv6);
-
-  void HandleSubflowConnected (Ptr<MpTcpSubflow> subflow);
-  void HandleSubflowCreated (Ptr<MpTcpSubflow> subflow);
-
-private:
-  virtual void DoSetup (void);
-  virtual void DoRun (void);
-  virtual void DoTeardown (void);
-  void SetupDefaultSim (void);
-  void SetupDefaultSim6 (void);
-
-  Ptr<Node> CreateInternetNode (void);
-  Ptr<Node> CreateInternetNode6 (void);
-  Ptr<SimpleNetDevice> AddSimpleNetDevice (Ptr<Node> node, const char* ipaddr, const char* netmask);
-  Ptr<SimpleNetDevice> AddSimpleNetDevice6 (Ptr<Node> node, Ipv6Address ipaddr, Ipv6Prefix prefix);
-  void ServerHandleConnectionCreated (Ptr<Socket> s, const Address & addr);
-  void ServerHandleRecv (Ptr<Socket> sock);
-  void ServerHandleSend (Ptr<Socket> sock, uint32_t available);
-  void SourceHandleSend (Ptr<Socket> sock, uint32_t available);
-  void SourceHandleRecv (Ptr<Socket> sock);
-  void SourceConnectionSuccessful (Ptr<Socket> sock);
-  void SourceConnectionFailed (Ptr<Socket> sock);
-
-
-
-
-
-  const uint32_t m_totalBytes;          /* size of payload to send */
-  const uint32_t m_sourceWriteSize;
-  const uint32_t m_sourceReadSize;
-  const uint32_t m_serverWriteSize;
-  const uint32_t m_serverReadSize;
-  uint32_t m_currentSourceTxBytes;  /**!< Amount of data already sent */
-  uint32_t m_currentSourceRxBytes;  /**!< Amount of data already received */
-  uint32_t m_currentServerRxBytes;
-  uint32_t m_currentServerTxBytes;
-  uint8_t *m_sourceTxPayload;
-  uint8_t *m_sourceRxPayload;
-  uint8_t* m_serverRxPayload;
-
-  int m_nb_of_successful_connections;
-  int m_nb_of_successful_subflow_creations;
-//  int m_nb_of_subflow_connections;
-
-  bool m_connect_cb_called;
-  const bool m_useIpv6;
-
-  const uint8_t m_number_of_devices;
-  const uint8_t m_number_of_subflow_per_device;
-
-  Ptr<Node> m_serverNode;
-  Ptr<Node> m_sourceNode;
-};
-
-static std::string Name (std::string str, uint32_t totalStreamSize,
-                         uint32_t sourceWriteSize,
-                         uint32_t serverReadSize,
-                         uint32_t serverWriteSize,
-                         uint32_t sourceReadSize,
-                         uint8_t nb_of_devices,
-                         uint8_t nb_of_subflows_per_device,
-                         bool useIpv6)
-{
-  std::ostringstream oss;
-  oss << str << " total=" << totalStreamSize << " sourceWrite=" << sourceWriteSize
-      << " sourceRead=" << sourceReadSize << " serverRead=" << serverReadSize
-      << " serverWrite=" << serverWriteSize << " useIpv6=" << useIpv6
-      << " nbOfDevices=" << static_cast<long int>(nb_of_devices) 
-      << " nb_of_subflows_per_device=" << static_cast<long int>(nb_of_subflows_per_device)
-      << " => expects " << nb_of_subflows_per_device * nb_of_devices << " subflows "
-      ;
-  return oss.str ();
-}
-
-#ifdef NS3_LOG_ENABLE
-static std::string GetString (Ptr<Packet> p)
-{
-  std::ostringstream oss;
-  p->CopyData (&oss, p->GetSize ());
-  return oss.str ();
-}
-#endif /* NS3_LOG_ENABLE */
-
-MpTcpMultihomedTestCase::MpTcpMultihomedTestCase (uint32_t totalStreamSize,
-                          uint32_t sourceWriteSize,
-                          uint32_t sourceReadSize,
-                          uint32_t serverWriteSize,
-                          uint32_t serverReadSize,
-                          uint8_t nb_of_devices,
-                          uint8_t nb_of_subflows_per_device,
-                          bool useIpv6)
-  : TestCase (Name ("Send string data from client to server and back",
-                    totalStreamSize,
-                    sourceWriteSize,
-                    serverReadSize,
-                    serverWriteSize,
-                    sourceReadSize,
-                    nb_of_devices,
-                    nb_of_subflows_per_device,
-                    useIpv6)),
-    m_totalBytes (totalStreamSize),
-    m_sourceWriteSize (sourceWriteSize),
-    m_sourceReadSize (sourceReadSize),
-    m_serverWriteSize (serverWriteSize),
-    m_serverReadSize (serverReadSize),
-    m_number_of_devices (nb_of_devices),
-    m_number_of_subflow_per_device (nb_of_subflows_per_device),
-    m_nb_of_successful_connections (0),
-    m_nb_of_successful_subflow_creations (0),
-    m_connect_cb_called(false),
-    m_useIpv6 (useIpv6)
-{
-
-}
-
-void
-MpTcpMultihomedTestCase::DoSetup (void)
-{
-  // These
-//  Config::SetDefault ("ns3::TcpL4Protocol::SocketType",  StringValue("ns3::TcpNewReno") );
-  Config::SetDefault ("ns3::TcpSocketBase::EnableMpTcp", BooleanValue(true));
-  Config::SetDefault ("ns3::TcpSocketBase::NullISN",    BooleanValue(true));
-//    Time::SetResolution (Time::MS);
-    // Arguments to these test cases are 1) totalStreamSize,
-//  Config::SetDefault ("ns3::TcpL4Protocol::SocketType", StringValue("ns3::MpTcpCongestionLia") );
-
-  Config::SetDefault ("ns3::TcpL4Protocol::SocketType", StringValue("ns3::MpTcpCongestionLia") );
-//  CallbackValue cbValue = MakeCallback (&OnNewSocket);
-
-// Disabled cause source of a crash ?
-  CallbackValue cbValue = MakeCallback (&TcpTraceHelper::OnNewSocket);
-  Config::SetDefault ("ns3::TcpL4Protocol::OnNewSocket", cbValue);
-  
-
-  m_currentSourceTxBytes = 0;
-  m_currentSourceRxBytes = 0;
-  m_currentServerRxBytes = 0;
-  m_currentServerTxBytes = 0;
-  m_sourceTxPayload = new uint8_t [m_totalBytes];
-  m_sourceRxPayload = new uint8_t [m_totalBytes];
-  m_serverRxPayload = new uint8_t [m_totalBytes];
-  for(uint32_t i = 0; i < m_totalBytes; ++i)
-    {
-      uint8_t m = (uint8_t)(97 + (i % 26));
-      m_sourceTxPayload[i] = m;
-    }
-  memset (m_sourceRxPayload, 0, m_totalBytes);
-  memset (m_serverRxPayload, 0, m_totalBytes);
-
-  if (m_useIpv6 == true)
-    {
-      SetupDefaultSim6 ();
-    }
-  else
-    {
-      SetupDefaultSim ();
-    }
-}
-
-void
-MpTcpMultihomedTestCase::DoRun (void)
-{
-
-  AnimationInterface anim ("animation.xml");
-  Simulator::Run ();
-
-  NS_TEST_EXPECT_MSG_EQ (m_connect_cb_called, true, "Callback was called on successful connection");
-  NS_TEST_EXPECT_MSG_EQ (m_currentSourceTxBytes, m_totalBytes, "Source sent all bytes");
-  NS_TEST_EXPECT_MSG_EQ (m_currentServerRxBytes, m_totalBytes, "Server received all bytes");
-  NS_TEST_EXPECT_MSG_EQ (m_currentServerTxBytes, m_totalBytes, "Server sent all bytes");
-  NS_TEST_EXPECT_MSG_EQ (m_currentSourceRxBytes, m_totalBytes, "Source received all bytes");
-  NS_TEST_EXPECT_MSG_EQ (memcmp (m_sourceTxPayload, m_serverRxPayload, m_totalBytes), 0,
-                         "Server received expected data buffers");
-  NS_TEST_EXPECT_MSG_EQ (memcmp (m_sourceTxPayload, m_sourceRxPayload, m_totalBytes), 0,
-                         "Source received back expected data buffers");
-
-
-  NS_TEST_EXPECT_MSG_EQ ( m_nb_of_successful_connections, m_number_of_devices * m_number_of_subflow_per_device,
-                         "As many successful connections as subflows");
-
-  NS_TEST_EXPECT_MSG_EQ ( m_nb_of_successful_connections, m_nb_of_successful_subflow_creations,
-                         "As many successful connections callback calls as creation callback calls.");
-}
-void
-MpTcpMultihomedTestCase::DoTeardown (void)
-{
-  delete [] m_sourceTxPayload;
-  delete [] m_sourceRxPayload;
-  delete [] m_serverRxPayload;
-  Simulator::Destroy ();
-}
-
-
-/**
-Normally this should be called twice, first when server replied with MPTCP option,
-2nd when DataAck was received, i.e., FullyEstablished
-**/
-void
-MpTcpMultihomedTestCase::SourceConnectionSuccessful (Ptr<Socket> sock)
-{
-
-  Ptr<MpTcpSocketBase> meta =  DynamicCast<MpTcpSocketBase>(sock);
-  NS_ASSERT_MSG(meta, "WTF ?!! expecting a meta but [" << sock << "]  is not a meta:" << sock->GetInstanceTypeId().GetName());
-
-  NS_LOG_LOGIC("connection successful. Meta state=" << TcpSocket::TcpStateName[meta->GetState() ]
-//              << " received a DSS: " << meta->m_receivedDSS
-              );
-
-
-  if (!meta->FullyEstablished ())
-  {
-    //!
-    NS_LOG_INFO ("No DSS received yet => Not fully established. Can't create any subflow");
-    return;
-  }
-
-  m_nb_of_successful_connections++;
-  NS_LOG_INFO("At least one DSS received => fully established. Asking for a new subflow");
-
-//  NS_LOG_WARN("TODO check this is called after the receival of 1st DSS !!!");
-  m_connect_cb_called = true;
-
-  /*
-  Callback when a subflow successfully connected
-  TODO move to Connect
-  */
-//  #if 0
-  meta->SetSubflowConnectCallback(
-    MakeCallback (&MpTcpMultihomedTestCase::HandleSubflowConnected, this),
-    MakeNullCallback<void, Ptr<MpTcpSubflow> > ()
-  );
-
-//    #endif
-    
-  /*
-  first address on 2nd interface
-  TODO this should depend on the number of interfaces
-  */
-
-  Ptr<Ipv4> ipv4Local = m_sourceNode->GetObject<Ipv4> ();
-  NS_ABORT_MSG_UNLESS (ipv4Local, "GetObject for <Ipv4> interface failed");
-
-  NS_LOG_DEBUG ( "NbIpInterfaces=" << ipv4Local->GetNInterfaces () << " (with localhost)");
-  
-//  #if 0 
-//      bool isForwarding = false;
-
-  // Starts at one to skip loopback. Better solution ?
-  for (uint32_t interface = 1; interface < ipv4Local->GetNInterfaces (); ++interface )
-    {
-      //!
-      if (
-//          ipv4Local->GetNetDevice (j) == ndLocal && 
-      ipv4Local->IsUp (interface) &&
-          ipv4Local->IsForwarding (interface)   // to remove localhost
-          ) 
-        {
-//              isForwarding = true;
-          // TODO call to CreateNewSubflow
-          int nb_of_subflows_to_create = m_number_of_subflow_per_device;
-
-          // If it's the same interface as master subflow, then remove one
-          if (ipv4Local->GetInterfaceForPrefix ( "192.168.0.0", g_netmask) == interface)
-          {
-            NS_LOG_DEBUG ("same interface as master's");
-            nb_of_subflows_to_create--;
-          }
-          
-          // create subflows for this device
-          for (int i = 0; i < nb_of_subflows_to_create; ++i)
-          {
-            // Create new subflow
-            Ipv4Address serverAddr = m_serverNode->GetObject<Ipv4>()->GetAddress(interface, 0).GetLocal();
-            Ipv4Address sourceAddr = m_sourceNode->GetObject<Ipv4>()->GetAddress(interface, 0).GetLocal();
-
-            NS_LOG_UNCOND ("serverAddr=" << serverAddr <<  "sourceAddr=" << sourceAddr);
-
-            //! TODO, we should be able to not specify a port but it seems buggy so for now, let's set a port
-            InetSocketAddress local(sourceAddr, 4420);
-            InetSocketAddress remote(serverAddr, serverPort);
-//            InetSocketAddress remote(serverAddr, serverPort);
-
-            meta->ConnectNewSubflow (local, remote);
-          }
-        }
-        else 
-        {
-          NS_LOG_WARN ("Interface not up or not forwarding");
-        }
-    }
-//    #endif
-
-//    #if 0
-//    uint32_t numDevices = m_sourceNode->GetNDevices ();
-//    for (int dev_id = 1; nb_of_devices < numDevices; ++nb_of_devices) {
-//
-//        // TODO account for master subflow
-//        for (int subflow_per_device = 0; subflow_per_device < m_number_of_subflow_per_device; ++subflow_per_device)
-//        {
-//        
-//        }
-//    }
-    
-//    #endif
-
-//#endif
-
-}
-
-
-
-void
-MpTcpMultihomedTestCase::SourceConnectionFailed(Ptr<Socket> sock)
-{
-
-  NS_FATAL_ERROR("Connect failed");
-}
-
-void
-MpTcpMultihomedTestCase::ServerHandleConnectionCreated (Ptr<Socket> s, const Address & addr)
-{
-  NS_LOG_DEBUG ("ServerHandleConnectionCreated");
-  s->SetRecvCallback (MakeCallback (&MpTcpMultihomedTestCase::ServerHandleRecv, this));
-  s->SetSendCallback (MakeCallback (&MpTcpMultihomedTestCase::ServerHandleSend, this));
-
-  Ptr<MpTcpSocketBase> server_meta = DynamicCast<MpTcpSocketBase>(s);
-  NS_ASSERT_MSG (server_meta, "Was expecting a meta socket !" << s->GetInstanceTypeId ());
-
-
-  //! cb when server creates
-  server_meta->SetSubflowAcceptCallback(
-    MakeNullCallback<bool, Ptr<MpTcpSocketBase>, const Address &, const Address &  > (),
-    MakeCallback (&MpTcpMultihomedTestCase::HandleSubflowCreated, this)
-    
-    );
-    
-//  m_nb_of_successful_subflow_creations++;
-}
-
-void
-MpTcpMultihomedTestCase::ServerHandleRecv (Ptr<Socket> sock)
-{
-  NS_LOG_DEBUG("ServerHandleRecv, Rx available [" << sock->GetRxAvailable () << "]");
-  while (sock->GetRxAvailable () > 0)
-    {
-
-      uint32_t toRead = std::min (m_serverReadSize, sock->GetRxAvailable ());
-      NS_LOG_DEBUG("Rx Available [" << toRead );
-      Ptr<Packet> p = sock->Recv (toRead, 0);
-      if (p == 0 && sock->GetErrno () != Socket::ERROR_NOTERROR)
-        {
-          NS_FATAL_ERROR ("Server could not read stream at byte " << m_currentServerRxBytes);
-        }
-      NS_TEST_EXPECT_MSG_EQ ((m_currentServerRxBytes + p->GetSize () <= m_totalBytes), true,
-                             "Server received too many bytes");
-      NS_LOG_DEBUG ("Server recv data=\"" << GetString (p) << "\"");
-      p->CopyData (&m_serverRxPayload[m_currentServerRxBytes], p->GetSize ());
-      m_currentServerRxBytes += p->GetSize ();
-      ServerHandleSend (sock, sock->GetTxAvailable ());
-    }
-}
-
-void
-MpTcpMultihomedTestCase::ServerHandleSend (Ptr<Socket> sock, uint32_t available)
-{
-  NS_LOG_DEBUG("ServerHandleSend: TxAvailable=" << available
-        << " m_currentServerTxBytes=" << m_currentServerTxBytes
-        << " m_currentServerRxBytes=" << m_currentServerRxBytes
-
-        );
-
-  // en fait la seconde condition est zarb : kesako ?
-  while (sock->GetTxAvailable () > 0 && m_currentServerTxBytes < m_currentServerRxBytes)
-    {
-      uint32_t left = m_currentServerRxBytes - m_currentServerTxBytes;
-      uint32_t toSend = std::min (left, sock->GetTxAvailable ());
-      NS_LOG_DEBUG ("toSend=min(nbBytesLeft=" << left << ",m_serverWriteSize=" << m_serverWriteSize << ")");
-      toSend = std::min (toSend, m_serverWriteSize);
-      Ptr<Packet> p = Create<Packet> (&m_serverRxPayload[m_currentServerTxBytes], toSend);
-      NS_LOG_DEBUG ("Server send data=\"" << GetString (p) << "\"");
-      int sent = sock->Send (p);
-      NS_TEST_EXPECT_MSG_EQ ((sent != -1), true, "Server error during send ?");
-      m_currentServerTxBytes += sent;
-    }
-  if (m_currentServerTxBytes == m_totalBytes)
-    {
-      NS_LOG_DEBUG ("Server received all the data. Closing socket.");
-      sock->Close ();
-    }
-}
-
-void
-MpTcpMultihomedTestCase::SourceHandleSend (Ptr<Socket> sock, uint32_t available)
-{
-  NS_LOG_DEBUG("SourceHandleSend with available = " << available
-                  << " m_currentSourceTxBytes=" << m_currentSourceTxBytes << " (already sent) "
-                  << " m_currentSourceRxBytes=" << m_currentSourceRxBytes << " "
-                  << " m_totalBytes=" << m_totalBytes
-                  );
-  while (sock->GetTxAvailable () > 0 && m_currentSourceTxBytes < m_totalBytes)
-    {
-      uint32_t left = m_totalBytes - m_currentSourceTxBytes;
-      uint32_t toSend = std::min (left, sock->GetTxAvailable ());
-      toSend = std::min (toSend, m_sourceWriteSize);
-      NS_LOG_DEBUG ("toSend=min(nbBytesLeft=" << left << ",sourceWriteSize=" << m_sourceWriteSize << ")");
-      Ptr<Packet> p = Create<Packet> (&m_sourceTxPayload[m_currentSourceTxBytes], toSend);
-      NS_LOG_DEBUG ("Source send data=\"" << GetString (p) << "\"");
-      int sent = sock->Send (p);
-      NS_TEST_EXPECT_MSG_EQ ((sent != -1), true, "Error during send ?");
-      m_currentSourceTxBytes += sent;
-    }
-}
-
-void
-MpTcpMultihomedTestCase::SourceHandleRecv (Ptr<Socket> sock)
-{
-  NS_LOG_DEBUG("SourceHandleRecv : m_currentSourceRxBytes=" << m_currentSourceRxBytes);
-  while (sock->GetRxAvailable () > 0 && m_currentSourceRxBytes < m_totalBytes)
-    {
-      uint32_t toRead = std::min (m_sourceReadSize, sock->GetRxAvailable ());
-      Ptr<Packet> p = sock->Recv (toRead, 0);
-      if (p == 0 && sock->GetErrno () != Socket::ERROR_NOTERROR)
-        {
-          NS_FATAL_ERROR ("Source could not read stream at byte " << m_currentSourceRxBytes);
-        }
-      NS_TEST_EXPECT_MSG_EQ ((m_currentSourceRxBytes + p->GetSize () <= m_totalBytes), true,
-                             "Source received too many bytes");
-
-      p->CopyData (&m_sourceRxPayload[m_currentSourceRxBytes], p->GetSize ());
-      m_currentSourceRxBytes += p->GetSize ();
-
-      NS_LOG_DEBUG ("Source recv data=\"" << GetString (p) << "\". m_currentSourceRxBytes=" << m_currentSourceRxBytes);
-    }
-  if (m_currentSourceRxBytes == m_totalBytes)
-    {
-      NS_LOG_DEBUG ("Client received all the data. Closing socket.");
-      sock->Close ();
-    }
-}
-
-Ptr<Node>
-MpTcpMultihomedTestCase::CreateInternetNode ()
-{
-  Ptr<Node> node = CreateObject<Node> ();
-  NS_LOG_INFO("New node with id=" << node->GetId());
-  //ARP
-  Ptr<ArpL3Protocol> arp = CreateObject<ArpL3Protocol> ();
-  node->AggregateObject (arp);
-  //IPV4
-  Ptr<Ipv4L3Protocol> ipv4 = CreateObject<Ipv4L3Protocol> ();
-  //Routing for Ipv4
-  Ptr<Ipv4ListRouting> ipv4Routing = CreateObject<Ipv4ListRouting> ();
-  ipv4->SetRoutingProtocol (ipv4Routing);
-  Ptr<Ipv4StaticRouting> ipv4staticRouting = CreateObject<Ipv4StaticRouting> ();
-  ipv4Routing->AddRoutingProtocol (ipv4staticRouting, 0);
-  node->AggregateObject (ipv4);
-  //ICMP
-  Ptr<Icmpv4L4Protocol> icmp = CreateObject<Icmpv4L4Protocol> ();
-  node->AggregateObject (icmp);
-  //UDP
-  Ptr<UdpL4Protocol> udp = CreateObject<UdpL4Protocol> ();
-  node->AggregateObject (udp);
-
-
-
-  Ptr<TcpL4Protocol> tcp = CreateObject<TcpL4Protocol> ();
-  node->AggregateObject (tcp);
-  return node;
-}
-
-Ptr<SimpleNetDevice>
-MpTcpMultihomedTestCase::AddSimpleNetDevice (Ptr<Node> node, const char* ipaddr, const char* netmask)
-{
-  Ptr<SimpleNetDevice> dev = CreateObject<SimpleNetDevice> ();
-  dev->SetAddress (Mac48Address::ConvertFrom (Mac48Address::Allocate ()));
-  node->AddDevice (dev);
-  Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
-  uint32_t ndid = ipv4->AddInterface (dev);
-  Ipv4InterfaceAddress ipv4Addr = Ipv4InterfaceAddress (Ipv4Address (ipaddr), Ipv4Mask (netmask));
-  ipv4->AddAddress (ndid, ipv4Addr);
-  ipv4->SetUp (ndid);
-  return dev;
-}
-
-#if 0
-Assign (const Ptr<NetDevice> &device)
-{
-  Ipv4InterfaceContainer retval;
-
-  Ptr<Node> node = device->GetNode ();
-  NS_ASSERT_MSG (node, "Ipv4AddressHelper::Assign(): NetDevice is not not associated "
-                   "with any node -> fail");
-
-  Ptr<Ipv4> ipv4 = node->GetObject<Ipv4> ();
-  NS_ASSERT_MSG (ipv4, "Ipv4AddressHelper::Assign(): NetDevice is associated"
-                 " with a node without IPv4 stack installed -> fail "
-                 "(maybe need to use InternetStackHelper?)");
-
-  int32_t interface = ipv4->GetInterfaceForDevice (device);
-  if (interface == -1)
-    {
-      interface = ipv4->AddInterface (device);
-    }
-  NS_ASSERT_MSG (interface >= 0, "Ipv4AddressHelper::Assign(): "
-                 "Interface index not found");
-
-  Ipv4InterfaceAddress ipv4Addr = Ipv4InterfaceAddress (, m_mask);
-  ipv4->AddAddress (interface, ipv4Addr);
-  ipv4->SetMetric (interface, 1);
-  ipv4->SetUp (interface);
-  retval.Add (ipv4, interface);
-  return retval;
-}
-#endif
-
-//Callback<bool, const Address &> m_joinRequest
-//Callback<void, Ptr<MpTcpSubflow> > m_joinConnectionSucceeded;
-
-
-/** Here subflow should already have a correct id */
-void
-MpTcpMultihomedTestCase::HandleSubflowCreated (Ptr<MpTcpSubflow> subflow)
-{
-  NS_LOG_LOGIC("Created new subflow [" << subflow << "]. Is master: " << subflow->IsMaster());
-
-  if(subflow->IsMaster())
-  {
-    NS_LOG_LOGIC("successful establishement of first subflow " << subflow);
-  }
-  else
-  {
-    //! ce n'est pas le master donc forcement il s'agit d'un join
-    NS_LOG_LOGIC ("successful JOIN of subflow " << subflow );
-  }
-
-//  NS_LOG_LOGIC ( "Subflow id=" << (int)subflow->GetLocalId() );
-  NS_LOG_LOGIC ( "Subflow =" << subflow );
-
-  // TODO check it's not called several times for the same sf ?
-  m_nb_of_successful_subflow_creations++;
-//  subflow->GetMeta()->SetupSubflowTracing(subflow);
-}
-
-
-/** Here subflow should already have a correct id */
-void
-MpTcpMultihomedTestCase::HandleSubflowConnected (Ptr<MpTcpSubflow> subflow)
-{
-  NS_LOG_LOGIC ("successful connection of a subflow");
-
-  if (subflow->IsMaster ())
-  {
-    NS_LOG_LOGIC ("successful establishement of first subflow " << subflow);
-  }
-  else
-  {
-    //! ce n'est pas le master donc forcement il s'agit d'un join
-    NS_LOG_LOGIC ("successful JOIN of subflow " << subflow );
-  }
-
-  // TODO check it's not called several times for the same sf ?
-  m_nb_of_successful_connections++;
-}
-
-
-/**
-relier chaque interface
-nbIf
-fullMesh /
-In the future we should be able to havemore complex topologies
-**/
-void
-MpTcpMultihomedTestCase::SetupDefaultSim (void)
-{
-  // TODO this number should be made configurable
-
-  NS_LOG_UNCOND ("SetupDefaultSim Start ");
-//const char* netmask = "255.255.255.0";
-
-//  const char* ipaddr1 = "192.168.1.2";
-//  Ptr<Node> m_serverNode = CreateInternetNode ();
-//  Ptr<Node> m_sourceNode = CreateInternetNode ();
-  m_serverNode = CreateInternetNode ();
-  m_sourceNode = CreateInternetNode ();
-
-  // For netanim
-  setPos (m_serverNode, 0,0,0);
-  setPos (m_sourceNode, 100,0,0);
-
-  int nbOfDevices = m_number_of_devices;
-
-// TODO ptet essayer avec AddSimpleNetDevice
-  for(int i = 0; i < nbOfDevices; ++i)
-  {
-    // Use 10.0. instead !
-    // TODO use SimpleNetDevice instead if you want to upstream !
-    std::stringstream netAddr;
-    netAddr << "192.168." << i << ".0";
-
-    PointToPointHelper p2p;
-    p2p.SetDeviceAttribute ("DataRate", StringValue ("100Mbps"));
-    p2p.SetChannelAttribute ("Delay", StringValue ("10ms"));
-    p2p.SetChannelAttribute ("AlternateDelay", StringValue ("10ms"));
-    NetDeviceContainer cont = p2p.Install(m_serverNode, m_sourceNode);
-    p2p.EnablePcapAll("mptcp-multi", true);
-
-    Ipv4AddressHelper ipv4;
-    NS_LOG_DEBUG ("setting ipv4 base " << netAddr.str());
-    ipv4.SetBase ( netAddr.str().c_str(), g_netmask);
-    ipv4.Assign(cont);
-    /// Added by matt for debugging purposes
-
-    //PointToPointHelper helper;
-    //helper.EnablePcapAll("test",true);
-    //helper.EnablePcapAll("testmptcp",false);
-
-  }
-  //pcap.EnablePcapInternal("mptcp",dev,true,true);
-
-  // TODO addition
-  GlobalRouteManager::BuildGlobalRoutingDatabase ();
-  GlobalRouteManager::InitializeRoutes ();
-
-  Ptr<SocketFactory> sockFactory0 = m_serverNode->GetObject<TcpSocketFactory> ();
-  Ptr<SocketFactory> sockFactory1 = m_sourceNode->GetObject<TcpSocketFactory> ();
-
-  // a wrapper that calls m_tcp->CreateSocket ();
-  Ptr<Socket> server = sockFactory0->CreateSocket ();
-  Ptr<Socket> source = sockFactory1->CreateSocket ();
-//  source->Ref();
-
-
-  /* We want to control over which socket the meta binds first
-   GetAddress(interface, noIp);
-   sachant que l'interface 0 est le loopback en fait
-  */
-  Ipv4Address serverMainAddr = m_serverNode->GetObject<Ipv4>()->GetAddress(1,0).GetLocal();
-  InetSocketAddress serverlocaladdr (serverMainAddr, serverPort);
-  InetSocketAddress serverremoteaddr (serverMainAddr, serverPort);
-  NS_LOG_DEBUG("serverMainAddr=" << serverlocaladdr);
-  server->Bind (serverlocaladdr);
-  server->Listen ();
-  server->SetAcceptCallback (MakeNullCallback<bool, Ptr< Socket >, const Address &> (),
-                             MakeCallback (&MpTcpMultihomedTestCase::ServerHandleConnectionCreated,this));
-
-//  NS_LOG_UNCOND("Server Meta:" << server_meta << " NodeId:" << server_meta->GetNode()->GetId());
-//  NS_LOG_UNCOND("Client Meta:" << source_meta << " NodeId:" << source_meta->GetNode()->GetId());
-//  NS_LOG_INFO( "test" << server);
-  source->SetRecvCallback (MakeCallback (&MpTcpMultihomedTestCase::SourceHandleRecv, this));
-  source->SetSendCallback (MakeCallback (&MpTcpMultihomedTestCase::SourceHandleSend, this));
-
-  // SetConnectCallback
-  source->SetConnectCallback (
-//    Callback< void, Ptr< Socket > > connectionSucceeded, Callback< void, Ptr< Socket > > connectionFailed
-    MakeCallback (&MpTcpMultihomedTestCase::SourceConnectionSuccessful, this),
-    MakeCallback (&MpTcpMultihomedTestCase::SourceConnectionFailed, this)
-
-    );
-
-
-
-//  server_meta->SetupMetaTracing("server");
-//  source_meta->SetupMetaTracing("source");
-//  server_meta->SetupMetaTracing("server");
-
-  source->Connect (serverremoteaddr);
-
-
-
-
-}
-
-void
-MpTcpMultihomedTestCase::SetupDefaultSim6 (void)
-{
-  Ipv6Prefix prefix = Ipv6Prefix(64);
-  Ipv6Address ipaddr0 = Ipv6Address("2001:0100:f00d:cafe::1");
-  Ipv6Address ipaddr1 = Ipv6Address("2001:0100:f00d:cafe::2");
-  Ptr<Node> m_serverNode = CreateInternetNode6 ();
-  Ptr<Node> m_sourceNode = CreateInternetNode6 ();
-  Ptr<SimpleNetDevice> dev0 = AddSimpleNetDevice6 (m_serverNode, ipaddr0, prefix);
-  Ptr<SimpleNetDevice> dev1 = AddSimpleNetDevice6 (m_sourceNode, ipaddr1, prefix);
-
-  Ptr<SimpleChannel> channel = CreateObject<SimpleChannel> ();
-  dev0->SetChannel (channel);
-  dev1->SetChannel (channel);
-
-  Ptr<SocketFactory> sockFactory0 = m_serverNode->GetObject<TcpSocketFactory> ();
-  Ptr<SocketFactory> sockFactory1 = m_sourceNode->GetObject<TcpSocketFactory> ();
-
-  Ptr<Socket> server = sockFactory0->CreateSocket ();
-  Ptr<Socket> source = sockFactory1->CreateSocket ();
-
-  uint16_t serverPort = 50000;
-  Inet6SocketAddress serverlocaladdr (Ipv6Address::GetAny (), serverPort);
-  Inet6SocketAddress serverremoteaddr (ipaddr0, serverPort);
-
-  server->Bind (serverlocaladdr);
-  server->Listen ();
-  server->SetAcceptCallback (MakeNullCallback<bool, Ptr< Socket >, const Address &> (),
-                             MakeCallback (&MpTcpMultihomedTestCase::ServerHandleConnectionCreated,this));
-
-  source->SetRecvCallback (MakeCallback (&MpTcpMultihomedTestCase::SourceHandleRecv, this));
-  source->SetSendCallback (MakeCallback (&MpTcpMultihomedTestCase::SourceHandleSend, this));
-
-  source->Connect (serverremoteaddr);
-}
-
-Ptr<Node>
-MpTcpMultihomedTestCase::CreateInternetNode6 ()
-{
-  Ptr<Node> node = CreateObject<Node> ();
-  //IPV6
-  Ptr<Ipv6L3Protocol> ipv6 = CreateObject<Ipv6L3Protocol> ();
-  //Routing for Ipv6
-  Ptr<Ipv6ListRouting> ipv6Routing = CreateObject<Ipv6ListRouting> ();
-  ipv6->SetRoutingProtocol (ipv6Routing);
-  Ptr<Ipv6StaticRouting> ipv6staticRouting = CreateObject<Ipv6StaticRouting> ();
-  ipv6Routing->AddRoutingProtocol (ipv6staticRouting, 0);
-  node->AggregateObject (ipv6);
-  //ICMP
-  Ptr<Icmpv6L4Protocol> icmp = CreateObject<Icmpv6L4Protocol> ();
-  node->AggregateObject (icmp);
-  //Ipv6 Extensions
-  ipv6->RegisterExtensions ();
-  ipv6->RegisterOptions ();
-  //UDP
-  Ptr<UdpL4Protocol> udp = CreateObject<UdpL4Protocol> ();
-  node->AggregateObject (udp);
-  //TCP
-  Ptr<TcpL4Protocol> tcp = CreateObject<TcpL4Protocol> ();
-  node->AggregateObject (tcp);
-  return node;
-}
-
-Ptr<SimpleNetDevice>
-MpTcpMultihomedTestCase::AddSimpleNetDevice6 (Ptr<Node> node, Ipv6Address ipaddr, Ipv6Prefix prefix)
-{
-  Ptr<SimpleNetDevice> dev = CreateObject<SimpleNetDevice> ();
-  dev->SetAddress (Mac48Address::ConvertFrom (Mac48Address::Allocate ()));
-  node->AddDevice (dev);
-  Ptr<Ipv6> ipv6 = node->GetObject<Ipv6> ();
-  uint32_t ndid = ipv6->AddInterface (dev);
-  Ipv6InterfaceAddress ipv6Addr = Ipv6InterfaceAddress (ipaddr, prefix);
-  ipv6->AddAddress (ndid, ipv6Addr);
-  ipv6->SetUp (ndid);
-  return dev;
-}
-
-static class MpTcpMultihomedTestSuite : public TestSuite
-{
-public:
-  MpTcpMultihomedTestSuite ()
-    : TestSuite ("mptcp-multi", UNIT)
-  {
-
-
-    // TODO addition by matt
-
-//  Config::Set ("ns3::TcpL4Protocol::SocketType", StringValue("ns3::MpTcpCongestionLia") );
-
-    // with units of bytes
-    static const uint8_t MaxNbOfDevices = 2;
-    static const uint8_t SubflowPerDevice = 1;
-    
-
-    uint8_t nb_of_devices = MaxNbOfDevices;
-    uint8_t subflow_per_device = SubflowPerDevice;
-
-//    #define LOOP
-        
-    #ifdef LOOP
-    for (nb_of_devices = 1; nb_of_devices <= MaxNbOfDevices; nb_of_devices++) {
-
-        for (subflow_per_device = 1; subflow_per_device <= SubflowPerDevice; subflow_per_device++) {
-    #endif
-//            AddTestCase (
-//                new MpTcpMultihomedTestCase (
-//                    13,     // 1) totalStreamSize (everything in bytes)
-//                    200,    // 2) source write size,
-//                    200,    // 3) source read size
-//                    200,    // 4) server write size
-//                    200,    // 5) server read size
-//                    nb_of_devices,
-//                    subflow_per_device,
-//                    false       // 6/ use ipv6
-//                    ),
-//                TestCase::QUICK
-//            );
-
-//            AddTestCase (new MpTcpMultihomedTestCase (13, 1, 1, 1, 1, nb_of_devices, subflow_per_device, false), TestCase::QUICK);
-            AddTestCase (new MpTcpMultihomedTestCase (100000, 100, 50, 100, 20, nb_of_devices, subflow_per_device, false), TestCase::QUICK);
-
-    #ifdef LOOP
-        }
-    }
-    #endif
-
-// here it's a test where I lower streamsize to see where it starts failing.
-// 2100 is ok, 2200 fails
-//    AddTestCase (new MpTcpMultihomedTestCase (5000, 100, 50, 100, 20, false), TestCase::EXTENSIVE);
-//    AddTestCase (new MpTcpMultihomedTestCase (10000, 100, 50, 100, 50, false), TestCase::QUICK);
-//    AddTestCase (new MpTcpMultihomedTestCase (10000, 100, 50, 100, 20, false), TestCase::QUICK);
-
-
-
-    // Disable IPv6 tests; not supported yet
-//    AddTestCase (new MpTcpMultihomedTestCase (13, 200, 200, 200, 200, true), TestCase::QUICK);
-//    AddTestCase (new MpTcpMultihomedTestCase (13, 1, 1, 1, 1, true), TestCase::QUICK);
-//    AddTestCase (new MpTcpMultihomedTestCase (100000, 100, 50, 100, 20, true), TestCase::QUICK);
-  }
-
-} g_tcpTestSuite;
diff --git a/src/internet/test/tcp-header-test.cc b/src/internet/test/tcp-header-test.cc
index d453ef5..0f492d2 100644
--- a/src/internet/test/tcp-header-test.cc
+++ b/src/internet/test/tcp-header-test.cc
@@ -381,106 +381,6 @@ TcpHeaderFlagsToString::DoRun (void)
   NS_TEST_ASSERT_MSG_EQ (str, target, "str " << str <<  " does not equal target " << target);
 }
 
-
-/**
-To check if one can serialize more than the 40 bytes.
- */
-class TcpHeaderWithManyOptions : public TestCase
-{
-public:
-  TcpHeaderWithManyOptions (std::string name);
-
-private:
-  virtual void DoRun (void);
-//  virtual void DoTeardown (void);
-};
-
-
-TcpHeaderWithManyOptions::TcpHeaderWithManyOptions (std::string name) : TestCase (name)
-{
-}
-
-void 
-TcpHeaderWithManyOptions::DoRun (void)
-{
-  uint16_t sourcePort;        //!< Source port
-  uint16_t destinationPort;   //!< Destination port
-  SequenceNumber32 sequenceNumber;  //!< Sequence number
-  SequenceNumber32 ackNumber;       //!< ACK number
-  uint8_t flags;              //!< Flags (really a uint6_t)
-  uint16_t windowSize;        //!< Window size
-  uint16_t urgentPointer;     //!< Urgent pointer
-  TcpHeader header;
-  Buffer buffer;
-  #if 0
-  Ptr<UniformRandomVariable> x = CreateObject<UniformRandomVariable> ();
-  for (uint32_t i = 0; i < 1000; ++i)
-    {
-      sourcePort = GET_RANDOM_UINT16 (x);
-      destinationPort = GET_RANDOM_UINT16 (x);
-      sequenceNumber = SequenceNumber32 (GET_RANDOM_UINT32 (x));
-      ackNumber = SequenceNumber32 (GET_RANDOM_UINT32 (x));
-      flags = GET_RANDOM_UINT6 (x);
-      windowSize = GET_RANDOM_UINT16 (x);
-      urgentPointer = GET_RANDOM_UINT16 (x);
-
-      header.SetSourcePort (sourcePort);
-      header.SetDestinationPort (destinationPort);
-      header.SetSequenceNumber (sequenceNumber);
-      header.SetAckNumber (ackNumber);
-      header.SetFlags (flags);
-      header.SetWindowSize (windowSize);
-      header.SetUrgentPointer (urgentPointer);
-
-      NS_TEST_ASSERT_MSG_EQ (header.GetLength (), 5, "TcpHeader without option is"
-                         " not 5 word");
-
-      buffer.AddAtStart (header.GetSerializedSize ());
-      header.Serialize (buffer.Begin ());
-
-      NS_TEST_ASSERT_MSG_EQ (sourcePort, header.GetSourcePort (),
-                         "Different source port found");
-      NS_TEST_ASSERT_MSG_EQ (destinationPort, header.GetDestinationPort (),
-                         "Different destination port found");
-      NS_TEST_ASSERT_MSG_EQ (sequenceNumber, header.GetSequenceNumber (),
-                         "Different sequence number found");
-      NS_TEST_ASSERT_MSG_EQ (ackNumber, header.GetAckNumber (),
-                         "Different ack number found");
-      NS_TEST_ASSERT_MSG_EQ (flags, header.GetFlags (),
-                         "Different flags found");
-      NS_TEST_ASSERT_MSG_EQ (windowSize, header.GetWindowSize (),
-                         "Different window size found");
-      NS_TEST_ASSERT_MSG_EQ (urgentPointer, header.GetUrgentPointer (),
-                         "Different urgent pointer found");
-
-      NS_TEST_ASSERT_MSG_EQ (header.GetLength (), 5, "TcpHeader without option is"
-                         " not 5 word");
-
-      TcpHeader copyHeader;
-
-      copyHeader.Deserialize (buffer.Begin ());
-    #endif 
-    
-    Ptr<TcpOptionMSS> oMSS = CreateObject<TcpOptionMSS>();
-    oMSS->SetMSS (50);
-//    TcpHeader header, dest;
-    
-    uint32_t addedBytes = 0;
-    NS_TEST_EXPECT_MSG_GT ( oMSS->GetSerializedSize (), 0 , "else infinite loop" );
-    do 
-    {
-      addedBytes += oMSS->GetSerializedSize ();
-      bool res = header.AppendOption( oMSS);
-    } 
-    while( addedBytes < TcpHeader::m_maxOptionsLen);
-    
-    bool res = header.AppendOption( oMSS);
-    NS_TEST_EXPECT_MSG_EQ(res, false, "Can't add more options");
-    NS_TEST_EXPECT_MSG_LT_OR_EQ( header.GetSerializedSize (), TcpHeader::m_maxOptionsLen , "Max size not respected" );
-
-//    Buffer buffer;
-};
-
 static class TcpHeaderTestSuite : public TestSuite
 {
 public:
@@ -490,7 +390,6 @@ public:
     AddTestCase (new TcpHeaderGetSetTestCase ("GetSet test cases"), TestCase::QUICK);
     AddTestCase (new TcpHeaderWithRFC793OptionTestCase ("Test for options in RFC 793"), TestCase::QUICK);
     AddTestCase (new TcpHeaderFlagsToString ("Test flags to string function"), TestCase::QUICK);
-    AddTestCase (new TcpHeaderWithManyOptions ("TcpHeaderWithManyOptions"), TestCase::QUICK);
   }
 
 } g_TcpHeaderTestSuite;
diff --git a/src/internet/test/tcp-option-mptcp-test.cc b/src/internet/test/tcp-option-mptcp-test.cc
deleted file mode 100644
index 17dc4ec..0000000
--- a/src/internet/test/tcp-option-mptcp-test.cc
+++ /dev/null
@@ -1,377 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie (UPMC)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-
-#include "ns3/test.h"
-#include "ns3/drop-tail-queue.h"
-#include "ns3/config.h"
-#include "ns3/uinteger.h"
-#include "ns3/log.h"
-#include "ns3/sequence-number.h"
-
-#include "ns3/tcp-option-mptcp.h"
-#include <string>
-
-NS_LOG_COMPONENT_DEFINE ("MpTcpOptionsTestSuite");
-
-using namespace ns3;
-
-
-template<class T>
-class TcpOptionMpTcpTestCase : public TestCase
-{
-public:
-  TcpOptionMpTcpTestCase (Ptr<T> configuredOption, TcpOptionMpTcp::SubType type, std::string desc) :
-      TestCase (desc),
-      m_option(configuredOption),
-      m_type (type)
-  {
-    NS_LOG_FUNCTION (this);
-
-  }
-
-  virtual ~TcpOptionMpTcpTestCase ()
-  {
-    NS_LOG_FUNCTION (this);
-  }
-
-  virtual void TestSerialize (void)
-  {
-    NS_LOG_INFO ( "option.GetSerializedSize ():" << m_option->GetSerializedSize () );
-    m_buffer.AddAtStart ( m_option->GetSerializedSize ());
-    m_option->Serialize ( m_buffer.Begin () );
-  }
-
-  virtual void TestDeserialize (void)
-  {
-    T option;
-    Buffer::Iterator start = m_buffer.Begin ();
-    uint8_t kind = start.PeekU8 ();
-
-    NS_TEST_EXPECT_MSG_EQ (kind, TcpOption::MPTCP, "Option number does not match MPTCP sequence number");
-
-    uint32_t read = option.Deserialize ( start );
-
-    NS_LOG_INFO ("original LEN = " << option.GetSerializedSize () );
-    NS_TEST_EXPECT_MSG_EQ ( read, option.GetSerializedSize (), "");
-
-    bool res = (*m_option == option);
-    NS_TEST_EXPECT_MSG_EQ ( res,true, "Option loaded after serializing/deserializing are not equal. you should investigate ");
-  }
-
-
-  virtual void DoRun (void)
-  {
-    // check subtypes match
-    Ptr<T> opt = DynamicCast<T>(TcpOptionMpTcp::CreateMpTcpOption( m_type));
-    NS_ASSERT_MSG( opt, "Could not create the mptcp option");
-    NS_ASSERT_MSG( m_option->GetSubType() == opt->GetSubType(), "Mismatch between mptcp option types");
-
-    TestSerialize ();
-    TestDeserialize ();
-  }
-
-protected:
-  const Ptr<T> m_option;
-  Buffer m_buffer;
-  const TcpOptionMpTcp::SubType m_type;  //!< To check if the subtype returned by the class is the correct one
-};
-
-
-/** test inspired by rfc
-
-   The DATA_FIN is signaled by setting the 'F' flag in the Data Sequence
-   Signal option (Figure 9) to 1.  A DATA_FIN occupies 1 octet (the
-   final octet) of the connection-level sequence space.  Note that the
-   DATA_FIN is included in the Data-Level Length, but not at the subflow
-   level: for example, a segment with DSN 80, and Data-Level Length 11,
-   with DATA_FIN set, would map 10 octets from the subflow into data
-   sequence space 80-89, the DATA_FIN is DSN 90; therefore, this segment
-   including DATA_FIN would be acknowledged with a DATA_ACK of 91.
-*/
-class DssTest : public TestCase
-{
-public:
-  //: TcpOptionMpTcpTestCase (configuredOption, TcpOptionMpTcp::MP_DSS, "DSS Test");
-  DssTest() : TestCase ("Testing DSS option specifics")
-  {
-    NS_LOG_FUNCTION (this);
-  }
-
-  
-  virtual void DoRun (void)
-  {
-    
-    Ptr<TcpOptionMpTcpDSS> dss = CreateObject<TcpOptionMpTcpDSS> ();
-    dss->SetMapping (80, 80, 10, true);
-    
-    // WARNING SetMapping might be called only once !
-    // test DataFinMappingOnly
-    NS_TEST_EXPECT_MSG_EQ ( dss->DataFinMappingOnly (), false, "must be no");
-    NS_TEST_EXPECT_MSG_EQ ( dss->GetDataLevelLength() , 11, "must be no");
-    NS_TEST_EXPECT_MSG_EQ ( dss->GetDataFinDSN (), 90, "must be no");
-    
-    
-    dss->SetMapping(80, 0, 0, true);
-    NS_TEST_EXPECT_MSG_EQ ( dss->DataFinMappingOnly (), true, "must be no");
-    NS_TEST_EXPECT_MSG_EQ ( dss->GetDataLevelLength() , 1, "must be no");
-    NS_TEST_EXPECT_MSG_EQ ( dss->GetDataFinDSN (), 80, "must be no");
-//    NS_TEST_EXPECT_MSG_EQ ( dss->DataFinMappingOnly (), true, "mapping length null => datafin only");
-  }
-
-};
-
-
-
-static class TcpOptionMpTcpTestSuite : public TestSuite
-{
-public:
-  TcpOptionMpTcpTestSuite ()
-    : TestSuite ("tcp-option-mptcp", UNIT)
-  {
-
-    ////////////////////////////////////////////////
-    //// MP CAPABLE
-    ////
-    Ptr<TcpOptionMpTcpCapable> mpc = CreateObject<TcpOptionMpTcpCapable> (),
-                               mpc2 = CreateObject<TcpOptionMpTcpCapable> ();
-    mpc->SetPeerKey (42);
-    mpc->SetSenderKey (232323);
-    AddTestCase (
-      new TcpOptionMpTcpTestCase<TcpOptionMpTcpCapable> (mpc, TcpOptionMpTcp::MP_CAPABLE, "MP_CAPABLE with Sender & Peer keys both set"),
-      QUICK
-      );
-
-    mpc2->SetSenderKey (3);
-    AddTestCase (
-      new TcpOptionMpTcpTestCase<TcpOptionMpTcpCapable> (mpc2, TcpOptionMpTcp::MP_CAPABLE, "MP_CAPABLE with only sender Key set"),
-      QUICK
-      );
-
-
-
-    ////////////////////////////////////////////////
-    //// MP PRIORITY
-    ////
-    Ptr<TcpOptionMpTcpChangePriority> prio = CreateObject<TcpOptionMpTcpChangePriority> (),
-                                      prio2 = CreateObject<TcpOptionMpTcpChangePriority> ();
-
-    prio->SetAddressId (3);
-    AddTestCase (
-      new TcpOptionMpTcpTestCase<TcpOptionMpTcpChangePriority> (prio, TcpOptionMpTcp::MP_PRIO, "Change priority for a different address"),
-      QUICK
-      );
-
-
-    ////////////////////////////////////////////////
-    //// MP REMOVE_ADDRESS
-    ////
-    Ptr<TcpOptionMpTcpRemoveAddress> rem = CreateObject<TcpOptionMpTcpRemoveAddress>();
-    for (uint8_t i = 0; i < 4; ++i)
-      {
-        Ptr<TcpOptionMpTcpRemoveAddress> rem2 = CreateObject<TcpOptionMpTcpRemoveAddress>();
-
-        rem->AddAddressId (i);
-        rem2->AddAddressId (i);
-
-        AddTestCase (
-          new TcpOptionMpTcpTestCase<TcpOptionMpTcpRemoveAddress> (rem, TcpOptionMpTcp::MP_REMOVE_ADDR, "With X addresses"),
-          QUICK
-          );
-
-        AddTestCase (
-          new TcpOptionMpTcpTestCase<TcpOptionMpTcpRemoveAddress> (rem2, TcpOptionMpTcp::MP_REMOVE_ADDR, "With 1 address"),
-          QUICK
-          );
-
-      }
-
-
-    ////////////////////////////////////////////////
-    //// MP ADD_ADDRESS
-    ////
-    Ptr<TcpOptionMpTcpAddAddress> add = CreateObject<TcpOptionMpTcpAddAddress>();
-    add->SetAddress ( InetSocketAddress ( "123.24.23.32"), 8 );
-
-    AddTestCase (
-      new TcpOptionMpTcpTestCase<TcpOptionMpTcpAddAddress> (add, TcpOptionMpTcp::MP_ADD_ADDR,"AddAddress IPv4"),
-      QUICK
-      );
-
-
-    ////////////////////////////////////////////////
-    //// MP_DSS
-    ////
-    uint16_t checksum = 32321;
-    
-
-    
-    AddTestCase ( new DssTest (), QUICK);
-    
-    for (int i = 0; i < 2; ++i)
-      {
-
-        Ptr<TcpOptionMpTcpDSS> dss1 = CreateObject<TcpOptionMpTcpDSS> (),
-                               dss2 = CreateObject<TcpOptionMpTcpDSS> (),
-                               dss3 = CreateObject<TcpOptionMpTcpDSS> (),
-                               dss4 = CreateObject<TcpOptionMpTcpDSS> ()
-        ;
-        if (i > 0)
-          {
-            dss1->SetChecksum (checksum);
-            dss2->SetChecksum (checksum);
-            dss3->SetChecksum (checksum);
-            dss4->SetChecksum (checksum);
-          }
-
-
-
-//          MpTcpMapping mapping;
-        uint16_t dataLvlLen = 32;
-        uint64_t dsn = 54;
-        uint32_t ssn = 40;
-
-        // TODO test truncated dsns
-        // TODO test enable datafin yes/no
-        dss1->SetMapping (dsn, ssn, dataLvlLen, false);
-        AddTestCase (
-          new TcpOptionMpTcpTestCase<TcpOptionMpTcpDSS> (dss1, TcpOptionMpTcp::MP_DSS, "DSN mapping only"),
-          QUICK
-          );
-
-        dss1->SetMapping (dsn, ssn, dataLvlLen, true);
-        AddTestCase (
-          new TcpOptionMpTcpTestCase<TcpOptionMpTcpDSS> (dss1, TcpOptionMpTcp::MP_DSS, "DSN mapping + DFIN"),
-          QUICK
-          );
-
-        dss1->SetDataAck (45000);
-        AddTestCase (
-          new TcpOptionMpTcpTestCase<TcpOptionMpTcpDSS> (dss1, TcpOptionMpTcp::MP_DSS, "DataAck + DSN mapping + DFIN"),
-          QUICK
-          );
-
-        dss2->SetDataAck (3210);
-        AddTestCase (
-          new TcpOptionMpTcpTestCase<TcpOptionMpTcpDSS> (dss2, TcpOptionMpTcp::MP_DSS, "DataAck only"),
-          QUICK
-          );
-
-//
-//        AddTestCase (
-//          new TcpOptionMpTcpTestCase<TcpOptionMpTcpDSS> (dss3, TcpOptionMpTcp::MP_DSS, "DataFin only"),
-//          QUICK
-//          );
-
-        dss4->SetDataAck (45000);
-        dss4->SetMapping (80, 80, 10, true);
-        AddTestCase (
-          new TcpOptionMpTcpTestCase<TcpOptionMpTcpDSS> (dss4, TcpOptionMpTcp::MP_DSS, "DataAck + DSN mapping + Datafin"),
-          QUICK
-          );
-
-//        dss4->SetDataAck (45000);
-        dss4->SetMapping (80, 0, 0, true);
-        AddTestCase (
-          new TcpOptionMpTcpTestCase<TcpOptionMpTcpDSS> (dss4, TcpOptionMpTcp::MP_DSS, "DataAck + DSN mapping + Datafin"),
-          QUICK
-          );
-      }
-    ////////////////////////////////////////////////
-    //// MP_JOIN Initial syn
-    ////
-    Ptr<TcpOptionMpTcpJoin> syn = CreateObject<TcpOptionMpTcpJoin>(),
-                            syn2 = CreateObject<TcpOptionMpTcpJoin>();
-//                    ;
-//                     CreateObject<TcpOptionMpTcpJoin>();
-    syn->SetMode (TcpOptionMpTcpJoin::Syn);
-    syn->SetAddressId (4);
-    syn->SetPeerToken (5323);
-    AddTestCase (
-      new TcpOptionMpTcpTestCase<TcpOptionMpTcpJoin> ( syn, TcpOptionMpTcp::MP_JOIN, "MP_JOIN Syn"),
-      QUICK
-      );
-
-
-    ////////////////////////////////////////////////
-    //// MP_JOIN synRcvd
-    ////
-    Ptr<TcpOptionMpTcpJoin> jsr = CreateObject<TcpOptionMpTcpJoin>(),
-                            jsr2 = CreateObject<TcpOptionMpTcpJoin>();
-    jsr->SetMode (TcpOptionMpTcpJoin::SynAck);
-    jsr->SetAddressId (4);
-    jsr->SetTruncatedHmac ( 522323 );
-    AddTestCase (
-      new TcpOptionMpTcpTestCase<TcpOptionMpTcpJoin> ( jsr, TcpOptionMpTcp::MP_JOIN, "MP_JOIN Syn Received"),
-      QUICK
-      );
-
-
-
-    ////////////////////////////////////////////////
-    //// MP_JOIN SynAck
-    ////
-    Ptr<TcpOptionMpTcpJoin> jsar = CreateObject<TcpOptionMpTcpJoin> ();
-    uint8_t hmac[20] = {3,0};
-    jsar->SetMode (TcpOptionMpTcpJoin::Ack);
-    jsar->SetHmac ( hmac  );
-    AddTestCase (
-      new TcpOptionMpTcpTestCase<TcpOptionMpTcpJoin> ( jsar, TcpOptionMpTcp::MP_JOIN, "MP_JOIN SynAck Received"),
-      QUICK
-      );
-
-
-    ////////////////////////////////////////////////
-    //// MP_FASTCLOSE
-    ////
-    Ptr<TcpOptionMpTcpFastClose> close = CreateObject<TcpOptionMpTcpFastClose> ();
-    close->SetPeerKey (3232);
-
-    AddTestCase (
-      new TcpOptionMpTcpTestCase<TcpOptionMpTcpFastClose> ( close, TcpOptionMpTcp::MP_FASTCLOSE, "MP_Fastclose"),
-      QUICK
-      );
-      
-    /** non standard options tests */
-    #if 0
-
-    ////////////////////////////////////////////////
-    //// MP_DELTAOWD
-    ////
-    Ptr<TcpOptionMpTcpDeltaOWD> deltaOwd = CreateObject<TcpOptionMpTcpDeltaOWD> ();
-    AddTestCase (
-      new TcpOptionMpTcpTestCase<TcpOptionMpTcpDeltaOWD> ( deltaOwd, TcpOptionMpTcp::MP_DELTAOWD, "MP_DeltaOWD"),
-      QUICK
-      );
-    #endif 
-
-    ////////////////////////////////////////////////
-    //// MP_DELTAOWD
-    ////
-    Ptr<TcpOptionMpTcpOwdTimeStamp> owd_ts = CreateObject<TcpOptionMpTcpOwdTimeStamp> ();
-    AddTestCase (
-      new TcpOptionMpTcpTestCase<TcpOptionMpTcpOwdTimeStamp> ( owd_ts, TcpOptionMpTcp::MP_OWDTS, "One way Delay timestamps"),
-      QUICK
-      );
-  }
-
-
-
-
-} g_TcpOptionTestSuite;
diff --git a/src/internet/test/tcp-test.cc b/src/internet/test/tcp-test.cc
index 181ffea..a80f8ef 100644
--- a/src/internet/test/tcp-test.cc
+++ b/src/internet/test/tcp-test.cc
@@ -2,7 +2,7 @@
 /*
  * Copyright (c) 2007 Georgia Tech Research Corporation
  * Copyright (c) 2009 INRIA
- *
+ * 
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation;
@@ -46,7 +46,6 @@
 #include "ns3/icmpv6-l4-protocol.h"
 #include "ns3/udp-l4-protocol.h"
 #include "ns3/tcp-l4-protocol.h"
-#include "ns3/global-route-manager.h"
 
 #include <string>
 
@@ -103,7 +102,7 @@ static std::string Name (std::string str, uint32_t totalStreamSize,
                          bool useIpv6)
 {
   std::ostringstream oss;
-  oss << str << " total=" << totalStreamSize << " sourceWrite=" << sourceWriteSize
+  oss << str << " total=" << totalStreamSize << " sourceWrite=" << sourceWriteSize 
       << " sourceRead=" << sourceReadSize << " serverRead=" << serverReadSize
       << " serverWrite=" << serverWriteSize << " useIpv6=" << useIpv6;
   return oss.str ();
@@ -122,8 +121,8 @@ TcpTestCase::TcpTestCase (uint32_t totalStreamSize,
                           uint32_t serverWriteSize,
                           uint32_t serverReadSize,
                           bool useIpv6)
-  : TestCase (Name ("Send string data from client to server and back",
-                    totalStreamSize,
+  : TestCase (Name ("Send string data from client to server and back", 
+                    totalStreamSize, 
                     sourceWriteSize,
                     serverReadSize,
                     serverWriteSize,
@@ -170,9 +169,9 @@ TcpTestCase::DoRun (void)
   NS_TEST_EXPECT_MSG_EQ (m_currentSourceTxBytes, m_totalBytes, "Source sent all bytes");
   NS_TEST_EXPECT_MSG_EQ (m_currentServerRxBytes, m_totalBytes, "Server received all bytes");
   NS_TEST_EXPECT_MSG_EQ (m_currentSourceRxBytes, m_totalBytes, "Source received all bytes");
-  NS_TEST_EXPECT_MSG_EQ (memcmp (m_sourceTxPayload, m_serverRxPayload, m_totalBytes), 0,
+  NS_TEST_EXPECT_MSG_EQ (memcmp (m_sourceTxPayload, m_serverRxPayload, m_totalBytes), 0, 
                          "Server received expected data buffers");
-  NS_TEST_EXPECT_MSG_EQ (memcmp (m_sourceTxPayload, m_sourceRxPayload, m_totalBytes), 0,
+  NS_TEST_EXPECT_MSG_EQ (memcmp (m_sourceTxPayload, m_sourceRxPayload, m_totalBytes), 0, 
                          "Source received back expected data buffers");
 }
 void
@@ -202,7 +201,7 @@ TcpTestCase::ServerHandleRecv (Ptr<Socket> sock)
         {
           NS_FATAL_ERROR ("Server could not read stream at byte " << m_currentServerRxBytes);
         }
-      NS_TEST_EXPECT_MSG_EQ ((m_currentServerRxBytes + p->GetSize () <= m_totalBytes), true,
+      NS_TEST_EXPECT_MSG_EQ ((m_currentServerRxBytes + p->GetSize () <= m_totalBytes), true, 
                              "Server received too many bytes");
       NS_LOG_DEBUG ("Server recv data=\"" << GetString (p) << "\"");
       p->CopyData (&m_serverRxPayload[m_currentServerRxBytes], p->GetSize ());
@@ -258,7 +257,7 @@ TcpTestCase::SourceHandleRecv (Ptr<Socket> sock)
         {
           NS_FATAL_ERROR ("Source could not read stream at byte " << m_currentSourceRxBytes);
         }
-      NS_TEST_EXPECT_MSG_EQ ((m_currentSourceRxBytes + p->GetSize () <= m_totalBytes), true,
+      NS_TEST_EXPECT_MSG_EQ ((m_currentSourceRxBytes + p->GetSize () <= m_totalBytes), true, 
                              "Source received too many bytes");
       NS_LOG_DEBUG ("Source recv data=\"" << GetString (p) << "\"");
       p->CopyData (&m_sourceRxPayload[m_currentSourceRxBytes], p->GetSize ());
@@ -438,9 +437,9 @@ public:
     AddTestCase (new TcpTestCase (13, 1, 1, 1, 1, false), TestCase::QUICK);
     AddTestCase (new TcpTestCase (100000, 100, 50, 100, 20, false), TestCase::QUICK);
 
-//    AddTestCase (new TcpTestCase (13, 200, 200, 200, 200, true), TestCase::QUICK);
-//    AddTestCase (new TcpTestCase (13, 1, 1, 1, 1, true), TestCase::QUICK);
-//    AddTestCase (new TcpTestCase (100000, 100, 50, 100, 20, true), TestCase::QUICK);
+    AddTestCase (new TcpTestCase (13, 200, 200, 200, 200, true), TestCase::QUICK);
+    AddTestCase (new TcpTestCase (13, 1, 1, 1, 1, true), TestCase::QUICK);
+    AddTestCase (new TcpTestCase (100000, 100, 50, 100, 20, true), TestCase::QUICK);
   }
 
 } g_tcpTestSuite;
diff --git a/src/internet/wscript b/src/internet/wscript
index b80c395..1ac05e6 100644
--- a/src/internet/wscript
+++ b/src/internet/wscript
@@ -66,7 +66,7 @@ def configure(conf):
         conf.report_optional_feature("nsc", "Network Simulation Cradle", False,
                                      "NSC not found (see option --with-nsc)")
 	return
-
+    
     if Options.platform in ['linux', 'freebsd']:
         arch = os.uname()[4]
     else:
@@ -78,7 +78,7 @@ def configure(conf):
         conf.check_nonfatal(mandatory=True, lib='dl', define_name='HAVE_DL', uselib_store='DL')
         ok = True
     conf.msg('Checking for NSC supported architecture ' + (arch or ''), ok)
-
+    
     if not ok:
         conf.env['NSC_ENABLED'] = False
         conf.report_optional_feature("nsc", "Network Simulation Cradle", False,
@@ -105,7 +105,6 @@ def configure(conf):
 def build(bld):
     # bridge and mpi dependencies are due to global routing
     obj = bld.create_ns3_module('internet', ['bridge', 'mpi', 'network', 'core'])
-    obj.use.append('GCRYPT')
     obj.source = [
         'model/ip-l4-protocol.cc',
         'model/udp-header.cc',
@@ -155,18 +154,6 @@ def build(bld):
         'model/tcp-option-rfc793.cc',
         'model/tcp-option-winscale.cc',
         'model/tcp-option-ts.cc',
-        'model/tcp-option-mptcp.cc',
-        'model/mptcp-crypto.cc',
-        'model/mptcp-socket-base.cc',
-        'model/mptcp-scheduler-round-robin.cc',
-        'model/mptcp-scheduler-fastest-rtt.cc',
-        'model/mptcp-scheduler-owd.cc',
-        'model/mptcp-id-manager.cc',
-        'model/mptcp-mapping.cc',
-        'model/mptcp-id-manager-impl.cc',
-        'model/mptcp-subflow.cc',
-        'model/mptcp-subflow-owd.cc',
-        'model/mptcp-cc-lia.cc',
         'model/ipv4-packet-info-tag.cc',
         'model/ipv6-packet-info-tag.cc',
         'model/ipv4-interface-address.cc',
@@ -218,7 +205,6 @@ def build(bld):
         'model/ripng.cc',
         'model/ripng-header.cc',
         'helper/ripng-helper.cc',
-        'helper/tcp-trace-helper.cc',
         ]
 
     internet_test = bld.create_ns3_module_test_library('internet')
@@ -245,13 +231,6 @@ def build(bld):
         'test/tcp-timestamp-test.cc',
         'test/tcp-wscaling-test.cc',
         'test/tcp-option-test.cc',
-        'test/tcp-option-mptcp-test.cc',
-        'test/mptcp-crypto-test.cc',
-        'test/mptcp-mapping-test.cc',
-        'test/mptcp-pm-test.cc',
-        'test/mptcp-tcp-multi.cc',
-        # TO remove once tcp-multi is confirmed
-        # 'test/mptcp-tcp-test.cc',
         'test/tcp-header-test.cc',
         'test/udp-test.cc',
         'test/ipv6-address-generator-test-suite.cc',
@@ -259,7 +238,7 @@ def build(bld):
         'test/ipv6-fragmentation-test.cc',
         'test/ipv6-forwarding-test.cc',
         'test/ipv6-ripng-test.cc',
-        'test/ipv6-address-helper-test-suite.cc',
+     	'test/ipv6-address-helper-test-suite.cc',
         'test/rtt-test.cc',
         'test/codel-queue-test-suite.cc',
         ]
@@ -275,7 +254,6 @@ def build(bld):
         'model/udp-header.h',
         'model/tcp-header.h',
         'model/tcp-option.h',
-        'model/tcp-option-mptcp.h',
         'model/icmpv4.h',
         'model/icmpv6-header.h',
         # used by routing
@@ -350,18 +328,6 @@ def build(bld):
         'model/tcp-socket-base.h',
         'model/tcp-tx-buffer.h',
         'model/tcp-rx-buffer.h',
-        'model/mptcp-crypto.h',
-        'model/mptcp-mapping.h',
-        'model/mptcp-subflow.h',
-        'model/mptcp-subflow-owd.h',
-        'model/mptcp-socket-base.h',
-        'model/mptcp-cc-lia.h',
-        'model/mptcp-scheduler.h',
-        'model/mptcp-scheduler-owd.h',
-        'model/mptcp-scheduler-round-robin.h',
-        'model/mptcp-scheduler-fastest-rtt.h',
-        'model/mptcp-id-manager.h',
-        'model/mptcp-id-manager-impl.h',
         'model/rtt-estimator.h',
         'model/ipv4-packet-probe.h',
         'model/ipv6-packet-probe.h',
@@ -369,11 +335,8 @@ def build(bld):
         'model/ripng.h',
         'model/ripng-header.h',
         'helper/ripng-helper.h',
-        'helper/tcp-trace-helper.h',
        ]
 
-
-
     if bld.env['NSC_ENABLED']:
         obj.source.append ('model/nsc-tcp-socket-impl.cc')
         obj.source.append ('model/nsc-tcp-l4-protocol.cc')
diff --git a/src/network/helper/trace-helper.cc b/src/network/helper/trace-helper.cc
index 32d8d08..b0febe1 100644
--- a/src/network/helper/trace-helper.cc
+++ b/src/network/helper/trace-helper.cc
@@ -170,13 +170,6 @@ PcapHelper::DefaultSink (Ptr<PcapFileWrapper> file, Ptr<const Packet> p)
   file->Write (Simulator::Now (), p);
 }
 
-void
-PcapHelper::SinkWithHeader (Ptr<PcapFileWrapper> file, const Header &header, Ptr<const Packet> p)
-{
-  NS_LOG_FUNCTION (file << p);
-  file->Write (Simulator::Now (), header, p);
-}
-
 AsciiTraceHelper::AsciiTraceHelper ()
 {
   NS_LOG_FUNCTION_NOARGS ();
diff --git a/src/network/helper/trace-helper.h b/src/network/helper/trace-helper.h
index fd94e59..9c13726 100644
--- a/src/network/helper/trace-helper.h
+++ b/src/network/helper/trace-helper.h
@@ -50,11 +50,9 @@ public:
     DLT_PPP = 9,
     DLT_RAW = 101,
     DLT_IEEE802_11 = 105,
-    DLT_LINUX_SLL = 113,
     DLT_PRISM_HEADER = 119,
     DLT_IEEE802_11_RADIO = 127,
-    DLT_IEEE802_15_4 = 195,
-    DLT_NETLINK = 253
+    DLT_IEEE802_15_4 = 195
   };
 
   /**
@@ -123,18 +121,6 @@ private:
    * @param p the packet to write
    */
   static void DefaultSink (Ptr<PcapFileWrapper> file, Ptr<const Packet> p);
-
-  /**
-   * This trace sink passes a header separately from the packet to prevent creating a new packet
-   * (for performance reasons)
-   *
-   * @param file the file to write to
-   * @param header header of the packet
-   * @param p the packet to write
-   *
-   * @see DefaultSink
-   */
-  static void SinkWithHeader (Ptr<PcapFileWrapper> file, const Header& header, Ptr<const Packet> p);
 };
 
 template <typename T> void
diff --git a/src/network/model/buffer.cc b/src/network/model/buffer.cc
index 97e7074..6f4c8d3 100644
--- a/src/network/model/buffer.cc
+++ b/src/network/model/buffer.cc
@@ -305,10 +305,11 @@ Buffer::GetInternalEnd (void) const
   return m_end - (m_zeroAreaEnd - m_zeroAreaStart);
 }
 
-void
+bool
 Buffer::AddAtStart (uint32_t start)
 {
   NS_LOG_FUNCTION (this << start);
+  bool dirty;
   NS_ASSERT (CheckInternalState ());
   bool isDirty = m_data->m_count > 1 && m_start > m_data->m_dirtyStart;
   if (m_start >= start && !isDirty)
@@ -320,6 +321,7 @@ Buffer::AddAtStart (uint32_t start)
        */
       NS_ASSERT (m_data->m_count == 1 || m_start == m_data->m_dirtyStart);
       m_start -= start;
+      dirty = m_start > m_data->m_dirtyStart;
       // update dirty area
       m_data->m_dirtyStart = m_start;
     } 
@@ -345,15 +347,20 @@ Buffer::AddAtStart (uint32_t start)
       // update dirty area
       m_data->m_dirtyStart = m_start;
       m_data->m_dirtyEnd = m_end;
+
+      dirty = true;
+
     }
   m_maxZeroAreaStart = std::max (m_maxZeroAreaStart, m_zeroAreaStart);
   LOG_INTERNAL_STATE ("add start=" << start << ", ");
   NS_ASSERT (CheckInternalState ());
+  return dirty;
 }
-void
+bool
 Buffer::AddAtEnd (uint32_t end)
 {
   NS_LOG_FUNCTION (this << end);
+  bool dirty;
   NS_ASSERT (CheckInternalState ());
   bool isDirty = m_data->m_count > 1 && m_end < m_data->m_dirtyEnd;
   if (GetInternalEnd () + end <= m_data->m_size && !isDirty)
@@ -367,6 +374,9 @@ Buffer::AddAtEnd (uint32_t end)
       m_end += end;
       // update dirty area.
       m_data->m_dirtyEnd = m_end;
+
+      dirty = m_end < m_data->m_dirtyEnd;
+
     } 
   else
     {
@@ -390,10 +400,15 @@ Buffer::AddAtEnd (uint32_t end)
       // update dirty area
       m_data->m_dirtyStart = m_start;
       m_data->m_dirtyEnd = m_end;
+
+      dirty = true;
+
     } 
   m_maxZeroAreaStart = std::max (m_maxZeroAreaStart, m_zeroAreaStart);
   LOG_INTERNAL_STATE ("add end=" << end << ", ");
   NS_ASSERT (CheckInternalState ());
+
+  return dirty;
 }
 
 void
@@ -689,6 +704,19 @@ Buffer::Deserialize (const uint8_t *buffer, uint32_t size)
   return (sizeCheck != 0) ? 0 : 1;
 }
 
+int32_t 
+Buffer::GetCurrentStartOffset (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return m_start;
+}
+int32_t 
+Buffer::GetCurrentEndOffset (void) const
+{
+  NS_LOG_FUNCTION (this);
+  return m_end;
+}
+
 
 void
 Buffer::TransformIntoRealBuffer (void) const
@@ -711,12 +739,10 @@ Buffer::PeekData (void) const
   return m_data->m_data + m_start;
 }
 
-uint32_t
+void
 Buffer::CopyData (std::ostream *os, uint32_t size) const
 {
   NS_LOG_FUNCTION (this << &os << size);
-  uint32_t originalSize = size;
-#if 0
   if (size > 0)
     {
       uint32_t tmpsize = std::min (m_zeroAreaStart-m_start, size);
@@ -740,88 +766,18 @@ Buffer::CopyData (std::ostream *os, uint32_t size) const
             }
         }
     }
-  return left;
-#endif
-  uint8_t *temp = new uint8_t[size];
-  uint32_t written = CopyData (temp, size);
-  os->write ((const char*)(temp), written);
-  delete temp;
-  return written;
 }
 
 uint32_t 
 Buffer::CopyData (uint8_t *buffer, uint32_t size) const
 {
   NS_LOG_FUNCTION (this << &buffer << size);
-
-  uint32_t originalSize = size;
-  if (size > 0)
-    {
-      uint32_t tmpsize = std::min (m_zeroAreaStart-m_start, size);
-//      if(os) {
-//        os->write ((const char*)(m_data->m_data + m_start), tmpsize);
-//      }
-//      else {
-      memcpy (buffer, (const char*)(m_data->m_data + m_start), tmpsize);
-      buffer += tmpsize;
-//      }
-      size -= tmpsize;
-      if (size > 0) 
-        { 
-          tmpsize = std::min (m_zeroAreaEnd - m_zeroAreaStart, size);
-          uint32_t left = tmpsize;
-          while (left > 0)
-            {
-              uint32_t toWrite = std::min (left, g_zeroes.size);
-//              if(os) {
-//                os->write (g_zeroes.buffer, toWrite);
-//              }
-//              else {
-              memcpy (buffer, g_zeroes.buffer, toWrite);
-              left -= toWrite;
-//              }
-              buffer += toWrite;
-            }
-          size -= tmpsize;
-          if (size > 0)
-            {
-              tmpsize = std::min (m_end - m_zeroAreaEnd, size);
-//              if(os) {
-//                os->write ((const char*)(m_data->m_data + m_zeroAreaStart), tmpsize); 
-//              }
-//              else {
-                memcpy (buffer, (const char*)(m_data->m_data + m_zeroAreaStart), tmpsize);
-//              }
-              size -= tmpsize;
-            }
-        }
-    }
-  return originalSize - size;
-}
-
-#if 0
-uint32_t 
-Buffer::CopyData (uint8_t *buffer, std::ostream *os, uint32_t size) const
-{
-  NS_LOG_FUNCTION (this << &buffer << size);
-//  
-//  void (*output) (void* data, const char*, uint32_t) = 0;
-//  if(os){
-//    output = [] (void* data, const char*, uint32_t) {
-//      ((std::ostream *)data)->write ((const char*)(m_data->m_data + m_start), tmpsize);
-//    }
-//  }
   uint32_t originalSize = size;
   if (size > 0)
     {
       uint32_t tmpsize = std::min (m_zeroAreaStart-m_start, size);
-      if(os) {
-        os->write ((const char*)(m_data->m_data + m_start), tmpsize);
-      }
-      else {
       memcpy (buffer, (const char*)(m_data->m_data + m_start), tmpsize);
       buffer += tmpsize;
-      }
       size -= tmpsize;
       if (size > 0) 
         { 
@@ -830,32 +786,21 @@ Buffer::CopyData (uint8_t *buffer, std::ostream *os, uint32_t size) const
           while (left > 0)
             {
               uint32_t toWrite = std::min (left, g_zeroes.size);
-              if(os) {
-                os->write (g_zeroes.buffer, toWrite);
-              }
-              else {
               memcpy (buffer, g_zeroes.buffer, toWrite);
               left -= toWrite;
-              }
               buffer += toWrite;
             }
           size -= tmpsize;
           if (size > 0)
             {
               tmpsize = std::min (m_end - m_zeroAreaEnd, size);
-              if(os) {
-                os->write ((const char*)(m_data->m_data + m_zeroAreaStart), tmpsize); 
-              }
-              else {
-                memcpy (buffer, (const char*)(m_data->m_data + m_zeroAreaStart), tmpsize);
-              }
+              memcpy (buffer, (const char*)(m_data->m_data + m_zeroAreaStart), tmpsize);
               size -= tmpsize;
             }
         }
     }
   return originalSize - size;
 }
-#endif
 
 /******************************************************
  *            The buffer iterator below.
@@ -895,14 +840,15 @@ bool
 Buffer::Iterator::CheckNoZero (uint32_t start, uint32_t end) const
 {
   NS_LOG_FUNCTION (this << &start << &end);
+  bool ok = true;
   for (uint32_t i = start; i < end; i++)
     {
       if (!Check (i))
         {
-          return false;
+          ok = false;
         }
     }
-  return true;
+  return ok;
 }
 bool 
 Buffer::Iterator::Check (uint32_t i) const
diff --git a/src/network/model/buffer.h b/src/network/model/buffer.h
index 6a401ce..ce24b8b 100644
--- a/src/network/model/buffer.h
+++ b/src/network/model/buffer.h
@@ -496,6 +496,7 @@ private:
 
   /**
    * \param start size to reserve
+   * \returns true if the buffer needed resizing, false otherwise.
    *
    * Add bytes at the start of the Buffer. The
    * content of these bytes is undefined but debugging
@@ -503,9 +504,10 @@ private:
    * Any call to this method invalidates any Iterator
    * pointing to this Buffer.
    */
-  void AddAtStart (uint32_t start);
+  bool AddAtStart (uint32_t start);
   /**
    * \param end size to reserve
+   * \returns true if the buffer needed resizing, false otherwise.
    *
    * Add bytes at the end of the Buffer. The
    * content of these bytes is undefined but debugging
@@ -513,7 +515,7 @@ private:
    * Any call to this method invalidates any Iterator
    * pointing to this Buffer.
    */
-  void AddAtEnd (uint32_t end);
+  bool AddAtEnd (uint32_t end);
 
   /**
    * \param o the buffer to append to the end of this buffer.
@@ -561,6 +563,14 @@ private:
   inline Buffer::Iterator End (void) const;
 
   /**
+   * \brief Create a full copy of the buffer, including
+   * all the internal structures.
+   *
+   * \returns a copy of the buffer
+   */
+  Buffer CreateFullCopy (void) const;
+
+  /**
    * \brief Return the number of bytes required for serialization.
    * \return the number of bytes.
    */
@@ -588,13 +598,24 @@ private:
    */
   uint32_t Deserialize (const uint8_t* buffer, uint32_t size);
 
+  /**
+   * \brief Returns the current buffer start offset
+   * \return the offset
+   */
+  int32_t GetCurrentStartOffset (void) const;
+  /**
+   * \brief Returns the current buffer end offset
+   * \return the offset
+   */
+  int32_t GetCurrentEndOffset (void) const;
+
   /** 
    * Copy the specified amount of data from the buffer to the given output stream.
    * 
    * @param os the output stream
    * @param size the maximum amount of bytes to copy. If zero, nothing is copied.
    */
-  uint32_t CopyData (std::ostream *os, uint32_t size) const;
+  void CopyData (std::ostream *os, uint32_t size) const;
 
   /**
    * Copy the specified amount of data from the buffer to the given buffer.
@@ -680,14 +701,6 @@ private:
   };
 
   /**
-   * \brief Create a full copy of the buffer, including
-   * all the internal structures.
-   *
-   * \returns a copy of the buffer
-   */
-  Buffer CreateFullCopy (void) const;
-
-  /**
    * \brief Transform a "Virtual byte buffer" into a "Real byte buffer"
    */
   void TransformIntoRealBuffer (void) const;
@@ -992,7 +1005,7 @@ uint8_t
 Buffer::Iterator::PeekU8 (void)
 {
   NS_ASSERT_MSG (m_current >= m_dataStart &&
-                 m_current < m_dataEnd,
+                 m_current <= m_dataEnd,
                  GetReadErrorMessage ());
 
   if (m_current < m_zeroStart)
diff --git a/src/network/model/byte-tag-list.cc b/src/network/model/byte-tag-list.cc
index e79ebd5..26d9bf6 100644
--- a/src/network/model/byte-tag-list.cc
+++ b/src/network/model/byte-tag-list.cc
@@ -106,8 +106,8 @@ ByteTagList::Iterator::PrepareForNext (void)
       TagBuffer buf = TagBuffer (m_current, m_end);
       m_nextTid = buf.ReadU32 ();
       m_nextSize = buf.ReadU32 ();
-      m_nextStart = buf.ReadU32 () + m_adjustment;
-      m_nextEnd = buf.ReadU32 () + m_adjustment;
+      m_nextStart = buf.ReadU32 ();
+      m_nextEnd = buf.ReadU32 ();
       if (m_nextStart >= m_offsetEnd || m_nextEnd <= m_offsetStart)
         {
           m_current += 4 + 4 + 4 + 4 + m_nextSize;
@@ -118,14 +118,13 @@ ByteTagList::Iterator::PrepareForNext (void)
         }
     }
 }
-ByteTagList::Iterator::Iterator (uint8_t *start, uint8_t *end, int32_t offsetStart, int32_t offsetEnd, int32_t adjustment)
+ByteTagList::Iterator::Iterator (uint8_t *start, uint8_t *end, int32_t offsetStart, int32_t offsetEnd)
   : m_current (start),
     m_end (end),
     m_offsetStart (offsetStart),
-    m_offsetEnd (offsetEnd),
-    m_adjustment (adjustment)
+    m_offsetEnd (offsetEnd)
 {
-  NS_LOG_FUNCTION (this << &start << &end << offsetStart << offsetEnd << adjustment);
+  NS_LOG_FUNCTION (this << &start << &end << offsetStart << offsetEnd);
   PrepareForNext ();
 }
 
@@ -138,19 +137,13 @@ ByteTagList::Iterator::GetOffsetStart (void) const
 
 
 ByteTagList::ByteTagList ()
-  : m_minStart (INT32_MAX),
-    m_maxEnd (INT32_MIN),
-    m_adjustment (0),
-    m_used (0),
+  : m_used (0),
     m_data (0)
 {
   NS_LOG_FUNCTION (this);
 }
 ByteTagList::ByteTagList (const ByteTagList &o)
-  : m_minStart (o.m_minStart),
-    m_maxEnd (o.m_maxEnd),
-    m_adjustment (o.m_adjustment),
-    m_used (o.m_used),
+  : m_used (o.m_used),
     m_data (o.m_data)
 {
   NS_LOG_FUNCTION (this << &o);
@@ -168,9 +161,6 @@ ByteTagList::operator = (const ByteTagList &o)
     }
 
   Deallocate (m_data);
-  m_minStart = o.m_minStart;
-  m_maxEnd = o.m_maxEnd;
-  m_adjustment = o.m_adjustment;
   m_data = o.m_data;
   m_used = o.m_used;
   if (m_data != 0)
@@ -210,16 +200,8 @@ ByteTagList::Add (TypeId tid, uint32_t bufferSize, int32_t start, int32_t end)
                              &m_data->data[spaceNeeded]);
   tag.WriteU32 (tid.GetUid ());
   tag.WriteU32 (bufferSize);
-  tag.WriteU32 (start - m_adjustment);
-  tag.WriteU32 (end - m_adjustment);
-  if (start - m_adjustment < m_minStart)
-    {
-      m_minStart = start - m_adjustment;
-    }
-  if (end - m_adjustment > m_maxEnd)
-    {
-      m_maxEnd = end - m_adjustment;
-    }
+  tag.WriteU32 (start);
+  tag.WriteU32 (end);
   m_used = spaceNeeded;
   m_data->dirty = m_used;
   return tag;
@@ -243,9 +225,6 @@ ByteTagList::RemoveAll (void)
 {
   NS_LOG_FUNCTION (this);
   Deallocate (m_data);
-  m_minStart = INT32_MAX;
-  m_maxEnd = INT32_MIN;
-  m_adjustment = 0;
   m_data = 0;
   m_used = 0;
 }
@@ -265,19 +244,51 @@ ByteTagList::Begin (int32_t offsetStart, int32_t offsetEnd) const
   NS_LOG_FUNCTION (this << offsetStart << offsetEnd);
   if (m_data == 0)
     {
-      return Iterator (0, 0, offsetStart, offsetEnd, 0);
+      return Iterator (0, 0, offsetStart, offsetEnd);
     }
   else
     {
-      return Iterator (m_data->data, &m_data->data[m_used], offsetStart, offsetEnd, m_adjustment);
+      return Iterator (m_data->data, &m_data->data[m_used], offsetStart, offsetEnd);
     }
 }
 
-void 
-ByteTagList::AddAtEnd (int32_t appendOffset)
+bool 
+ByteTagList::IsDirtyAtEnd (int32_t appendOffset)
 {
   NS_LOG_FUNCTION (this << appendOffset);
-  if (m_maxEnd <= appendOffset - m_adjustment)
+  ByteTagList::Iterator i = BeginAll ();
+  while (i.HasNext ())
+    {
+      ByteTagList::Iterator::Item item = i.Next ();
+      if (item.end > appendOffset)
+        {
+          return true;
+        }
+    }
+  return false;
+}
+
+bool 
+ByteTagList::IsDirtyAtStart (int32_t prependOffset)
+{
+  NS_LOG_FUNCTION (this << prependOffset);
+  ByteTagList::Iterator i = BeginAll ();
+  while (i.HasNext ())
+    {
+      ByteTagList::Iterator::Item item = i.Next ();
+      if (item.start < prependOffset)
+        {
+          return true;
+        }
+    }
+  return false;
+}
+
+void 
+ByteTagList::AddAtEnd (int32_t adjustment, int32_t appendOffset)
+{
+  NS_LOG_FUNCTION (this << adjustment << appendOffset);
+  if (adjustment == 0 && !IsDirtyAtEnd (appendOffset))
     {
       return;
     }
@@ -286,54 +297,57 @@ ByteTagList::AddAtEnd (int32_t appendOffset)
   while (i.HasNext ())
     {
       ByteTagList::Iterator::Item item = i.Next ();
+      item.start += adjustment;
+      item.end += adjustment;
 
       if (item.start >= appendOffset)
         {
           continue;
         }
-      if (item.end > appendOffset)
+      else if (item.start < appendOffset && item.end > appendOffset)
         {
           item.end = appendOffset;
         }
-      TagBuffer buf = list.Add (item.tid, item.size, item.start, item.end);
-      buf.CopyFrom (item.buf);
-      if (item.end > m_maxEnd)
+      else
         {
-          m_maxEnd = item.end;
+          // nothing to do.
         }
+      TagBuffer buf = list.Add (item.tid, item.size, item.start, item.end);
+      buf.CopyFrom (item.buf);
     }
   *this = list;
 }
 
 void 
-ByteTagList::AddAtStart (int32_t prependOffset)
+ByteTagList::AddAtStart (int32_t adjustment, int32_t prependOffset)
 {
-  NS_LOG_FUNCTION (this << prependOffset);
-  if (m_minStart >= prependOffset - m_adjustment)
+  NS_LOG_FUNCTION (this << adjustment << prependOffset);
+  if (adjustment == 0 && !IsDirtyAtStart (prependOffset))
     {
       return;
     }
-  m_minStart = INT32_MAX;
   ByteTagList list;
   ByteTagList::Iterator i = BeginAll ();
   while (i.HasNext ())
     {
       ByteTagList::Iterator::Item item = i.Next ();
+      item.start += adjustment;
+      item.end += adjustment;
 
       if (item.end <= prependOffset)
         {
           continue;
         }
-      if (item.start < prependOffset)
+      else if (item.end > prependOffset && item.start < prependOffset)
         {
           item.start = prependOffset;
         }
-      TagBuffer buf = list.Add (item.tid, item.size, item.start, item.end);
-      buf.CopyFrom (item.buf);
-      if (item.start < m_minStart)
+      else
         {
-          m_minStart = item.start;
+          // nothing to do.
         }
+      TagBuffer buf = list.Add (item.tid, item.size, item.start, item.end);
+      buf.CopyFrom (item.buf);
     }
   *this = list;
 }
diff --git a/src/network/model/byte-tag-list.h b/src/network/model/byte-tag-list.h
index df7d8e2..e8a5463 100644
--- a/src/network/model/byte-tag-list.h
+++ b/src/network/model/byte-tag-list.h
@@ -20,7 +20,6 @@
 #ifndef BYTE_TAG_LIST_H
 #define BYTE_TAG_LIST_H
 
-#define __STDC_LIMIT_MACROS
 #include <stdint.h>
 #include "ns3/type-id.h"
 #include "tag-buffer.h"
@@ -50,15 +49,21 @@ struct ByteTagListData;
  *     as-needed to emulate COW semantics.
  *
  *   - Each tag tags a unique set of bytes identified by the pair of offsets
- *     (start,end). These offsets are relative to the start of the packet
- *     Whenever the origin of the offset changes, the Packet adjusts all
- *     byte tags using ByteTagList::Adjust method.
+ *     (start,end). These offsets are provided by Buffer::GetCurrentStartOffset
+ *     and Buffer::GetCurrentEndOffset which means that they are relative to 
+ *     the start of the 'virtual byte buffer' as explained in the documentation
+ *     for the ns3::Buffer class. Whenever the origin of the offset of the Buffer
+ *     instance associated to this ByteTagList instance changes, the Buffer class
+ *     reports this to its container Packet class as a bool return value
+ *     in Buffer::AddAtStart and Buffer::AddAtEnd. In both cases, when this happens
+ *     the Packet class calls ByteTagList::AddAtEnd and ByteTagList::AddAtStart to update
+ *     the byte offsets of each tag in the ByteTagList.
  *
- *   - When packet is reduced in size, byte tags that span outside the packet
- *     boundaries remain in ByteTagList. It is not a problem as iterator fixes
- *     the boundaries before returning item. However, when packet is extending,
- *     it calls ByteTagList::AddAtStart or ByteTagList::AddAtEnd to cut byte
- *     tags that will otherwise cover new bytes.
+ *   - Whenever bytes are removed from the packet byte buffer, the ByteTagList offsets
+ *     are never updated because we rely on the fact that they will be updated in
+ *     either the next call to Packet::AddHeader or Packet::AddTrailer or when
+ *     the user iterates the tag list with Packet::GetTagIterator and 
+ *     TagIterator::Next.
  */
 class ByteTagList
 {
@@ -120,9 +125,8 @@ private:
      * \param end End tag
      * \param offsetStart offset to the start of the tag from the virtual byte buffer
      * \param offsetEnd offset to the end of the tag from the virtual byte buffer
-     * \param adjustment adjustment to byte tag offsets
      */
-    Iterator (uint8_t *start, uint8_t *end, int32_t offsetStart, int32_t offsetEnd, int32_t m_adjustment);
+    Iterator (uint8_t *start, uint8_t *end, int32_t offsetStart, int32_t offsetEnd);
 
     /**
      * \brief Prepare the iterator for the next tag
@@ -132,7 +136,6 @@ private:
     uint8_t *m_end;         //!< End tag
     int32_t m_offsetStart;  //!< Offset to the start of the tag from the virtual byte buffer
     int32_t m_offsetEnd;    //!< Offset to the end of the tag from the virtual byte buffer
-    int32_t m_adjustment;   //!< Adjustment to byte tag offsets
     uint32_t m_nextTid;     //!< TypeId of the next tag
     uint32_t m_nextSize;    //!< Size of the next tag
     int32_t m_nextStart;    //!< Start of the next tag
@@ -201,32 +204,42 @@ private:
    */
   ByteTagList::Iterator Begin (int32_t offsetStart, int32_t offsetEnd) const;
 
-  /*
-   * Adjust the offsets stored internally by the adjustment delta.
-   *
-   * \param adjustment value to change stored offsets by
-   */
-  inline void Adjust (int32_t adjustment);
-
   /**
-   * Make sure that all offsets are smaller than appendOffset which represents
+   * Adjust the offsets stored internally by the adjustment delta and
+   * make sure that all offsets are smaller than appendOffset which represents
    * the location where new bytes have been added to the byte buffer.
    * 
+   * \param adjustment value to change stored offsets by
    * \param appendOffset maximum offset value
    *
    */
-  void AddAtEnd (int32_t appendOffset);
+  void AddAtEnd (int32_t adjustment, int32_t appendOffset);
   /**
-   * Make sure that all offsets are bigger than prependOffset which represents
+   * Adjust the offsets stored internally by the adjustment delta and
+   * make sure that all offsets are bigger than prependOffset which represents
    * the location where new bytes have been added to the byte buffer.
    *
+   * \param adjustment value to change stored offsets byte
    * \param prependOffset minimum offset value
    *
    */
-  void AddAtStart (int32_t prependOffset);
+  void AddAtStart (int32_t adjustment, int32_t prependOffset);
 
 private:
   /**
+   * \brief Check that all offsets are smaller than appendOffset
+   * \param appendOffset the append offset to check
+   * \returns true if the check is false
+   */
+  bool IsDirtyAtEnd (int32_t appendOffset);
+  /**
+   * \brief Check that all offsets are bigger than prependOffset
+   * \param prependOffset the prepend offset to check
+   * \returns true if the check is false
+   */
+  bool IsDirtyAtStart (int32_t prependOffset);
+
+  /**
    * \brief Returns an iterator pointing to the very first tag in this list.
    *
    * \returns an iterator
@@ -246,19 +259,10 @@ private:
    */
   void Deallocate (struct ByteTagListData *data);
 
-  int32_t m_minStart; // !< minimal start offset
-  int32_t m_maxEnd; // !< maximal end offset
-  int32_t m_adjustment; // !< adjustment to byte tag offsets
   uint16_t m_used; //!< the number of used bytes in the buffer
   struct ByteTagListData *m_data; //!< the ByteTagListData structure
 };
 
-void
-ByteTagList::Adjust (int32_t adjustment)
-{
-  m_adjustment += adjustment;
-}
-
 } // namespace ns3
 
 #endif /* BYTE_TAG_LIST_H */
diff --git a/src/network/model/node.cc b/src/network/model/node.cc
index f42fe6d..76684d8 100644
--- a/src/network/model/node.cc
+++ b/src/network/model/node.cc
@@ -182,7 +182,7 @@ Node::DoDispose ()
        i != m_devices.end (); i++)
     {
       Ptr<NetDevice> device = *i;
-//      device->Dispose ();
+      device->Dispose ();
       *i = 0;
     }
   m_devices.clear ();
diff --git a/src/network/model/packet.cc b/src/network/model/packet.cc
index bd8cd86..80ede28 100644
--- a/src/network/model/packet.cc
+++ b/src/network/model/packet.cc
@@ -229,16 +229,12 @@ Packet::CreateFragment (uint32_t start, uint32_t length) const
 {
   NS_LOG_FUNCTION (this << start << length);
   Buffer buffer = m_buffer.CreateFragment (start, length);
-  ByteTagList byteTagList = m_byteTagList;
-  byteTagList.Adjust (-start);
   NS_ASSERT (m_buffer.GetSize () >= start + length);
   uint32_t end = m_buffer.GetSize () - (start + length);
   PacketMetadata metadata = m_metadata.CreateFragment (start, end);
   // again, call the constructor directly rather than
   // through Create because it is private.
-  Ptr<Packet> ret = Ptr<Packet> (new Packet (buffer, byteTagList, m_packetTagList, metadata), false);
-  ret->SetNixVector (GetNixVector ());
-  return ret;
+  return Ptr<Packet> (new Packet (buffer, m_byteTagList, m_packetTagList, metadata), false);
 }
 
 void
@@ -258,9 +254,13 @@ Packet::AddHeader (const Header &header)
 {
   uint32_t size = header.GetSerializedSize ();
   NS_LOG_FUNCTION (this << header.GetInstanceTypeId ().GetName () << size);
-  m_buffer.AddAtStart (size);
-  m_byteTagList.Adjust (size);
-  m_byteTagList.AddAtStart (size);
+  uint32_t orgStart = m_buffer.GetCurrentStartOffset ();
+  bool resized = m_buffer.AddAtStart (size);
+  if (resized)
+    {
+      m_byteTagList.AddAtStart (m_buffer.GetCurrentStartOffset () + size - orgStart,
+                                m_buffer.GetCurrentStartOffset () + size);
+    }
   header.Serialize (m_buffer.Begin ());
   m_metadata.AddHeader (header, size);
 }
@@ -270,7 +270,6 @@ Packet::RemoveHeader (Header &header)
   uint32_t deserialized = header.Deserialize (m_buffer.Begin ());
   NS_LOG_FUNCTION (this << header.GetInstanceTypeId ().GetName () << deserialized);
   m_buffer.RemoveAtStart (deserialized);
-  m_byteTagList.Adjust (-deserialized);
   m_metadata.RemoveHeader (header, deserialized);
   return deserialized;
 }
@@ -286,8 +285,13 @@ Packet::AddTrailer (const Trailer &trailer)
 {
   uint32_t size = trailer.GetSerializedSize ();
   NS_LOG_FUNCTION (this << trailer.GetInstanceTypeId ().GetName () << size);
-  m_byteTagList.AddAtEnd (GetSize ());
-  m_buffer.AddAtEnd (size);
+  uint32_t orgStart = m_buffer.GetCurrentStartOffset ();
+  bool resized = m_buffer.AddAtEnd (size);
+  if (resized)
+    {
+      m_byteTagList.AddAtEnd (m_buffer.GetCurrentStartOffset () - orgStart,
+                              m_buffer.GetCurrentEndOffset () - size);
+    }
   Buffer::Iterator end = m_buffer.End ();
   trailer.Serialize (end);
   m_metadata.AddTrailer (trailer, size);
@@ -313,20 +317,29 @@ void
 Packet::AddAtEnd (Ptr<const Packet> packet)
 {
   NS_LOG_FUNCTION (this << packet << packet->GetSize ());
-  m_byteTagList.AddAtEnd (GetSize ());
+  uint32_t aStart = m_buffer.GetCurrentStartOffset ();
+  uint32_t bEnd = packet->m_buffer.GetCurrentEndOffset ();
+  m_buffer.AddAtEnd (packet->m_buffer);
+  uint32_t appendPrependOffset = m_buffer.GetCurrentEndOffset () - packet->m_buffer.GetSize ();
+  m_byteTagList.AddAtEnd (m_buffer.GetCurrentStartOffset () - aStart, 
+                          appendPrependOffset);
   ByteTagList copy = packet->m_byteTagList;
-  copy.AddAtStart (0);
-  copy.Adjust (GetSize ());
+  copy.AddAtStart (m_buffer.GetCurrentEndOffset () - bEnd,
+                   appendPrependOffset);
   m_byteTagList.Add (copy);
-  m_buffer.AddAtEnd (packet->m_buffer);
   m_metadata.AddAtEnd (packet->m_metadata);
 }
 void
 Packet::AddPaddingAtEnd (uint32_t size)
 {
   NS_LOG_FUNCTION (this << size);
-  m_byteTagList.AddAtEnd (GetSize ());
-  m_buffer.AddAtEnd (size);
+  uint32_t orgEnd = m_buffer.GetCurrentEndOffset ();
+  bool resized = m_buffer.AddAtEnd (size);
+  if (resized)
+    {
+      m_byteTagList.AddAtEnd (m_buffer.GetCurrentEndOffset () - orgEnd,
+                              m_buffer.GetCurrentEndOffset () - size);
+    }
   m_metadata.AddPaddingAtEnd (size);
 }
 void 
@@ -341,7 +354,6 @@ Packet::RemoveAtStart (uint32_t size)
 {
   NS_LOG_FUNCTION (this << size);
   m_buffer.RemoveAtStart (size);
-  m_byteTagList.Adjust (-size);
   m_metadata.RemoveAtStart (size);
 }
 
@@ -358,7 +370,7 @@ Packet::CopyData (uint8_t *buffer, uint32_t size) const
   return m_buffer.CopyData (buffer, size);
 }
 
-uint32_t
+void
 Packet::CopyData (std::ostream *os, uint32_t size) const
 {
   return m_buffer.CopyData (os, size);
@@ -793,14 +805,14 @@ Packet::AddByteTag (const Tag &tag) const
   NS_LOG_FUNCTION (this << tag.GetInstanceTypeId ().GetName () << tag.GetSerializedSize ());
   ByteTagList *list = const_cast<ByteTagList *> (&m_byteTagList);
   TagBuffer buffer = list->Add (tag.GetInstanceTypeId (), tag.GetSerializedSize (), 
-                                0,
-                                GetSize ());
+                                m_buffer.GetCurrentStartOffset (),
+                                m_buffer.GetCurrentEndOffset ());
   tag.Serialize (buffer);
 }
 ByteTagIterator 
 Packet::GetByteTagIterator (void) const
 {
-  return ByteTagIterator (m_byteTagList.Begin (0, GetSize ()));
+  return ByteTagIterator (m_byteTagList.Begin (m_buffer.GetCurrentStartOffset (), m_buffer.GetCurrentEndOffset ()));
 }
 
 bool 
diff --git a/src/network/model/packet.h b/src/network/model/packet.h
index 82ab8ad..a20c6ad 100644
--- a/src/network/model/packet.h
+++ b/src/network/model/packet.h
@@ -410,7 +410,7 @@ public:
    * \param size the maximum number of bytes we want to write
    *        in the output stream.
    */
-  uint32_t CopyData (std::ostream *os, uint32_t size) const;
+  void CopyData (std::ostream *os, uint32_t size) const;
 
   /**
    * \brief performs a COW copy of the packet.
diff --git a/src/network/model/socket.cc b/src/network/model/socket.cc
index 1de001d..1cc2129 100644
--- a/src/network/model/socket.cc
+++ b/src/network/model/socket.cc
@@ -42,87 +42,24 @@ Socket::GetTypeId (void)
   return tid;
 }
 
-
-Socket&
-Socket::operator =(const Socket& sock)
-{
-  m_boundnetdevice = 0;
-  m_recvPktInfo = sock.m_recvPktInfo;
-  m_connectionSucceeded = sock.m_connectionSucceeded;
-  m_connectionFailed = sock.m_connectionFailed;
-  m_normalClose = sock.m_normalClose;
-  m_errorClose = sock.m_errorClose;
-  m_connectionRequest = sock.m_connectionRequest;
-  m_newConnectionCreated = sock.m_newConnectionCreated;
-  m_dataSent = sock.m_dataSent;
-  m_sendCb = sock.m_sendCb;
-  m_receivedData = sock.m_receivedData;
-  m_manualIpTos  = sock.m_manualIpTos;
-  m_manualIpTtl  = sock.m_manualIpTtl;
-  m_ipRecvTos  = sock.m_ipRecvTos;
-  m_ipRecvTtl  = sock.m_ipRecvTtl;
-  m_ipTos = sock.m_ipTos;
-  m_ipTtl = sock.m_ipTtl;
-  m_manualIpv6Tclass  = sock.m_manualIpv6Tclass;
-  m_manualIpv6HopLimit  = sock.m_manualIpv6HopLimit;
-  m_ipv6RecvTclass  = sock.m_ipv6RecvTclass;
-  m_ipv6RecvHopLimit  = sock.m_ipv6RecvHopLimit;
-  m_ipv6Tclass = sock.m_ipv6Tclass;
-  m_ipv6HopLimit = sock.m_ipv6HopLimit;
-  return *this;
-}
-
-Socket::Socket (const Socket& sock)
-  :
-    m_boundnetdevice(0),
-    m_recvPktInfo(sock.m_recvPktInfo),
-    m_connectionSucceeded(sock.m_connectionSucceeded),
-    m_connectionFailed(sock.m_connectionFailed),
-    m_normalClose(sock.m_normalClose),
-    m_errorClose(sock.m_errorClose),
-    m_connectionRequest(sock.m_connectionRequest),
-    m_newConnectionCreated(sock.m_newConnectionCreated),
-    m_dataSent(sock.m_dataSent),
-    m_sendCb(sock.m_sendCb),
-    m_receivedData(sock.m_receivedData),
-    m_manualIpTos (sock.m_manualIpTos),
-    m_manualIpTtl (sock.m_manualIpTtl),
-    m_ipRecvTos (sock.m_ipRecvTos),
-    m_ipRecvTtl (sock.m_ipRecvTtl),
-    m_ipTos(sock.m_ipTos),
-    m_ipTtl(sock.m_ipTtl),
-    m_manualIpv6Tclass (sock.m_manualIpv6Tclass),
-    m_manualIpv6HopLimit (sock.m_manualIpv6HopLimit),
-    m_ipv6RecvTclass (sock.m_ipv6RecvTclass),
-    m_ipv6RecvHopLimit (sock.m_ipv6RecvHopLimit),
-    m_ipv6Tclass(sock.m_ipv6Tclass),
-    m_ipv6HopLimit(sock.m_ipv6HopLimit)
-{
-  NS_LOG_FUNCTION_NOARGS ();
-  NS_LOG_LOGIC("Invoked copy constructor");
-  NS_LOG_DEBUG("cb null ?=" << m_sendCb.IsNull());
-}
-
-
 Socket::Socket (void)
-  :
-    m_boundnetdevice(0),
-    m_recvPktInfo(false),
-    m_manualIpTos (false),
+  : m_manualIpTos (false),
     m_manualIpTtl (false),
     m_ipRecvTos (false),
     m_ipRecvTtl (false),
-    m_ipTos(0),
-    m_ipTtl(0),
     m_manualIpv6Tclass (false),
     m_manualIpv6HopLimit (false),
     m_ipv6RecvTclass (false),
-    m_ipv6RecvHopLimit (false),
-    m_ipv6Tclass(0),
-    m_ipv6HopLimit(0)
-
+    m_ipv6RecvHopLimit (false)
 {
   NS_LOG_FUNCTION_NOARGS ();
+  m_boundnetdevice = 0;
+  m_recvPktInfo = false;
+
+  m_ipTos = 0;
+  m_ipTtl = 0;
+  m_ipv6Tclass = 0;
+  m_ipv6HopLimit = 0;
 }
 
 Socket::~Socket ()
@@ -130,7 +67,7 @@ Socket::~Socket ()
   NS_LOG_FUNCTION (this);
 }
 
-Ptr<Socket>
+Ptr<Socket> 
 Socket::CreateSocket (Ptr<Node> node, TypeId tid)
 {
   NS_LOG_FUNCTION (node << tid);
@@ -143,7 +80,7 @@ Socket::CreateSocket (Ptr<Node> node, TypeId tid)
   return s;
 }
 
-void
+void 
 Socket::SetConnectCallback (
   Callback<void, Ptr<Socket> > connectionSucceeded,
   Callback<void, Ptr<Socket> > connectionFailed)
@@ -153,7 +90,7 @@ Socket::SetConnectCallback (
   m_connectionFailed = connectionFailed;
 }
 
-void
+void 
 Socket::SetCloseCallbacks (
   Callback<void, Ptr<Socket> > normalClose,
   Callback<void, Ptr<Socket> > errorClose)
@@ -163,7 +100,7 @@ Socket::SetCloseCallbacks (
   m_errorClose = errorClose;
 }
 
-void
+void 
 Socket::SetAcceptCallback (
   Callback<bool, Ptr<Socket>, const Address &> connectionRequest,
   Callback<void, Ptr<Socket>, const Address&> newConnectionCreated)
@@ -187,21 +124,21 @@ Socket::SetSendCallback (Callback<void, Ptr<Socket>, uint32_t> sendCb)
   m_sendCb = sendCb;
 }
 
-void
+void 
 Socket::SetRecvCallback (Callback<void, Ptr<Socket> > receivedData)
 {
   NS_LOG_FUNCTION (this << &receivedData);
   m_receivedData = receivedData;
 }
 
-int
+int 
 Socket::Send (Ptr<Packet> p)
 {
   NS_LOG_FUNCTION (this << p);
   return Send (p, 0);
 }
 
-int
+int 
 Socket::Send (const uint8_t* buf, uint32_t size, uint32_t flags)
 {
   NS_LOG_FUNCTION (this << &buf << size << flags);
@@ -217,7 +154,7 @@ Socket::Send (const uint8_t* buf, uint32_t size, uint32_t flags)
   return Send (p, flags);
 }
 
-int
+int 
 Socket::SendTo (const uint8_t* buf, uint32_t size, uint32_t flags,
                 const Address &toAddress)
 {
@@ -241,7 +178,7 @@ Socket::Recv (void)
   return Recv (std::numeric_limits<uint32_t>::max (), 0);
 }
 
-int
+int 
 Socket::Recv (uint8_t* buf, uint32_t size, uint32_t flags)
 {
   NS_LOG_FUNCTION (this << &buf << size << flags);
@@ -261,12 +198,12 @@ Socket::RecvFrom (Address &fromAddress)
   return RecvFrom (std::numeric_limits<uint32_t>::max (), 0, fromAddress);
 }
 
-int
+int 
 Socket::RecvFrom (uint8_t* buf, uint32_t size, uint32_t flags,
                   Address &fromAddress)
 {
   NS_LOG_FUNCTION (this << &buf << size << flags << &fromAddress);
-  Ptr<Packet> p = RecvFrom (size, flags, fromAddress);
+  Ptr<Packet> p = RecvFrom (size, flags, fromAddress); 
   if (p == 0)
     {
       return 0;
@@ -276,7 +213,7 @@ Socket::RecvFrom (uint8_t* buf, uint32_t size, uint32_t flags,
 }
 
 
-void
+void 
 Socket::NotifyConnectionSucceeded (void)
 {
   NS_LOG_FUNCTION (this);
@@ -286,7 +223,7 @@ Socket::NotifyConnectionSucceeded (void)
     }
 }
 
-void
+void 
 Socket::NotifyConnectionFailed (void)
 {
   NS_LOG_FUNCTION (this);
@@ -296,7 +233,7 @@ Socket::NotifyConnectionFailed (void)
     }
 }
 
-void
+void 
 Socket::NotifyNormalClose (void)
 {
   NS_LOG_FUNCTION (this);
@@ -306,7 +243,7 @@ Socket::NotifyNormalClose (void)
     }
 }
 
-void
+void 
 Socket::NotifyErrorClose (void)
 {
   NS_LOG_FUNCTION (this);
@@ -316,7 +253,7 @@ Socket::NotifyErrorClose (void)
     }
 }
 
-bool
+bool 
 Socket::NotifyConnectionRequest (const Address &from)
 {
   NS_LOG_FUNCTION (this << &from);
@@ -334,7 +271,7 @@ Socket::NotifyConnectionRequest (const Address &from)
     }
 }
 
-void
+void 
 Socket::NotifyNewConnectionCreated (Ptr<Socket> socket, const Address &from)
 {
   NS_LOG_FUNCTION (this << socket << from);
@@ -344,7 +281,7 @@ Socket::NotifyNewConnectionCreated (Ptr<Socket> socket, const Address &from)
     }
 }
 
-void
+void 
 Socket::NotifyDataSent (uint32_t size)
 {
   NS_LOG_FUNCTION (this << size);
@@ -354,7 +291,7 @@ Socket::NotifyDataSent (uint32_t size)
     }
 }
 
-void
+void 
 Socket::NotifySend (uint32_t spaceAvailable)
 {
   NS_LOG_FUNCTION (this << spaceAvailable);
@@ -364,7 +301,7 @@ Socket::NotifySend (uint32_t spaceAvailable)
     }
 }
 
-void
+void 
 Socket::NotifyDataRecv (void)
 {
   NS_LOG_FUNCTION (this);
@@ -374,7 +311,7 @@ Socket::NotifyDataRecv (void)
     }
 }
 
-void
+void 
 Socket::DoDispose (void)
 {
   NS_LOG_FUNCTION (this);
@@ -417,7 +354,7 @@ Socket::GetBoundNetDevice ()
   return m_boundnetdevice;
 }
 
-void
+void 
 Socket::SetRecvPktInfo (bool flag)
 {
   NS_LOG_FUNCTION (this << flag);
@@ -582,14 +519,14 @@ SocketAddressTag::SocketAddressTag ()
   NS_LOG_FUNCTION (this);
 }
 
-void
+void 
 SocketAddressTag::SetAddress (Address addr)
 {
   NS_LOG_FUNCTION (this << addr);
   m_address = addr;
 }
 
-Address
+Address 
 SocketAddressTag::GetAddress (void) const
 {
   NS_LOG_FUNCTION (this);
@@ -643,14 +580,14 @@ SocketIpTtlTag::SocketIpTtlTag ()
   NS_LOG_FUNCTION (this);
 }
 
-void
+void 
 SocketIpTtlTag::SetTtl (uint8_t ttl)
 {
   NS_LOG_FUNCTION (this << static_cast<uint32_t> (ttl));
   m_ttl = ttl;
 }
 
-uint8_t
+uint8_t 
 SocketIpTtlTag::GetTtl (void) const
 {
   NS_LOG_FUNCTION (this);
@@ -675,21 +612,21 @@ SocketIpTtlTag::GetInstanceTypeId (void) const
   return GetTypeId ();
 }
 
-uint32_t
+uint32_t 
 SocketIpTtlTag::GetSerializedSize (void) const
-{
+{ 
   NS_LOG_FUNCTION (this);
   return 1;
 }
-void
+void 
 SocketIpTtlTag::Serialize (TagBuffer i) const
-{
+{ 
   NS_LOG_FUNCTION (this << &i);
   i.WriteU8 (m_ttl);
 }
-void
+void 
 SocketIpTtlTag::Deserialize (TagBuffer i)
-{
+{ 
   NS_LOG_FUNCTION (this << &i);
   m_ttl = i.ReadU8 ();
 }
@@ -704,13 +641,13 @@ SocketIpv6HopLimitTag::SocketIpv6HopLimitTag ()
 {
 }
 
-void
+void 
 SocketIpv6HopLimitTag::SetHopLimit (uint8_t hopLimit)
 {
   m_hopLimit = hopLimit;
 }
 
-uint8_t
+uint8_t 
 SocketIpv6HopLimitTag::GetHopLimit (void) const
 {
   return m_hopLimit;
@@ -734,19 +671,19 @@ SocketIpv6HopLimitTag::GetInstanceTypeId (void) const
   return GetTypeId ();
 }
 
-uint32_t
+uint32_t 
 SocketIpv6HopLimitTag::GetSerializedSize (void) const
-{
+{ 
   return 1;
 }
-void
+void 
 SocketIpv6HopLimitTag::Serialize (TagBuffer i) const
-{
+{ 
   i.WriteU8 (m_hopLimit);
 }
-void
+void 
 SocketIpv6HopLimitTag::Deserialize (TagBuffer i)
-{
+{ 
   m_hopLimit = i.ReadU8 ();
 }
 void
@@ -780,7 +717,7 @@ SocketSetDontFragmentTag::IsEnabled (void) const
 
 NS_OBJECT_ENSURE_REGISTERED (SocketSetDontFragmentTag);
 
-TypeId
+TypeId 
 SocketSetDontFragmentTag::GetTypeId (void)
 {
   static TypeId tid = TypeId ("ns3::SocketSetDontFragmentTag")
@@ -789,30 +726,30 @@ SocketSetDontFragmentTag::GetTypeId (void)
     .AddConstructor<SocketSetDontFragmentTag> ();
   return tid;
 }
-TypeId
+TypeId 
 SocketSetDontFragmentTag::GetInstanceTypeId (void) const
 {
   return GetTypeId ();
 }
-uint32_t
+uint32_t 
 SocketSetDontFragmentTag::GetSerializedSize (void) const
 {
   NS_LOG_FUNCTION (this);
   return 1;
 }
-void
+void 
 SocketSetDontFragmentTag::Serialize (TagBuffer i) const
 {
   NS_LOG_FUNCTION (this << &i);
   i.WriteU8 (m_dontFragment ? 1 : 0);
 }
-void
+void 
 SocketSetDontFragmentTag::Deserialize (TagBuffer i)
 {
   NS_LOG_FUNCTION (this << &i);
   m_dontFragment = (i.ReadU8 () == 1) ? true : false;
 }
-void
+void 
 SocketSetDontFragmentTag::Print (std::ostream &os) const
 {
   NS_LOG_FUNCTION (this << &os);
@@ -847,7 +784,7 @@ SocketIpTosTag::GetTypeId (void)
   return tid;
 }
 
-TypeId
+TypeId 
 SocketIpTosTag::GetInstanceTypeId (void) const
 {
   return GetTypeId ();
@@ -898,13 +835,13 @@ SocketIpv6TclassTag::GetTypeId (void)
 {
   static TypeId tid = TypeId ("ns3::SocketIpv6TclassTag")
     .SetParent<Tag> ()
-    .SetGroupName("Network")
+    .SetGroupName("Network") 
     .AddConstructor<SocketIpv6TclassTag> ()
     ;
   return tid;
 }
 
-TypeId
+TypeId 
 SocketIpv6TclassTag::GetInstanceTypeId (void) const
 {
   return GetTypeId ();
diff --git a/src/network/model/socket.h b/src/network/model/socket.h
index 8cf6e8b..708f563 100644
--- a/src/network/model/socket.h
+++ b/src/network/model/socket.h
@@ -53,13 +53,13 @@ class Packet;
  *   C-style structs
  * - in contrast to the original BSD socket API, this API is asynchronous:
  *   it does not contain blocking calls.  Sending and receiving operations
- *   must make use of the callbacks provided.
- * - It also uses class ns3::Packet as a fancy byte buffer, allowing
- *   data to be passed across the API using an ns-3 Packet instead of
+ *   must make use of the callbacks provided. 
+ * - It also uses class ns3::Packet as a fancy byte buffer, allowing 
+ *   data to be passed across the API using an ns-3 Packet instead of 
  *   a raw data pointer.
  * - Not all of the full POSIX sockets API is supported
  *
- * Other than that, it tries to stick to the BSD API to make it
+ * Other than that, it tries to stick to the BSD API to make it 
  * easier for those who know the BSD API to use this API.
  * More details are provided in the ns-3 tutorial.
  */
@@ -73,7 +73,6 @@ public:
   static TypeId GetTypeId (void);
 
   Socket (void);
-  Socket (const Socket& sock);
   virtual ~Socket (void);
 
   /**
@@ -112,16 +111,13 @@ public:
   /**
    * This method wraps the creation of sockets that is performed
    * on a given node by a SocketFactory specified by TypeId.
-   *
+   * 
    * \return A smart pointer to a newly created socket.
-   *
+   * 
    * \param node The node on which to create the socket
    * \param tid The TypeId of a SocketFactory class to use
    */
   static Ptr<Socket> CreateSocket (Ptr<Node> node, TypeId tid);
-  
-  Socket& operator =(const Socket&);
-  
   /**
    * \brief Get last error number.
    *
@@ -142,16 +138,16 @@ public:
   /**
    * \brief Specify callbacks to allow the caller to determine if
    * the connection succeeds of fails.
-   * \param connectionSucceeded this callback is invoked when the
-   *        connection request initiated by the user is successfully
-   *        completed. The callback is passed  back a pointer to
+   * \param connectionSucceeded this callback is invoked when the 
+   *        connection request initiated by the user is successfully 
+   *        completed. The callback is passed  back a pointer to 
    *        the same socket object.
-   * \param connectionFailed this callback is invoked when the
-   *        connection request initiated by the user is unsuccessfully
-   *        completed. The callback is passed back a pointer to the
-   *        same socket object.
+   * \param connectionFailed this callback is invoked when the 
+   *        connection request initiated by the user is unsuccessfully 
+   *        completed. The callback is passed back a pointer to the 
+   *        same socket object. 
    */
-  virtual void SetConnectCallback (Callback<void, Ptr<Socket> > connectionSucceeded,
+  void SetConnectCallback (Callback<void, Ptr<Socket> > connectionSucceeded,
                            Callback<void,  Ptr<Socket> > connectionFailed);
   /**
    * \brief Detect socket recv() events such as graceful shutdown or error.
@@ -168,42 +164,42 @@ public:
    * \param errorClose this callback is invoked when the
    *        connection closes abnormally
    */
-  virtual void SetCloseCallbacks (Callback<void, Ptr<Socket> > normalClose,
+  void SetCloseCallbacks (Callback<void, Ptr<Socket> > normalClose,
                           Callback<void, Ptr<Socket> > errorClose);
   /**
    * \brief Accept connection requests from remote hosts
-   * \param connectionRequest Callback for connection request from peer.
-   *        This user callback is passed a pointer to this socket, the
-   *        ip address and the port number of the connection originator.
+   * \param connectionRequest Callback for connection request from peer. 
+   *        This user callback is passed a pointer to this socket, the 
+   *        ip address and the port number of the connection originator. 
    *        This callback must return true to accept the incoming connection,
-   *        false otherwise. If the connection is accepted, the
-   *        "newConnectionCreated" callback will be invoked later to
-   *        give access to the user to the socket created to match
-   *        this new connection. If the user does not explicitly
+   *        false otherwise. If the connection is accepted, the 
+   *        "newConnectionCreated" callback will be invoked later to 
+   *        give access to the user to the socket created to match 
+   *        this new connection. If the user does not explicitly 
    *        specify this callback, all incoming  connections will be refused.
    * \param newConnectionCreated Callback for new connection: when a new
    *        is accepted, it is created and the corresponding socket is passed
-   *        back to the user through this callback. This user callback is
-   *        passed a pointer to the new socket, and the ip address and
+   *        back to the user through this callback. This user callback is 
+   *        passed a pointer to the new socket, and the ip address and 
    *        port number of the connection originator.
    */
-  virtual void SetAcceptCallback (Callback<bool, Ptr<Socket>,
+  void SetAcceptCallback (Callback<bool, Ptr<Socket>, 
                                    const Address &> connectionRequest,
-                          Callback<void, Ptr<Socket>,
+                          Callback<void, Ptr<Socket>, 
                                    const Address&> newConnectionCreated);
   /**
-   * \brief Notify application when a packet has been sent from transport
+   * \brief Notify application when a packet has been sent from transport 
    *        protocol (non-standard socket call)
    * \param dataSent Callback for the event that data is sent from the
    *        underlying transport protocol.  This callback is passed a
    *        pointer to the socket, and the number of bytes sent.
    */
-  virtual void SetDataSentCallback (Callback<void, Ptr<Socket>,
+  void SetDataSentCallback (Callback<void, Ptr<Socket>, 
                                      uint32_t> dataSent);
   /**
    * \brief Notify application when space in transmit buffer is added
    *
-   *        This callback is intended to notify a
+   *        This callback is intended to notify a 
    *        socket that would have been blocked in a blocking socket model
    *        that space is available in the transmit buffer and that it
    *        can call Send() again.
@@ -223,21 +219,21 @@ public:
    *        is available to be read.
    */
   void SetRecvCallback (Callback<void, Ptr<Socket> >);
-  /**
+  /** 
    * \brief Allocate a local endpoint for this socket.
    * \param address the address to try to allocate
    * \returns 0 on success, -1 on failure.
    */
   virtual int Bind (const Address &address) = 0;
 
-  /**
+  /** 
    * \brief Allocate a local IPv4 endpoint for this socket.
    *
    * \returns 0 on success, -1 on failure.
    */
   virtual int Bind () = 0;
 
-  /**
+  /** 
    * \brief Allocate a local IPv6 endpoint for this socket.
    *
    * \returns 0 on success, -1 on failure.
@@ -284,8 +280,8 @@ public:
 
   /**
    * \brief Returns the number of bytes which can be sent in a single call
-   * to Send.
-   *
+   * to Send. 
+   * 
    * For datagram sockets, this returns the number of bytes that
    * can be passed atomically through the underlying protocol.
    *
@@ -295,7 +291,7 @@ public:
    * \returns The number of bytes which can be sent in a single Send call.
    */
   virtual uint32_t GetTxAvailable (void) const = 0;
-
+ 
   /**
    * \brief Send data (or dummy data) to the remote host
    *
@@ -303,16 +299,16 @@ public:
    * call in the standard C library (libc):
    *   ssize_t send (int s, const void *msg, size_t len, int flags);
    * except that the send I/O is asynchronous.  This is the
-   * primary Send method at this low-level API and must be implemented
+   * primary Send method at this low-level API and must be implemented 
    * by subclasses.
-   *
+   * 
    * In a typical blocking sockets model, this call would block upon
    * lack of space to hold the message to be sent.  In ns-3 at this
    * API, the call returns immediately in such a case, but the callback
    * registered with SetSendCallback() is invoked when the socket
    * has space (when it conceptually unblocks); this is an asynchronous
    * I/O model for send().
-   *
+   * 
    * This variant of Send() uses class ns3::Packet to encapsulate
    * data, rather than providing a raw pointer and length field.
    * This allows an ns-3 application to attach tags if desired (such
@@ -321,17 +317,17 @@ public:
    * socket, just think of it as a fancy byte buffer with streaming
    * semantics.
    *
-   * If either the message buffer within the Packet is too long to pass
-   * atomically through the underlying protocol (for datagram sockets),
+   * If either the message buffer within the Packet is too long to pass 
+   * atomically through the underlying protocol (for datagram sockets), 
    * or the message buffer cannot entirely fit in the transmit buffer
-   * (for stream sockets), -1 is returned and SocketErrno is set
+   * (for stream sockets), -1 is returned and SocketErrno is set 
    * to ERROR_MSGSIZE.  If the packet does not fit, the caller can
-   * split the Packet (based on information obtained from
+   * split the Packet (based on information obtained from 
    * GetTxAvailable) and reattempt to send the data.
    *
    * The flags argument is formed by or'ing one or more of the values:
-   *        MSG_OOB        process out-of-band data
-   *        MSG_DONTROUTE  bypass routing, use direct interface
+   *        MSG_OOB        process out-of-band data 
+   *        MSG_DONTROUTE  bypass routing, use direct interface 
    * These flags are _unsupported_ as of ns-3.1.
    *
    * \param p ns3::Packet to send
@@ -353,14 +349,14 @@ public:
    * \param p packet to send
    * \param flags Socket control flags
    * \param toAddress IP Address of remote host
-   * \returns -1 in case of error or the number of bytes copied in the
+   * \returns -1 in case of error or the number of bytes copied in the 
    *          internal buffer and accepted for transmission.
    */
-  virtual int SendTo (Ptr<Packet> p, uint32_t flags,
+  virtual int SendTo (Ptr<Packet> p, uint32_t flags, 
                       const Address &toAddress) = 0;
 
   /**
-   * Return number of bytes which can be returned from one or
+   * Return number of bytes which can be returned from one or 
    * multiple calls to Recv.
    * Must be possible to call this method from the Recv callback.
    *
@@ -376,9 +372,9 @@ public:
    * call in the standard C library (libc):
    *   ssize_t recv (int s, void *buf, size_t len, int flags);
    * except that the receive I/O is asynchronous.  This is the
-   * primary Recv method at this low-level API and must be implemented
+   * primary Recv method at this low-level API and must be implemented 
    * by subclasses.
-   *
+   * 
    * This method is normally used only on a connected socket.
    * In a typical blocking sockets model, this call would block until
    * at least one byte is returned or the connection closes.
@@ -388,7 +384,7 @@ public:
    * to be notified of data being available to be read
    * (when it conceptually unblocks); this is an asynchronous
    * I/O model for recv().
-   *
+   * 
    * This variant of Recv() uses class ns3::Packet to encapsulate
    * data, rather than providing a raw pointer and length field.
    * This allows an ns-3 application to attach tags if desired (such
@@ -402,7 +398,7 @@ public:
    * is not necessarily preserved.  For a stream socket, the bytes
    * are delivered in order, and on-the-wire packet boundaries are
    * not preserved.
-   *
+   * 
    * The flags argument is formed by or'ing one or more of the values:
    *        MSG_OOB             process out-of-band data
    *        MSG_PEEK            peek at incoming message
@@ -423,7 +419,7 @@ public:
   virtual Ptr<Packet> Recv (uint32_t maxSize, uint32_t flags) = 0;
 
   /**
-   * \brief Read a single packet from the socket and retrieve the sender
+   * \brief Read a single packet from the socket and retrieve the sender 
    * address.
    *
    * Calls Recv(maxSize, flags) with maxSize
@@ -448,10 +444,10 @@ public:
   //   The remainder of these public methods are overloaded methods  //
   //   or variants of Send() and Recv(), and they are non-virtual    //
   /////////////////////////////////////////////////////////////////////
-
+ 
   /**
    * \brief Send data (or dummy data) to the remote host
-   *
+   * 
    * Overloaded version of Send(..., flags) with flags set to zero.
    *
    * \param p ns3::Packet to send
@@ -462,12 +458,12 @@ public:
 
   /**
    * \brief Send data (or dummy data) to the remote host
-   *
-   * This method is provided so as to have an API which is closer in
+   * 
+   * This method is provided so as to have an API which is closer in 
    * appearance to that of real network or BSD sockets.
    *
-   * \param buf A pointer to a raw byte buffer of some data to send.  If
-   * this buffer is 0, we send dummy data whose size is specified by the
+   * \param buf A pointer to a raw byte buffer of some data to send.  If 
+   * this buffer is 0, we send dummy data whose size is specified by the 
    * second parameter
    * \param size the number of bytes to copy from the buffer
    * \param flags Socket control flags
@@ -480,21 +476,21 @@ public:
   /**
    * \brief Send data to a specified peer.
    *
-   * This method is provided so as to have an API which is closer in
+   * This method is provided so as to have an API which is closer in 
    * appearance to that of real network or BSD sockets.
    *
    * \param buf A pointer to a raw byte buffer of some data to send.
-   * If this is 0, we send dummy data whose size is specified by the
+   * If this is 0, we send dummy data whose size is specified by the 
    * third parameter
    * \param size the number of bytes to copy from the buffer
    * \param flags Socket control flags
    * \param address IP Address of remote host
-   * \returns -1 in case of error or the number of bytes copied in the
+   * \returns -1 in case of error or the number of bytes copied in the 
    *          internal buffer and accepted for transmission.
    *
    */
-  int SendTo (const uint8_t* buf, uint32_t size, uint32_t flags,
-              const Address &address);
+  int SendTo (const uint8_t* buf, uint32_t size, uint32_t flags, 
+              const Address &address); 
 
   /**
    * \brief Read a single packet from the socket
@@ -510,13 +506,13 @@ public:
   /**
    * \brief Recv data (or dummy data) from the remote host
    *
-   * This method is provided so as to have an API which is closer in
+   * This method is provided so as to have an API which is closer in 
    * appearance to that of real network or BSD sockets.
-   *
+   * 
    * If the underlying packet was carring null (fake) data, this buffer
    * will be zeroed up to the length specified by the return value.
    *
-   * \param buf A pointer to a raw byte buffer to write the data to.
+   * \param buf A pointer to a raw byte buffer to write the data to. 
    * \param size Number of bytes (at most) to copy to buf
    * \param flags any flags to pass to the socket
    * \returns number of bytes copied into buf
@@ -524,7 +520,7 @@ public:
   int Recv (uint8_t* buf, uint32_t size, uint32_t flags);
 
   /**
-   * \brief Read a single packet from the socket and retrieve the sender
+   * \brief Read a single packet from the socket and retrieve the sender 
    * address.
    *
    * Calls RecvFrom (maxSize, flags, fromAddress) with maxSize
@@ -542,10 +538,10 @@ public:
    * \brief Read a single packet from the socket and retrieve the sender
    * address.
    *
-   * This method is provided so as to have an API which is closer in
+   * This method is provided so as to have an API which is closer in 
    * appearance to that of real network or BSD sockets.
-   *
-   * \param buf A pointer to a raw byte buffer to write the data to.
+   * 
+   * \param buf A pointer to a raw byte buffer to write the data to. 
    * If the underlying packet was carring null (fake) data, this buffer
    * will be zeroed up to the length specified by the return value.
    * \param size Number of bytes (at most) to copy to buf
@@ -562,7 +558,7 @@ public:
    * \param address the address name this socket is associated with.
    * \returns 0 if success, -1 otherwise
    */
-  virtual int GetSockName (Address &address) const = 0;
+  virtual int GetSockName (Address &address) const = 0; 
 
   /**
    * \brief Bind a socket to specific device.
@@ -574,8 +570,8 @@ public:
    * packets received from the bound interface will be delivered.
    *
    * This option has no particular relationship to binding sockets to
-   * an address via Socket::Bind ().  It is possible to bind sockets to a
-   * specific IP address on the bound interface by calling both
+   * an address via Socket::Bind ().  It is possible to bind sockets to a 
+   * specific IP address on the bound interface by calling both 
    * Socket::Bind (address) and Socket::BindToNetDevice (device), but it
    * is also possible to bind to mismatching device and address, even if
    * the socket can not receive any packets as a result.
@@ -593,11 +589,11 @@ public:
    *
    * This method corresponds to using getsockopt() SO_BINDTODEVICE
    * of real network or BSD sockets.
-   *
-   *
+   * 
+   * 
    * \returns Pointer to interface.
    */
-  Ptr<NetDevice> GetBoundNetDevice ();
+  Ptr<NetDevice> GetBoundNetDevice (); 
 
 
   /**
@@ -626,7 +622,7 @@ public:
   /**
    * \brief Enable/Disable receive packet information to socket.
    *
-   * For IP_PKTINFO/IP6_PKTINFO. This method is only usable for
+   * For IP_PKTINFO/IP6_PKTINFO. This method is only usable for 
    * Raw socket and Datagram Socket. Not supported for Stream socket.
    *
    * Method doesn't make distinction between IPv4 and IPv6. If it is enabled,
@@ -646,7 +642,7 @@ public:
 
   /**
    * \brief Manually set IP Type of Service field
-   *
+   * 
    * This method corresponds to using setsockopt () IP_TOS of
    * real network or BSD sockets. This option is for IPv4 only.
    * Setting the IP TOS should also change the socket queueing
@@ -671,7 +667,7 @@ public:
    * \brief Tells a socket to pass information about IP Type of Service up the stack
    *
    * This method corresponds to using setsockopt () IP_RECVTOS of real
-   * network or BSD sockets. In our implementation, the socket simply
+   * network or BSD sockets. In our implementation, the socket simply 
    * adds a SocketIpTosTag tag to the packet before passing the
    * packet up the stack.
    *
@@ -692,7 +688,7 @@ public:
 
   /**
    * \brief Manually set IPv6 Traffic Class field
-   *
+   * 
    * This method corresponds to using setsockopt () IPV6_TCLASS of
    * real network or BSD sockets. This option is for IPv6 only.
    * Setting the IPV6_TCLASSS to -1 clears the option and let the socket
@@ -716,7 +712,7 @@ public:
    * \brief Tells a socket to pass information about IPv6 Traffic Class up the stack
    *
    * This method corresponds to using setsockopt () IPV6_RECVTCLASS of real
-   * network or BSD sockets. In our implementation, the socket simply
+   * network or BSD sockets. In our implementation, the socket simply 
    * adds a SocketIpv6TclasssTag tag to the packet before passing the
    * packet up the stack.
    *
@@ -737,7 +733,7 @@ public:
 
   /**
    * \brief Manually set IP Time to Live field
-   *
+   * 
    * This method corresponds to using setsockopt () IP_TTL of
    * real network or BSD sockets.
    *
@@ -759,7 +755,7 @@ public:
    * \brief Tells a socket to pass information about IP_TTL up the stack
    *
    * This method corresponds to using setsockopt () IP_RECVTTL of real
-   * network or BSD sockets. In our implementation, the socket simply
+   * network or BSD sockets. In our implementation, the socket simply 
    * adds a SocketIpTtlTag tag to the packet before passing the
    * packet up the stack.
    *
@@ -780,7 +776,7 @@ public:
 
   /**
    * \brief Manually set IPv6 Hop Limit
-   *
+   * 
    * This method corresponds to using setsockopt () IPV6_HOPLIMIT of
    * real network or BSD sockets.
    *
@@ -802,7 +798,7 @@ public:
    * \brief Tells a socket to pass information about IPv6 Hop Limit up the stack
    *
    * This method corresponds to using setsockopt () IPV6_RECVHOPLIMIT of real
-   * network or BSD sockets. In our implementation, the socket simply
+   * network or BSD sockets. In our implementation, the socket simply 
    * adds a SocketIpv6HopLimitTag tag to the packet before passing the
    * packet up the stack.
    *
@@ -820,11 +816,11 @@ public:
    * \return Whether the IPV6_RECVHOPLIMIT is set
    */
   bool IsIpv6RecvHopLimit (void) const;
-
+ 
 protected:
   /**
    * \brief Notify through the callback (if set) that the connection has been
-   *        established. It is triggered for the client only.
+   *        established.
    */
   void NotifyConnectionSucceeded (void);
 
@@ -857,32 +853,32 @@ protected:
    * \param from the address the connection is incoming from
    * \returns true if the connection must be accepted, false otherwise.
    */
-  virtual bool NotifyConnectionRequest (const Address &from);
+  bool NotifyConnectionRequest (const Address &from);
 
   /**
    * \brief Notify through the callback (if set) that a new connection has been
-   *        created, i.e. it is a server side callback.
+   *        created.
    */
-  virtual void NotifyNewConnectionCreated (Ptr<Socket> socket, const Address &from);
+  void NotifyNewConnectionCreated (Ptr<Socket> socket, const Address &from);
 
   /**
    * \brief Notify through the callback (if set) that some data have been sent.
    *
    * \param size number of sent bytes.
    */
-  virtual void NotifyDataSent (uint32_t size);
+  void NotifyDataSent (uint32_t size);
 
   /**
    * \brief Notify through the callback (if set) that some data have been sent.
    *
    * \param spaceAvailable the number of bytes available in the transmission buffer.
    */
-  virtual void NotifySend (uint32_t spaceAvailable);
+  void NotifySend (uint32_t spaceAvailable);
 
   /**
    * \brief Notify through the callback (if set) that some data have been received.
    */
-  virtual void NotifyDataRecv (void);
+  void NotifyDataRecv (void);
 
   // inherited function, no doc necessary
   virtual void DoDispose (void);
@@ -918,11 +914,7 @@ protected:
   Ptr<NetDevice> m_boundnetdevice; //!< the device this socket is bound to (might be null).
   bool m_recvPktInfo; //!< if the socket should add packet info tags to the packet forwarded to L4.
 
-
-//Hack matt to pass callbacks from master to meta
-//private:
-protected:
-  // TODO matt : use TracedCallback instead !
+private:
   Callback<void, Ptr<Socket> >                   m_connectionSucceeded;  //!< connection succeeded callback
   Callback<void, Ptr<Socket> >                   m_connectionFailed;     //!< connection failed callback
   Callback<void, Ptr<Socket> >                   m_normalClose;          //!< connection closed callback
@@ -1168,7 +1160,7 @@ public:
    * \returns the TOS
    */
   uint8_t GetTos (void) const;
-
+  
   /**
    * \brief Get the type ID.
    * \return the object TypeId
@@ -1215,7 +1207,7 @@ public:
    * \returns the Tclass
    */
   uint8_t GetTclass (void) const;
-
+  
   /**
    * \brief Get the type ID.
    * \return the object TypeId
diff --git a/src/network/utils/pcap-file-wrapper.cc b/src/network/utils/pcap-file-wrapper.cc
index 8de725d..7c8e84d 100644
--- a/src/network/utils/pcap-file-wrapper.cc
+++ b/src/network/utils/pcap-file-wrapper.cc
@@ -121,7 +121,7 @@ PcapFileWrapper::Write (Time t, Ptr<const Packet> p)
 }
 
 void
-PcapFileWrapper::Write (Time t, const Header &header, Ptr<const Packet> p)
+PcapFileWrapper::Write (Time t, Header &header, Ptr<const Packet> p)
 {
   NS_LOG_FUNCTION (this << t << &header << p);
   uint64_t current = t.GetMicroSeconds ();
diff --git a/src/network/utils/pcap-file-wrapper.h b/src/network/utils/pcap-file-wrapper.h
index 02bfd17..5fd04c3 100644
--- a/src/network/utils/pcap-file-wrapper.h
+++ b/src/network/utils/pcap-file-wrapper.h
@@ -130,7 +130,7 @@ public:
    * \param p Packet to write to the pcap file.
    * 
    */
-  void Write (Time t, const Header &header, Ptr<const Packet> p);
+  void Write (Time t, Header &header, Ptr<const Packet> p);
 
   /**
    * \brief Write the provided data buffer to the pcap file.
diff --git a/src/network/utils/pcap-file.cc b/src/network/utils/pcap-file.cc
index 87f7b8d..f67d269 100644
--- a/src/network/utils/pcap-file.cc
+++ b/src/network/utils/pcap-file.cc
@@ -28,7 +28,6 @@
 #include "ns3/buffer.h"
 #include "pcap-file.h"
 #include "ns3/log.h"
-#include "ns3/build-profile.h"
 //
 // This file is used as part of the ns-3 test framework, so please refrain from 
 // adding any ns-3 specific constructs such as Packet to this file.
@@ -398,31 +397,27 @@ PcapFile::WritePacketHeader (uint32_t tsSec, uint32_t tsUsec, uint32_t totalLen)
   m_file.write ((const char *)&header.m_tsUsec, sizeof(header.m_tsUsec));
   m_file.write ((const char *)&header.m_inclLen, sizeof(header.m_inclLen));
   m_file.write ((const char *)&header.m_origLen, sizeof(header.m_origLen));
-  NS_BUILD_DEBUG(m_file.flush());
   return inclLen;
 }
 
 void
 PcapFile::Write (uint32_t tsSec, uint32_t tsUsec, uint8_t const * const data, uint32_t totalLen)
 {
-  NS_LOG_FUNCTION (this << tsSec << tsUsec << " with data " << &data << totalLen);
+  NS_LOG_FUNCTION (this << tsSec << tsUsec << &data << totalLen);
   uint32_t inclLen = WritePacketHeader (tsSec, tsUsec, totalLen);
   m_file.write ((const char *)data, inclLen);
-  NS_BUILD_DEBUG(m_file.flush());
 }
 
 void 
 PcapFile::Write (uint32_t tsSec, uint32_t tsUsec, Ptr<const Packet> p)
 {
-  NS_LOG_FUNCTION (this << tsSec << tsUsec << " packet:" << p);
+  NS_LOG_FUNCTION (this << tsSec << tsUsec << p);
   uint32_t inclLen = WritePacketHeader (tsSec, tsUsec, p->GetSize ());
-  uint32_t left = p->CopyData (&m_file, inclLen);
-  NS_ASSERT (left == inclLen);
-  NS_BUILD_DEBUG(m_file.flush());
+  p->CopyData (&m_file, inclLen);
 }
 
 void 
-PcapFile::Write (uint32_t tsSec, uint32_t tsUsec, const Header &header, Ptr<const Packet> p)
+PcapFile::Write (uint32_t tsSec, uint32_t tsUsec, Header &header, Ptr<const Packet> p)
 {
   NS_LOG_FUNCTION (this << tsSec << tsUsec << &header << p);
   uint32_t headerSize = header.GetSerializedSize ();
diff --git a/src/network/utils/pcap-file.h b/src/network/utils/pcap-file.h
index 966de6c..f3ed7a3 100644
--- a/src/network/utils/pcap-file.h
+++ b/src/network/utils/pcap-file.h
@@ -95,7 +95,7 @@ public:
    * PCAP_PPP, PCAP_80211, etc.  If you are storing different kinds of packet
    * data, such as naked TCP headers, you are at liberty to locally define your
    * own data link types.  According to the pcap-linktype man page, "well-known"
-   * pcap linktypes range from 0 to 263.  If you use a large random number for
+   * pcap linktypes range from 0 to 177.  If you use a large random number for
    * your type, chances are small for a collision.
    *
    * \param snapLen An optional maximum size for packets written to the file.
@@ -147,7 +147,7 @@ public:
    * \param p           Packet to write
    * 
    */
-  void Write (uint32_t tsSec, uint32_t tsUsec, const Header &header, Ptr<const Packet> p);
+  void Write (uint32_t tsSec, uint32_t tsUsec, Header &header, Ptr<const Packet> p);
 
 
   /**
@@ -296,8 +296,8 @@ private:
   typedef struct {
     uint32_t m_tsSec;         /**< seconds part of timestamp */
     uint32_t m_tsUsec;        /**< microseconds part of timestamp (nsecs for PCAP_NSEC_MAGIC) */
-    uint32_t m_inclLen;       /**< number of octets from the packet saved in this record */
-    uint32_t m_origLen;       /**< original number of octets in the packet */
+    uint32_t m_inclLen;       /**< number of octets of packet saved in file */
+    uint32_t m_origLen;       /**< actual length of original packet */
   } PcapRecordHeader;
 
   /**
@@ -337,10 +337,6 @@ private:
   void WriteFileHeader (void);
   /**
    * \brief Write a Pcap packet header
-   *
-   * The pcap header has a fixed length of 24 bytes. The last 4 bytes
-   * represent the link-layer type
-   *
    * \param tsSec Time stamp (seconds part)
    * \param tsUsec Time stamp (microseconds part)
    * \param totalLen total packet length
diff --git a/src/network/utils/sequence-number.h b/src/network/utils/sequence-number.h
index 49c0c5c..45585ff 100644
--- a/src/network/utils/sequence-number.h
+++ b/src/network/utils/sequence-number.h
@@ -60,26 +60,7 @@ public:
   /**
    * \brief Constructs a SequenceNumber with the given value
    * \param value the sequence number value
-   */
-  template<typename NUMERIC_TYPE2>
-  explicit SequenceNumber (NUMERIC_TYPE2 value)
-    : m_value (value)
-  {}
-
-  /**
-   * \brief Constructs a SequenceNumber from a copy
-   * \param value sequence number to copy
-   */
-  template<typename NUMERIC_TYPE2, typename SIGNED_TYPE2>
-  SequenceNumber (SequenceNumber<NUMERIC_TYPE2, SIGNED_TYPE2> const &value)
-    : m_value (value.GetValue())
-  {}
-
-
-  /**
-   * \brief Constructs a SequenceNumber with the given value
-   * \param value the sequence number value
-   */
+   */ 
   explicit SequenceNumber (NUMERIC_TYPE value)
     : m_value (value)
   {}
@@ -125,7 +106,7 @@ public:
   /**
    * \brief Extracts the numeric value of the sequence number
    * \returns the sequence number value
-   */
+   */ 
   NUMERIC_TYPE GetValue () const
   {
     return m_value;
@@ -134,7 +115,7 @@ public:
   /**
    * \brief Prefix increment operator
    * \returns incremented sequence number
-   */
+   */ 
   SequenceNumber<NUMERIC_TYPE, SIGNED_TYPE> operator++ ()
   {
     m_value++;
@@ -144,7 +125,7 @@ public:
   /**
    * \brief Postfix increment operator
    * \returns incremented sequence number
-   */
+   */ 
   SequenceNumber<NUMERIC_TYPE, SIGNED_TYPE> operator++ (int)
   {
     SequenceNumber<NUMERIC_TYPE, SIGNED_TYPE> retval (m_value);
@@ -155,7 +136,7 @@ public:
   /**
    * \brief Prefix decrement operator
    * \returns decremented sequence number
-   */
+   */ 
   SequenceNumber<NUMERIC_TYPE, SIGNED_TYPE> operator-- ()
   {
     m_value--;
@@ -165,7 +146,7 @@ public:
    /**
    * \brief Postfix decrement operator
    * \returns incremented sequence number
-   */
+   */ 
   SequenceNumber<NUMERIC_TYPE, SIGNED_TYPE> operator-- (int)
   {
     SequenceNumber<NUMERIC_TYPE, SIGNED_TYPE> retval (m_value);
@@ -177,18 +158,18 @@ public:
    * \brief Plus equals operator
    * \param value value to add to sequence number
    * \returns incremented sequence number
-   */
+   */ 
   SequenceNumber<NUMERIC_TYPE, SIGNED_TYPE>& operator+= (SIGNED_TYPE value)
   {
     m_value += value;
     return *this;
   }
-
+  
   /**
    * \brief Minus equals operator
    * \param value value to subtract from sequence number
    * \returns decremented sequence number
-   */
+   */ 
   SequenceNumber<NUMERIC_TYPE, SIGNED_TYPE>& operator-= (SIGNED_TYPE value)
   {
     m_value -= value;
@@ -487,12 +468,6 @@ std::istream & operator >> (std::istream &is, const SequenceNumber<NUMERIC_TYPE,
 
 /**
  * \ingroup network
- * 64 bit Sequence number.
- */
-typedef SequenceNumber<uint64_t, int64_t> SequenceNumber64;
-
-/**
- * \ingroup network
  * 32 bit Sequence number.
  */
 typedef SequenceNumber<uint32_t, int32_t> SequenceNumber32;
diff --git a/src/network/utils/sll-header.cc b/src/network/utils/sll-header.cc
deleted file mode 100644
index ef23ec5..0000000
--- a/src/network/utils/sll-header.cc
+++ /dev/null
@@ -1,125 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-#include "sll-header.h"
-#include "ns3/log.h"
-
-
-namespace ns3 {
-
-NS_LOG_COMPONENT_DEFINE ("SllHeader");
-
-NS_OBJECT_ENSURE_REGISTERED (SllHeader);
-
-SllHeader::SllHeader ()
-  : m_packetType (UNICAST_FROM_PEER_TO_ME),
-    m_arphdType (0),
-    m_addressLength (0),
-    m_address (0),
-    m_protocolType (0)
-{
-  NS_LOG_FUNCTION (this);
-}
-
-SllHeader::~SllHeader ()
-{
-  NS_LOG_FUNCTION (this);
-}
-
-
-TypeId
-SllHeader::GetTypeId (void)
-{
-  static TypeId tid = TypeId ("ns3::SllHeader")
-    .SetParent<Header> ()
-    .SetGroupName ("Network")
-    .AddConstructor<SllHeader> ()
-  ;
-  return tid;
-}
-
-TypeId
-SllHeader::GetInstanceTypeId (void) const
-{
-  return GetTypeId ();
-}
-
-uint16_t
-SllHeader::GetArpType () const
-{
-  return m_arphdType;
-}
-
-void
-SllHeader::SetArpType (uint16_t arphdType)
-{
-  NS_LOG_FUNCTION (arphdType);
-  m_arphdType = arphdType;
-}
-
-SllHeader::PacketType
-SllHeader::GetPacketType (void) const
-{
-  return m_packetType;
-}
-
-void
-SllHeader::SetPacketType (PacketType type)
-{
-  NS_LOG_FUNCTION (type);
-  m_packetType = type;
-}
-
-void
-SllHeader::Print (std::ostream &os)  const
-{
-  os << "SLLHeader packetType=" << m_packetType << " protocol=" << m_protocolType;
-}
-
-uint32_t
-SllHeader::GetSerializedSize (void)  const
-{
-  return 2 + 2 + 2 + 8 + 2;
-}
-
-void
-SllHeader::Serialize (Buffer::Iterator start)  const
-{
-  Buffer::Iterator i = start;
-  i.WriteHtonU16 (m_packetType);
-  i.WriteHtonU16 (m_arphdType);
-  i.WriteHtonU16 (m_addressLength);
-  i.WriteHtonU64 (m_address);
-  i.WriteHtonU16 (m_protocolType);
-}
-
-uint32_t
-SllHeader::Deserialize (Buffer::Iterator start)
-{
-  Buffer::Iterator i = start;
-  m_packetType = static_cast<PacketType> (i.ReadNtohU16 ());
-  m_arphdType = i.ReadNtohU16 ();
-  m_addressLength = i.ReadNtohU16 ();
-  m_address = i.ReadNtohU64 ();
-  m_protocolType = i.ReadNtohU16 ();
-
-  return GetSerializedSize ();
-}
-
-}
diff --git a/src/network/utils/sll-header.h b/src/network/utils/sll-header.h
deleted file mode 100644
index dc43f0b..0000000
--- a/src/network/utils/sll-header.h
+++ /dev/null
@@ -1,125 +0,0 @@
-/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */
-/*
- * Copyright (c) 2015 Universit√© Pierre et Marie Curie
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * Author: Matthieu Coudron <matthieu.coudron@lip6.fr>
- */
-#ifndef SLL_HEADER_H
-#define SLL_HEADER_H
-
-#include "ns3/buffer.h"
-#include "ns3/header.h"
-#include <stdint.h>
-
-namespace ns3 {
-
-/**
-  * \ingroup packet
-  *
-  * \brief Protocol header serialization and deserialization.
-  *
-  * Libpcap sometimes add an additional header to provide information that would be
-  * lost otherwise due to the link-layer/capture mechanism, for instance when capturing from
-  * "nlmon" device on linux
-  *
-  * \see http://www.tcpdump.org/linktypes/LINKTYPE_LINUX_SLL.html
-  * \see https://wiki.wireshark.org/SLL
-  *
-  * \verbatim
-  * +---------------------------+
-  * |         Packet type       |
-  * |         (2 Octets)        |
-  * +---------------------------+
-  * |        ARPHRD_ type       |
-  * |         (2 Octets)        |
-  * +---------------------------+
-  * | Link-layer address length |
-  * |         (2 Octets)        |
-  * +---------------------------+
-  * |    Link-layer address     |
-  * |         (8 Octets)        |
-  * +---------------------------+
-  * |        Protocol type      |
-  * |         (2 Octets)        |
-  * +---------------------------+
-  * |           Payload         |
-  * .                           .
-  * .                           .
-  * .                           .
-  * \endverbatim
-  */
-class SllHeader : public Header
-{
-public:
-  enum PacketType
-  {
-    UNICAST_FROM_PEER_TO_ME = 0, /**< the packet was specifically sent to us by somebody else */
-    BROADCAST_BY_PEER = 1, /**< packet was broadcast by somebody else */
-    MULTICAST_BY_PEER = 2, /**< packet was multicast, but not broadcast, by somebody else */
-    INTERCEPTED_PACKET = 3, /**< packet was sent to somebody else by somebody else **/
-    SENT_BY_US  /**< the packet was sent by us */
-  };
-
-  /**
-    * \brief Get the type ID.
-    * \return the object TypeId
-    */
-  static TypeId GetTypeId (void);
-
-  SllHeader ();
-  virtual ~SllHeader ();
-
-  /**
-    * \return ARP header type field in network byte order
-    *  The ARPHRD_ type field is in network byte order; it contains a Linux ARPHRD_ value for the link-layer device type.
-    */
-  uint16_t GetArpType () const;
-
-  /**
-    * \param arphw ARP protocol hardware identifier
-    */
-  void SetArpType (uint16_t arphdType);
-
-   /**
-    * \return Packet type
-    */
-  enum PacketType GetPacketType () const;
-
-  /**
-    * \param type Depends on source and address of the packet
-    */
-  void SetPacketType (PacketType type);
-
-  //! Inherited from ObjectBase
-  virtual TypeId GetInstanceTypeId (void) const;
-  //! Inherited from Header
-  virtual uint32_t GetSerializedSize (void) const;
-  virtual void Serialize (Buffer::Iterator start) const;
-  virtual uint32_t Deserialize (Buffer::Iterator start);
-  virtual void Print (std::ostream &os) const;
-
-protected:
-  // declared in packet order
-  PacketType m_packetType;
-  uint16_t m_arphdType;   /**< ARP protocol hardware identifier */
-  uint16_t m_addressLength;
-  uint64_t m_address;
-  uint16_t m_protocolType;
-};
-
-} // namespace ns3
-
-#endif /* SLL_HEADER_H */
diff --git a/src/network/wscript b/src/network/wscript
index adbefac..ebd9e8b 100644
--- a/src/network/wscript
+++ b/src/network/wscript
@@ -26,7 +26,6 @@ def build(bld):
         'utils/address-utils.cc',
         'utils/ascii-file.cc',
         'utils/crc32.cc',
-        'utils/sll-header.cc',
         'utils/data-rate.cc',
         'utils/drop-tail-queue.cc',
         'utils/error-model.cc',
@@ -120,7 +119,6 @@ def build(bld):
         'utils/ipv4-address.h',
         'utils/ipv6-address.h',
         'utils/llc-snap-header.h',
-        'utils/sll-header.h',
         'utils/mac16-address.h',
         'utils/mac48-address.h',
         'utils/mac64-address.h',
diff --git a/src/point-to-point/model/point-to-point-channel.cc b/src/point-to-point/model/point-to-point-channel.cc
index 87a92e9..91bb4d5 100644
--- a/src/point-to-point/model/point-to-point-channel.cc
+++ b/src/point-to-point/model/point-to-point-channel.cc
@@ -29,21 +29,16 @@ NS_LOG_COMPONENT_DEFINE ("PointToPointChannel");
 
 NS_OBJECT_ENSURE_REGISTERED (PointToPointChannel);
 
-TypeId
+TypeId 
 PointToPointChannel::GetTypeId (void)
 {
   static TypeId tid = TypeId ("ns3::PointToPointChannel")
     .SetParent<Channel> ()
     .SetGroupName ("PointToPoint")
     .AddConstructor<PointToPointChannel> ()
-    .AddAttribute ("AlternateDelay",
-                    "Transmission delay through the channel in the other direction: has to be set after Delay",
+    .AddAttribute ("Delay", "Transmission delay through the channel",
                    TimeValue (Seconds (0)),
-                   MakeTimeAccessor (&PointToPointChannel::m_alternateDelay),
-                   MakeTimeChecker ())
-    .AddAttribute ("Delay", "Transmission delay through the channel in one direction",
-                   TimeValue (Seconds (0)),
-                   MakeTimeAccessor ( (Time (PointToPointChannel::*)() const)&PointToPointChannel::GetDelay, &PointToPointChannel::SetDelay),
+                   MakeTimeAccessor (&PointToPointChannel::m_delay),
                    MakeTimeChecker ())
     .AddTraceSource ("TxRxPointToPoint",
                      "Trace source indicating transmission of packet "
@@ -56,13 +51,12 @@ PointToPointChannel::GetTypeId (void)
 }
 
 //
-// By default, you get a channel that
+// By default, you get a channel that 
 // has an "infitely" fast transmission speed and zero delay.
 PointToPointChannel::PointToPointChannel()
   :
     Channel (),
     m_delay (Seconds (0.)),
-    m_alternateDelay (Seconds (0.)),
     m_nDevices (0)
 {
   NS_LOG_FUNCTION_NOARGS ();
@@ -86,8 +80,6 @@ PointToPointChannel::Attach (Ptr<PointToPointNetDevice> device)
       m_link[1].m_dst = m_link[0].m_src;
       m_link[0].m_state = IDLE;
       m_link[1].m_state = IDLE;
-      m_link[0].m_delay = m_delay;
-      m_link[1].m_delay = m_alternateDelay;
     }
 }
 
@@ -105,17 +97,16 @@ PointToPointChannel::TransmitStart (
 
   uint32_t wire = src == m_link[0].m_src ? 0 : 1;
 
-  Simulator::ScheduleWithContext (GetDestination(wire)->GetNode ()->GetId (),
-                                  txTime + GetDelay(wire),
-                                  &PointToPointNetDevice::Receive,
-                                  GetDestination(wire), p);
+  Simulator::ScheduleWithContext (m_link[wire].m_dst->GetNode ()->GetId (),
+                                  txTime + m_delay, &PointToPointNetDevice::Receive,
+                                  m_link[wire].m_dst, p);
 
   // Call the tx anim callback on the net device
-  m_txrxPointToPoint (p, src, GetDestination(wire), txTime, txTime + GetDelay(wire));
+  m_txrxPointToPoint (p, src, m_link[wire].m_dst, txTime, txTime + m_delay);
   return true;
 }
 
-uint32_t
+uint32_t 
 PointToPointChannel::GetNDevices (void) const
 {
   NS_LOG_FUNCTION_NOARGS ();
@@ -134,57 +125,33 @@ Ptr<NetDevice>
 PointToPointChannel::GetDevice (uint32_t i) const
 {
   NS_LOG_FUNCTION_NOARGS ();
-  NS_ASSERT (i < 2);
   return GetPointToPointDevice (i);
 }
 
 Time
-PointToPointChannel::GetDelay () const
-{
-  return GetDelay(0);
-}
-
-
-Time
-PointToPointChannel::GetDelay (uint32_t i) const
-{
-  NS_ASSERT (i < 2);
-  return m_link[i].m_delay;
-}
-
-void
-PointToPointChannel::SetDelay (Time owd)
+PointToPointChannel::GetDelay (void) const
 {
-  NS_ASSERT(!IsInitialized());
-  m_delay = owd;
-
-  /* if m_alternateDelay set to its default value than we update it */
-  // REMOVED cause it was buggy ?!
-//  struct TypeId::AttributeInformation info;
-//  if(GetTypeId().LookupAttributeByName("AlternateDelay", &info) && info.originalInitialValue == info.initialValue) {
-//    m_alternateDelay = owd;
-//  }
-
+  return m_delay;
 }
 
 Ptr<PointToPointNetDevice>
 PointToPointChannel::GetSource (uint32_t i) const
 {
-  NS_ASSERT (i < 2);
   return m_link[i].m_src;
 }
 
 Ptr<PointToPointNetDevice>
 PointToPointChannel::GetDestination (uint32_t i) const
 {
-  NS_ASSERT (i < 2);
   return m_link[i].m_dst;
 }
 
 bool
 PointToPointChannel::IsInitialized (void) const
 {
-  return (m_link[0].m_state != INITIALIZING && m_link[1].m_state != INITIALIZING);
+  NS_ASSERT (m_link[0].m_state != INITIALIZING);
+  NS_ASSERT (m_link[1].m_state != INITIALIZING);
+  return true;
 }
 
 } // namespace ns3
diff --git a/src/point-to-point/model/point-to-point-channel.h b/src/point-to-point/model/point-to-point-channel.h
index 72bd9be..70d9c0a 100644
--- a/src/point-to-point/model/point-to-point-channel.h
+++ b/src/point-to-point/model/point-to-point-channel.h
@@ -100,22 +100,12 @@ public:
    */
   virtual Ptr<NetDevice> GetDevice (uint32_t i) const;
 
+protected:
   /**
    * \brief Get the delay associated with this channel
-   * \param i Between 0 and 1: select the link
    * \returns Time delay
    */
   Time GetDelay (void) const;
-  Time GetDelay (uint32_t i) const;
-
-  /**
-   * Must be called before link initialization
-   * \param t duration of packet transfer in both directions
-   */
-  void SetDelay (Time t) ;
-
-protected:
-
 
   /**
    * \brief Check to make sure the link is initialized
@@ -157,8 +147,7 @@ private:
   /** Each point to point link has exactly two net devices. */
   static const int N_DEVICES = 2;
 
-  Time          m_delay;             //!< Propagation delay
-  Time          m_alternateDelay;    //!< Propagation delay
+  Time          m_delay;    //!< Propagation delay
   int32_t       m_nDevices; //!< Devices of this channel
 
   /**
@@ -201,12 +190,11 @@ public:
     /** \brief Create the link, it will be in INITIALIZING state
      *
      */
-    Link() : m_state (INITIALIZING), m_src (0), m_dst (0), m_delay(0) {}
+    Link() : m_state (INITIALIZING), m_src (0), m_dst (0) {}
 
     WireState                  m_state; //!< State of the link
     Ptr<PointToPointNetDevice> m_src;   //!< First NetDevice
     Ptr<PointToPointNetDevice> m_dst;   //!< Second NetDevice
-    Time m_delay;                       //!< Propagation delay
   };
 
   Link    m_link[N_DEVICES]; //!< Link model
diff --git a/src/point-to-point/test/point-to-point-test.cc b/src/point-to-point/test/point-to-point-test.cc
index 2e7cf59..211e658 100644
--- a/src/point-to-point/test/point-to-point-test.cc
+++ b/src/point-to-point/test/point-to-point-test.cc
@@ -26,9 +26,6 @@
 
 using namespace ns3;
 
-static const Time testStartTime = Seconds (1.0);
-static const Time tolerance = MilliSeconds(5);
-
 /**
  * \brief Test class for PointToPoint model
  *
@@ -41,38 +38,24 @@ public:
   /**
    * \brief Create the test
    */
-  PointToPointTest (Time forwardDelay, Time backwardDelay);
+  PointToPointTest ();
 
   /**
    * \brief Run the test
    */
   virtual void DoRun (void);
 
-
-
-protected:
-
-  Time m_forwardDelay;
-  Time m_backwardDelay;
-
-  Time m_packetArrival[2];
-
-  Ptr<PointToPointNetDevice> m_devA;
-  Ptr<PointToPointNetDevice> m_devB;
-
+private:
   /**
    * \brief Send one packet to the device specified
    *
    * \param device NetDevice to send to
    */
   void SendOnePacket (Ptr<PointToPointNetDevice> device);
-  bool RecvOnePacket ( Ptr<NetDevice> dev, Ptr<const Packet> p, uint16_t protocol, const Address & sender);
 };
 
-PointToPointTest::PointToPointTest (Time forwardDelay, Time backwardDelay)
-  : TestCase ("PointToPoint"),
-    m_forwardDelay(forwardDelay),
-    m_backwardDelay(backwardDelay)
+PointToPointTest::PointToPointTest ()
+  : TestCase ("PointToPoint")
 {
 }
 
@@ -83,63 +66,31 @@ PointToPointTest::SendOnePacket (Ptr<PointToPointNetDevice> device)
   device->Send (p, device->GetBroadcast (), 0x800);
 }
 
-bool
-PointToPointTest::RecvOnePacket ( Ptr<NetDevice> dev, Ptr<const Packet> p, uint16_t protocol, const Address & sender)
-{
-//    if(dev == this->de)
-    static int counter=0;
-    m_packetArrival[counter] = Simulator::Now();
-
-    if(counter==0) {
-        Simulator::ScheduleNow( &PointToPointTest::SendOnePacket, this, m_devB);
-    }
-
-    counter++;
-    return true;
-}
 
 void
 PointToPointTest::DoRun (void)
 {
-  Ptr<Node> nodeA = CreateObject<Node> ();
-  Ptr<Node> nodeB = CreateObject<Node> ();
-  m_devA = CreateObject<PointToPointNetDevice> ();
-  m_devB = CreateObject<PointToPointNetDevice> ();
+  Ptr<Node> a = CreateObject<Node> ();
+  Ptr<Node> b = CreateObject<Node> ();
+  Ptr<PointToPointNetDevice> devA = CreateObject<PointToPointNetDevice> ();
+  Ptr<PointToPointNetDevice> devB = CreateObject<PointToPointNetDevice> ();
   Ptr<PointToPointChannel> channel = CreateObject<PointToPointChannel> ();
-  channel->SetAttribute("Delay", TimeValue(m_forwardDelay));
-  channel->SetAttribute("AlternateDelay", TimeValue(m_backwardDelay));
-
-  m_devA->Attach (channel);
-  m_devA->SetAddress (Mac48Address::Allocate ());
-  m_devA->SetQueue (CreateObject<DropTailQueue> ());
-  m_devB->Attach (channel);
-  m_devB->SetAddress (Mac48Address::Allocate ());
-  m_devB->SetQueue (CreateObject<DropTailQueue> ());
 
+  devA->Attach (channel);
+  devA->SetAddress (Mac48Address::Allocate ());
+  devA->SetQueue (CreateObject<DropTailQueue> ());
+  devB->Attach (channel);
+  devB->SetAddress (Mac48Address::Allocate ());
+  devB->SetQueue (CreateObject<DropTailQueue> ());
 
-  nodeA->AddDevice (m_devA);
-  nodeB->AddDevice (m_devB);
+  a->AddDevice (devA);
+  b->AddDevice (devB);
 
-  m_devA->SetReceiveCallback( MakeCallback(&PointToPointTest::RecvOnePacket, this) );
-  m_devB->SetReceiveCallback( MakeCallback(&PointToPointTest::RecvOnePacket, this) );
+  Simulator::Schedule (Seconds (1.0), &PointToPointTest::SendOnePacket, this, devA);
 
-  Simulator::Schedule (testStartTime, &PointToPointTest::SendOnePacket, this, m_devA);
-
-//  NS_TEST_ASSERT_MSG_EQ(true, false, "toto");
   Simulator::Run ();
 
   Simulator::Destroy ();
-
-  std::cout << "1st packet arrival=" << m_packetArrival[0].As(Time::MS)
-            << " (=" << (testStartTime + m_forwardDelay).As(Time::MS) << " ?)"
-            << std::endl;
-  std::cout << "2nd packet arrival=" << m_packetArrival[1].As(Time::MS)
-            << " to compare with :" << testStartTime + m_forwardDelay + m_backwardDelay
-            << std::endl;
-
-  NS_TEST_ASSERT_MSG_EQ_TOL( m_packetArrival[0], testStartTime + m_forwardDelay, tolerance, "Forward delay out of bounds");
-  NS_TEST_ASSERT_MSG_EQ_TOL( m_packetArrival[1], testStartTime + m_forwardDelay + m_backwardDelay, tolerance, "Backward delay out of bounds");
-
 }
 
 /**
@@ -157,7 +108,7 @@ public:
 PointToPointTestSuite::PointToPointTestSuite ()
   : TestSuite ("devices-point-to-point", UNIT)
 {
-  AddTestCase (new PointToPointTest(MilliSeconds(50), MilliSeconds(150)), TestCase::QUICK);
+  AddTestCase (new PointToPointTest, TestCase::QUICK);
 }
 
 static PointToPointTestSuite g_pointToPointTestSuite; //!< The testsuite
diff --git a/src/test/ns3tcp/ns3tcp-no-delay-test-suite.cc b/src/test/ns3tcp/ns3tcp-no-delay-test-suite.cc
index fd1ea3d..5394139 100644
--- a/src/test/ns3tcp/ns3tcp-no-delay-test-suite.cc
+++ b/src/test/ns3tcp/ns3tcp-no-delay-test-suite.cc
@@ -167,12 +167,13 @@ Ns3TcpNoDelayTestCase::DoRun (void)
       if (m_noDelay)
         {
           oss << "tcp-no-delay-on-test-case";
+          pointToPoint.EnablePcapAll (oss.str ());
         }
       else
         {
           oss << "tcp-no-delay-off-test-case";
+          pointToPoint.EnablePcapAll (oss.str ());
         }
-      pointToPoint.EnablePcapAll (oss.str ());
     }
 
   Simulator::Stop (simStopTimeObj);
diff --git a/utils/.ycm_extra_conf.py b/utils/.ycm_extra_conf.py
deleted file mode 100644
index 9eaa952..0000000
--- a/utils/.ycm_extra_conf.py
+++ /dev/null
@@ -1,183 +0,0 @@
-#!/usr/bin/env python
-#
-# Copyright (C) 2014  Google Inc.
-#
-# This file is part of YouCompleteMe.
-#
-# YouCompleteMe is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# YouCompleteMe is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with YouCompleteMe.  If not, see <http://www.gnu.org/licenses/>.
-
-import os
-import ycm_core
-import logging
-import subprocess
-
-log = logging.getLogger(__name__)
-
-# https://github.com/Valloric/YouCompleteMe/issues/1478
-# echo | clang -stdlib=libc++ -v -E -x c++ - 
-
-LOG_FILENAME = '/tmp/matt.log'
-
-
-# Set up a specific logger with our desired output level
-log = logging.getLogger('MyLogger')
-log.setLevel(logging.DEBUG)
-
-# Add the log message handler to the logger
-handler = logging.FileHandler(LOG_FILENAME)
-log.addHandler(handler)
-# log.addHandler()
-
-# that's what we have to fill
-
-def GetClangStandardHeaders():
-  system_flags = []
-
-  res = subprocess.check_output("sed -n '/#include <...> search starts here/,/End of search list/{//!p}' result.txt", shell=True)
-  res = res.decode()
-  system_headers = res.splitlines()
-
-  for include in system_headers:
-    system_flags.append('-isystem')
-    log.info("Appended system %s" % include)
-    system_flags.append(include.strip())
-
-  return system_flags
-
-
-
-def DirectoryOfThisScript():
-  return os.path.dirname( os.path.abspath( __file__ ) )
-
-# Set this to the absolute path to the folder (NOT the file!) containing the
-# compile_commands.json file to use that instead of 'flags'. See here for
-# more details: http://clang.llvm.org/docs/JSONCompilationDatabase.html
-#
-# Most projects will NOT need to set this to anything; you can just change the
-# 'flags' list of compilation flags.
-compilation_database_folder = os.path.join(DirectoryOfThisScript(),'build/')
-
-if os.path.exists( compilation_database_folder ):
-  log.info("Loading database")
-  database = ycm_core.CompilationDatabase( compilation_database_folder )
-  log.info("database should be loaded: %r" % database)
-else:
-  database = None
-
-SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]
-
-
-
-def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):
-  if not working_directory:
-    return list( flags )
-  new_flags = []
-  make_next_absolute = False
-  path_flags = [ '-isystem', '-I', '-iquote', '--sysroot=' ]
-  for flag in flags:
-    new_flag = flag
-
-    if make_next_absolute:
-      make_next_absolute = False
-      if not flag.startswith( '/' ):
-        new_flag = os.path.join( working_directory, flag )
-
-    for path_flag in path_flags:
-      if flag == path_flag:
-        make_next_absolute = True
-        break
-
-      if flag.startswith( path_flag ):
-        path = flag[ len( path_flag ): ]
-        new_flag = path_flag + os.path.join( working_directory, path )
-        break
-
-    if new_flag:
-      new_flags.append( new_flag )
-  return new_flags
-
-
-def IsHeaderFile( filename ):
-  extension = os.path.splitext( filename )[ 1 ]
-  return extension in [ '.h', '.hxx', '.hpp', '.hh' ]
-
-
-
-def MatchHeaderToSource( filename ):
-  """
-  NS3 headers are copied into a specific folder thus stock 
-  YCM functions don't fit the bill
-  Return the .cc associated with the .h
-  """
-  log.debug("MatchHeaderToSource: %s" % filename)
-  filename = os.path.basename(filename)
-  filename = os.path.splitext( filename )[ 0 ]
-  filename += ".cc"
-  log.debug("Looking for implementation of %s" % filename)
-  # be careful it is the python 2.7 version and as such does not return bytes
-  try:
-    match = subprocess.check_output("find src -name %s" % (filename), shell=True)
-    match=match.strip()
-  except Exception as e:
-    log.error("Could not map header to implementation: %s:" % e)
-
-  match = os.path.abspath(match) 
-  return match
-
-
-def GetCompilationInfoForFile( filename ):
-  # The compilation_commands.json file generated by CMake does not have entries
-  # for header files. So we do our best by asking the db for flags for a
-  # corresponding source file, if any. If one exists, the flags for that file
-  # should be good enough.
-  log.debug("GetCompilationInfoForFile called with parameter=%s" % filename)
-  final_name = filename
-  if IsHeaderFile( filename ):
-    final_name = MatchHeaderToSource( filename)
-  
-  log.info("compilation_info for =%s" % final_name)
-
-  return database.GetCompilationInfoForFile( final_name )
-
-
-# This is the entry point; this function is called by ycmd to produce flags for
-# a file.
-def FlagsForFile( filename, **kwargs ):
-  log.debug("== Getting flags for file %s" % filename)
-  if database:
-    # Bear in mind that compilation_info.compiler_flags_ does NOT return a
-    # python list, but a "list-like" StringVec object
-    compilation_info = GetCompilationInfoForFile( filename )
-    if not compilation_info:
-      log.warn("Could not find info for this one")
-      return None
-    
-    log.debug(" flags before being made relative %s" % compilation_info.compiler_flags_)
-
-    # this should not be necessary, I leave it just in case
-  flags = MakeRelativePathsInFlagsAbsolute(
-      compilation_info.compiler_flags_,
-      compilation_info.compiler_working_dir_ )
-    
-  flags += GetClangStandardHeaders();
-
-    #relative_to = DirectoryOfThisScript()
-    #final_flags = MakeRelativePathsInFlagsAbsolute( flags, relative_to )
-  
-  log.debug("Open filename '%s': found flags=%s\n" % (filename, flags))
-  return {
-    'flags': flags,
-    'do_cache': True
-  }
-
diff --git a/waf-tools/cflags.py b/waf-tools/cflags.py
index c6872b7..2e95695 100644
--- a/waf-tools/cflags.py
+++ b/waf-tools/cflags.py
@@ -46,7 +46,7 @@ class GccTraits(CompilerTraits):
 		elif level == 1:
 			return (['-g'], [])
 		elif level >= 2:
-			return (['-g', '-g3', '-frecord-gcc-switches'], ['_DEBUG'])
+			return (['-ggdb', '-g3'], ['_DEBUG'])
 		
 
 class IccTraits(CompilerTraits):
diff --git a/wscript b/wscript
index 1e8adce..02d2562 100644
--- a/wscript
+++ b/wscript
@@ -30,7 +30,7 @@ examples_enabled = False
 tests_enabled    = False
 
 # Bug 1868:  be conservative about -Wstrict-overflow for optimized builds
-# on older compilers; it can generate spurious warnings.
+# on older compilers; it can generate spurious warnings.  
 cc_version_warn_strict_overflow = ('4', '8', '2')
 
 # Get the information out of the NS-3 configuration file.
@@ -302,22 +302,6 @@ def configure(conf):
 
     env = conf.env
 
-    #have_crypto = False
-#    conf.env['HAVE_CRYPTO'] = have_crypto
-    #def debug_matt():
-        #print(conf.env['HAVE_GCRYPT']) 
-        #print(conf.env.LIB_GCRYPT)
-        #print(conf.env.LIBPATH_GCRYPT)
-        #print(conf.env.INCLUDES_GCRYPT)
-
-    #debug_matt()
-    conf.env.LIB_GCRYPT = ['gcrypt']
-    conf.env.HAVE_GCRYPT = True
-    #conf.env.LIBPATH_GCRYPT = ['/folder/to/gcrypt/lib']
-    #conf.env.INCLUDES_GCRYPT = ['/folder/to/gcrypt/includes']
-    #debug_matt()
-
-
     if Options.options.enable_gcov:
         env['GCOV_ENABLED'] = True
         env.append_value('CCFLAGS', '-fprofile-arcs')
@@ -327,7 +311,6 @@ def configure(conf):
         env.append_value('LINKFLAGS', '-lgcov')
         env.append_value('LINKFLAGS', '-coverage')
 
-
     if Options.options.build_profile == 'debug':
         env.append_value('DEFINES', 'NS3_ASSERT_ENABLE')
         env.append_value('DEFINES', 'NS3_LOG_ENABLE')
@@ -338,16 +321,16 @@ def configure(conf):
         env['BUILD_SUFFIX'] = ''
     else:
         env['BUILD_SUFFIX'] = '-'+Options.options.build_profile
-
+    
     env['APPNAME'] = wutils.APPNAME
     env['VERSION'] = wutils.VERSION
 
     if conf.env['CXX_NAME'] in ['gcc', 'icc']:
-        if Options.options.build_profile == 'release':
-            env.append_value('CXXFLAGS', '-fomit-frame-pointer')
-        if Options.options.build_profile == 'optimized':
+        if Options.options.build_profile == 'release': 
+            env.append_value('CXXFLAGS', '-fomit-frame-pointer') 
+        if Options.options.build_profile == 'optimized': 
             if conf.check_compilation_flag('-march=native'):
-                env.append_value('CXXFLAGS', '-march=native')
+                env.append_value('CXXFLAGS', '-march=native') 
             env.append_value('CXXFLAGS', '-fstrict-overflow')
             if conf.env['CC_VERSION'] == cc_version_warn_strict_overflow:
                 env.append_value('CXXFLAGS', '-Wstrict-overflow=5')
@@ -398,7 +381,7 @@ def configure(conf):
 
     # Set the list of enabled modules.
     if Options.options.enable_modules:
-        # Use the modules explicitly enabled.
+        # Use the modules explicitly enabled. 
         conf.env['NS3_ENABLED_MODULES'] = ['ns3-'+mod for mod in
                                            Options.options.enable_modules.split(',')]
     else:
@@ -448,11 +431,11 @@ def configure(conf):
 
     # Decide if tests will be built or not.
     if Options.options.enable_tests:
-        # Tests were explicitly enabled.
+        # Tests were explicitly enabled. 
         env['ENABLE_TESTS'] = True
         why_not_tests = "option --enable-tests selected"
     elif Options.options.disable_tests:
-        # Tests were explicitly disabled.
+        # Tests were explicitly disabled. 
         env['ENABLE_TESTS'] = False
         why_not_tests = "option --disable-tests selected"
     else:
@@ -469,11 +452,11 @@ def configure(conf):
 
     # Decide if examples will be built or not.
     if Options.options.enable_examples:
-        # Examples were explicitly enabled.
+        # Examples were explicitly enabled. 
         env['ENABLE_EXAMPLES'] = True
         why_not_examples = "option --enable-examples selected"
     elif Options.options.disable_examples:
-        # Examples were explicitly disabled.
+        # Examples were explicitly disabled. 
         env['ENABLE_EXAMPLES'] = False
         why_not_examples = "option --disable-examples selected"
     else:
@@ -493,7 +476,7 @@ def configure(conf):
         if os.path.isdir(os.path.join('examples', dir)):
             env['EXAMPLE_DIRECTORIES'].append(dir)
 
-    conf.report_optional_feature("ENABLE_EXAMPLES", "Build examples", env['ENABLE_EXAMPLES'],
+    conf.report_optional_feature("ENABLE_EXAMPLES", "Build examples", env['ENABLE_EXAMPLES'], 
                                  why_not_examples)
 
     env['VALGRIND_FOUND'] = False
@@ -506,7 +489,7 @@ def configure(conf):
     # These flags are used for the implicitly dependent modules.
     if env['ENABLE_STATIC_NS3']:
         if sys.platform == 'darwin':
-           env.STLIB_MARKER = '-Wl,-all_load'
+            env.STLIB_MARKER = '-Wl,-all_load'
         else:
             env.STLIB_MARKER = '-Wl,--whole-archive,-Bstatic'
             env.SHLIB_MARKER = '-Wl,-Bdynamic,--no-whole-archive'
@@ -519,75 +502,8 @@ def configure(conf):
                                  conf.env['ENABLE_GSL'],
                                  "GSL not found")
 
-
-
-#https://groups.google.com/forum/#!searchin/waf-users/link$20order/waf-users/DrkpsGnnpGw/aQVgeud37QkJ
-    have_crypto = conf.check_cxx( msg="Checking for libgcrypt", lib="gcrypt",
-		define_name="HAVE_CRYPTO", mandatory=False)
-		# doc here https://waf.io/apidocs/tools/c_config.html#waflib.Tools.c_config.check_cfg
-    #have_crypto = conf.check_cfg(path='libgcrypt-config', args='--libs', package="GCRYPT",
-         #uselib_store='GCRYPT', mandatory=False, msg="gcrypt check", okmsg=" libgcrypt found", errmsg=" erreur" ,
-    conf.env['HAVE_CRYPTO'] = True
-         #define_name="HAVE_CRYPTO")
-#output = subprocess.check_output(['libgcrypt-config --libs'])
-	#print(output)
-	#add_gcc_flag(output)
-    conf.report_optional_feature("libgcrypt", "gcrypt library",
-                                 have_crypto, "libgcrypt not found")
-
-
-#@before('apply_link')
-#def _custom_link(self):
-        #link_str = '${LINK_CXX} ${CXXLNK_SRC_F}${SRC} ${CXXLNK_TGT_F}${TGT}'
-
-                ## resolve circular references between libraries
-                        #link_str += ' -Wl,--start-group ${LINKFLAGS} -Wl,--end-group'
-
-    #Task.simple_task_type('CUSTOM_LINK', link_str, color='YELLOW', ext_in='.o')
-        #self.link = 'CUSTOM_LINK'
-    ##@feature('c', 'cxx', 'd', 'fc', 'javac', 'cs', 'uselib', 'asm')                                                                       
-    ##@after_method('process_use')
-    #def my_propagate_uselib_vars(self):
-            #"""
-            #Process uselib variables for adding flags. For example, the following target::
-
-                    #def build(bld):
-                            #bld.env.AFLAGS_aaa = ['bar']
-                            #from waflib.Tools.ccroot import USELIB_VARS
-                            #USELIB_VARS['aaa'] = set('AFLAGS')
-
-                            #tg = bld(features='aaa', aflags='test')
-
-            #The *aflags* attribute will be processed and this method will set::
-
-                            #tg.env.AFLAGS = ['bar', 'test']
-            #"""
-            #_vars = self.get_uselib_vars()
-            #env = self.env
-            #app = env.append_value
-            #feature_uselib = self.features + self.to_list(getattr(self, 'uselib', []))
-            #for var in _vars:
-                    #y = var.lower()
-                    #val = getattr(self, y, [])
-                    #if val:
-                            #app(var, self.to_list(val))
-
-                    #for x in feature_uselib:
-                            #val = env['%s_%s' % (var, x)]
-                            #if val:
-                                    #app(var, val)
-                    #print("Val=", val)
-    #setattr(TaskGen.task_gen, 'propagate_uselib_vars', my_propagate_uselib_vars)
-
-    #@TaskGen.feature('my_precious')
-    #@TaskGen.after('apply_link')
-    #def i_mess_with_the_link_flags(self):
-        #print("toto")
-        #self.link_task.env.LINKFLAGS.insert("-lgcrypt",0)
-
     # for compiling C code, copy over the CXX* flags
     conf.env.append_value('CCFLAGS', conf.env['CXXFLAGS'])
-    #setattr(TaskGen.task_gen, 'apply_lib_vars', my_apply_lib_vars)
 
     def add_gcc_flag(flag):
         if env['COMPILER_CXX'] == 'g++' and 'CXXFLAGS' not in os.environ:
@@ -622,8 +538,8 @@ def configure(conf):
     bld = wutils.bld
     print "%-30s: %s%s%s" % ("Build directory", Logs.colors('GREEN'),
                              Options.options.out, Logs.colors('NORMAL'))
-
-
+    
+    
     for (name, caption, was_enabled, reason_not_enabled) in conf.env['NS3_OPTIONAL_FEATURES']:
         if was_enabled:
             status = 'enabled'
@@ -694,7 +610,6 @@ def create_ns3_program(bld, name, dependencies=('core',)):
     program.ns3_module_dependencies = ['ns3-'+dep for dep in dependencies]
     program.includes = "#"
     program.use = program.ns3_module_dependencies
-    program.use.append('GCRYPT')
     if program.env['ENABLE_STATIC_NS3']:
         if sys.platform == 'darwin':
             program.env.STLIB_MARKER = '-Wl,-all_load'
@@ -704,8 +619,9 @@ def create_ns3_program(bld, name, dependencies=('core',)):
     else:
         if program.env.DEST_BINFMT == 'elf':
             # All ELF platforms are impacted but only the gcc compiler has a flag to fix it.
-            if 'gcc' in (program.env.CXX_NAME, program.env.CC_NAME):
+            if 'gcc' in (program.env.CXX_NAME, program.env.CC_NAME): 
                 program.env.append_value ('SHLIB_MARKER', '-Wl,--no-as-needed')
+
     return program
 
 def register_ns3_script(bld, name, dependencies=('core',)):
@@ -725,7 +641,7 @@ def add_scratch_programs(bld):
     all_modules = [mod[len("ns3-"):] for mod in bld.env['NS3_ENABLED_MODULES']]
     for filename in os.listdir("scratch"):
         if filename.startswith('.') or filename == 'CVS':
-		continue
+	    continue
         if os.path.isdir(os.path.join("scratch", filename)):
             obj = bld.create_ns3_program(filename, all_modules)
             obj.path = obj.path.find_dir('scratch').find_dir(filename)
@@ -866,7 +782,7 @@ def build(bld):
                 # Add this program to the list if all of its
                 # dependencies will be built.
                 if program_built:
-                    object_name = "%s%s-%s%s" % (wutils.APPNAME, wutils.VERSION,
+                    object_name = "%s%s-%s%s" % (wutils.APPNAME, wutils.VERSION, 
                                                   obj.name, bld.env.BUILD_SUFFIX)
 
                     # Get the relative path to the program from the
@@ -890,12 +806,12 @@ def build(bld):
             # disable the ns3header_taskgen
             if 'ns3header' in getattr(obj, "features", []):
                 if ("ns3-%s" % obj.module) not in modules:
-                    obj.mode = 'remove' # tell it to remove headers instead of installing
+                    obj.mode = 'remove' # tell it to remove headers instead of installing 
 
             # disable the ns3privateheader_taskgen
             if 'ns3privateheader' in getattr(obj, "features", []):
                 if ("ns3-%s" % obj.module) not in modules:
-                    obj.mode = 'remove' # tell it to remove headers instead of installing
+                    obj.mode = 'remove' # tell it to remove headers instead of installing 
 
             # disable pcfile taskgens for disabled modules
             if 'ns3pcfile' in getattr(obj, "features", []):
@@ -947,7 +863,7 @@ def build(bld):
         for gen in bld.all_task_gen:
             if type(gen).__name__ in ['ns3header_taskgen', 'ns3privateheader_taskgen', 'ns3moduleheader_taskgen']:
                 gen.post()
-        bld.env['PRINT_BUILT_MODULES_AT_END'] = False
+        bld.env['PRINT_BUILT_MODULES_AT_END'] = False 
 
     if Options.options.doxygen_no_build:
         _doxygen(bld)
@@ -1065,7 +981,7 @@ class print_introspected_doxygen_task(Task.TaskBase):
     def __init__(self, bld):
         self.bld = bld
         super(print_introspected_doxygen_task, self).__init__(generator=self)
-
+        
     def __str__(self):
         return 'print-introspected-doxygen\n'
 
@@ -1090,7 +1006,7 @@ class print_introspected_doxygen_task(Task.TaskBase):
             if subprocess.Popen([prog], stdout=doxygen_out, env=proc_env).wait():
                 raise SystemExit(1)
             doxygen_out.close()
-
+        
             # Create a text file with the introspected information.
             text_out = open(os.path.join('doc', 'ns3-object.txt'), 'w')
             if subprocess.Popen([prog, '--output-text'], stdout=text_out, env=proc_env).wait():
@@ -1104,7 +1020,7 @@ class run_python_unit_tests_task(Task.TaskBase):
     def __init__(self, bld):
         self.bld = bld
         super(run_python_unit_tests_task, self).__init__(generator=self)
-
+        
     def __str__(self):
         return 'run-python-unit-tests\n'
 
@@ -1177,7 +1093,7 @@ def _doxygen(bld):
 
     try:
         program_obj = wutils.find_program('print-introspected-doxygen', env)
-    except ValueError:
+    except ValueError: 
         Logs.warn("print-introspected-doxygen does not exist")
         raise SystemExit(1)
         return
@@ -1230,7 +1146,7 @@ class Ns3DoxygenContext(Context.Context):
 
 class Ns3SphinxContext(Context.Context):
     """build the Sphinx documentation: manual, tutorial, models"""
-
+    
     cmd = 'sphinx'
 
     def sphinx_build(self, path):
@@ -1246,18 +1162,18 @@ class Ns3SphinxContext(Context.Context):
         _getVersion()
         for sphinxdir in ["manual", "models", "tutorial", "tutorial-pt-br"] :
             self.sphinx_build(os.path.join("doc", sphinxdir))
-
+     
 
 class Ns3DocContext(Context.Context):
     """build all the documentation: doxygen, manual, tutorial, models"""
-
+    
     cmd = 'docs'
 
     def execute(self):
         steps = ['doxygen', 'sphinx']
         Options.commands = steps + Options.commands
-
-
+        
+    
 def lcov_report(bld):
     env = bld.env
 
